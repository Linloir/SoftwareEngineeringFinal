// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'package:json_annotation/json_annotation.dart';
import 'package:orm/binary_engine.dart' as _i5;
import 'package:orm/engine_core.dart' as _i3;
import 'package:orm/graphql.dart' as _i2;
import 'package:orm/logger.dart' as _i4;
import 'package:orm/orm.dart' as _i1;
import 'package:orm/orm.dart' show DateTimeJsonConverter;

part 'prisma_client.g.dart';

enum CategoryScalarFieldEnum implements _i1.PrismaEnum {
  name,
  color,
  icon,
  userId,
  profileName,
  updateAt,
  syncAt,
  deleteAt;

  @override
  String? get originalName => null;
}

enum ChannelScalarFieldEnum implements _i1.PrismaEnum {
  uuid,
  name,
  desc,
  color,
  imgRef,
  userId,
  profileName,
  updateAt,
  syncAt,
  deleteAt;

  @override
  String? get originalName => null;
}

enum ChannelSubscriptionScalarFieldEnum implements _i1.PrismaEnum {
  shareRecord,
  channelUuid,
  userId,
  profileName,
  updateAt,
  syncAt,
  deleteAt;

  @override
  String? get originalName => null;
}

enum FileRefScalarFieldEnum implements _i1.PrismaEnum {
  hash,
  count;

  @override
  String? get originalName => null;
}

enum ProfileScalarFieldEnum implements _i1.PrismaEnum {
  name,
  color,
  icon,
  userId,
  updateAt,
  syncAt,
  deleteAt;

  @override
  String? get originalName => null;
}

enum QueryMode implements _i1.PrismaEnum {
  @JsonValue('default')
  $default(r'default'),
  insensitive;

  const QueryMode([this.originalName]);

  @override
  final String? originalName;
}

enum RecordAttachmentScalarFieldEnum implements _i1.PrismaEnum {
  hash,
  name,
  assetRef,
  sessionUuid,
  taskUuid,
  userId,
  profileName,
  recordIndex,
  updateAt,
  syncAt,
  deleteAt;

  @override
  String? get originalName => null;
}

enum RecordScalarFieldEnum implements _i1.PrismaEnum {
  time,
  recordIndex,
  sessionUuid,
  taskUuid,
  userId,
  profileName,
  updateAt,
  syncAt,
  deleteAt;

  @override
  String? get originalName => null;
}

enum ScheduleScalarFieldEnum implements _i1.PrismaEnum {
  relStart,
  relEnd,
  sessionUuid,
  userId,
  profileName,
  updateAt,
  syncAt,
  deleteAt;

  @override
  String? get originalName => null;
}

enum SessionScalarFieldEnum implements _i1.PrismaEnum {
  uuid,
  start,
  end,
  cycle,
  taskUuid,
  updateAt,
  syncAt,
  deleteAt;

  @override
  String? get originalName => null;
}

enum SortOrder implements _i1.PrismaEnum {
  asc,
  desc;

  @override
  String? get originalName => null;
}

enum TagScalarFieldEnum implements _i1.PrismaEnum {
  name,
  color,
  icon,
  userId,
  profileName,
  updateAt,
  syncAt,
  deleteAt;

  @override
  String? get originalName => null;
}

enum TaskAssetScalarFieldEnum implements _i1.PrismaEnum {
  name,
  hash,
  assetRef,
  taskUuid,
  updateAt,
  syncAt,
  deleteAt;

  @override
  String? get originalName => null;
}

enum TaskAssignmentScalarFieldEnum implements _i1.PrismaEnum {
  status,
  priority,
  starred,
  taskUuid,
  userId,
  profileName,
  categoryName,
  updateAt,
  syncAt,
  deleteAt;

  @override
  String? get originalName => null;
}

enum TaskAssignmentTagsScalarFieldEnum implements _i1.PrismaEnum {
  taskUuid,
  userId,
  profileName,
  tagName;

  @override
  String? get originalName => null;
}

enum TaskScalarFieldEnum implements _i1.PrismaEnum {
  uuid,
  title,
  desc,
  content,
  location,
  requireLocation,
  requireTime,
  requireAttachment,
  userId,
  profile,
  parentUuid,
  channelUuid,
  updateAt,
  syncAt,
  deleteAt;

  @override
  String? get originalName => null;
}

enum UserScalarFieldEnum implements _i1.PrismaEnum {
  id,
  name,
  email,
  phone,
  password,
  avatarRef,
  unionId,
  tencentId,
  appleId;

  @override
  String? get originalName => null;
}

enum TaskAssignmentStatus implements _i1.PrismaEnum {
  @JsonValue('ACCEPTED')
  accepted(r'ACCEPTED'),
  @JsonValue('REJECTED')
  rejected(r'REJECTED');

  const TaskAssignmentStatus([this.originalName]);

  @override
  final String? originalName;
}

enum TaskPriority implements _i1.PrismaEnum {
  @JsonValue('NONE')
  none(r'NONE'),
  @JsonValue('LOW')
  low(r'LOW'),
  @JsonValue('MEDIUM')
  medium(r'MEDIUM'),
  @JsonValue('HIGH')
  high(r'HIGH'),
  @JsonValue('URGENT')
  urgent(r'URGENT');

  const TaskPriority([this.originalName]);

  @override
  final String? originalName;
}

@_i1.jsonSerializable
class UserWhereInput implements _i1.JsonSerializable {
  const UserWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.email,
    this.phone,
    this.password,
    this.avatarRef,
    this.unionId,
    this.tencentId,
    this.appleId,
    this.profiles,
  });

  factory UserWhereInput.fromJson(Map<String, dynamic> json) =>
      _$UserWhereInputFromJson(json);

  final Iterable<UserWhereInput>? AND;

  final Iterable<UserWhereInput>? OR;

  final Iterable<UserWhereInput>? NOT;

  final IntFilter? id;

  final StringFilter? name;

  final StringNullableFilter? email;

  final StringNullableFilter? phone;

  final StringFilter? password;

  final StringNullableFilter? avatarRef;

  final StringNullableFilter? unionId;

  final StringNullableFilter? tencentId;

  final StringNullableFilter? appleId;

  final ProfileListRelationFilter? profiles;

  @override
  Map<String, dynamic> toJson() => _$UserWhereInputToJson(this);
}

@_i1.jsonSerializable
class UserOrderByWithRelationInput implements _i1.JsonSerializable {
  const UserOrderByWithRelationInput({
    this.id,
    this.name,
    this.email,
    this.phone,
    this.password,
    this.avatarRef,
    this.unionId,
    this.tencentId,
    this.appleId,
    this.profiles,
  });

  factory UserOrderByWithRelationInput.fromJson(Map<String, dynamic> json) =>
      _$UserOrderByWithRelationInputFromJson(json);

  final SortOrder? id;

  final SortOrder? name;

  final SortOrder? email;

  final SortOrder? phone;

  final SortOrder? password;

  final SortOrder? avatarRef;

  final SortOrder? unionId;

  final SortOrder? tencentId;

  final SortOrder? appleId;

  final ProfileOrderByRelationAggregateInput? profiles;

  @override
  Map<String, dynamic> toJson() => _$UserOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class UserWhereUniqueInput implements _i1.JsonSerializable {
  const UserWhereUniqueInput({
    this.id,
    this.email,
    this.phone,
    this.unionId,
    this.tencentId,
    this.appleId,
  });

  factory UserWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$UserWhereUniqueInputFromJson(json);

  final int? id;

  final String? email;

  final String? phone;

  final String? unionId;

  final String? tencentId;

  final String? appleId;

  @override
  Map<String, dynamic> toJson() => _$UserWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class UserOrderByWithAggregationInput implements _i1.JsonSerializable {
  const UserOrderByWithAggregationInput({
    this.id,
    this.name,
    this.email,
    this.phone,
    this.password,
    this.avatarRef,
    this.unionId,
    this.tencentId,
    this.appleId,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory UserOrderByWithAggregationInput.fromJson(Map<String, dynamic> json) =>
      _$UserOrderByWithAggregationInputFromJson(json);

  final SortOrder? id;

  final SortOrder? name;

  final SortOrder? email;

  final SortOrder? phone;

  final SortOrder? password;

  final SortOrder? avatarRef;

  final SortOrder? unionId;

  final SortOrder? tencentId;

  final SortOrder? appleId;

  @JsonKey(name: r'_count')
  final UserCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final UserAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final UserMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final UserMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final UserSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$UserOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class UserScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const UserScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.email,
    this.phone,
    this.password,
    this.avatarRef,
    this.unionId,
    this.tencentId,
    this.appleId,
  });

  factory UserScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$UserScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<UserScalarWhereWithAggregatesInput>? AND;

  final Iterable<UserScalarWhereWithAggregatesInput>? OR;

  final Iterable<UserScalarWhereWithAggregatesInput>? NOT;

  final IntWithAggregatesFilter? id;

  final StringWithAggregatesFilter? name;

  final StringNullableWithAggregatesFilter? email;

  final StringNullableWithAggregatesFilter? phone;

  final StringWithAggregatesFilter? password;

  final StringNullableWithAggregatesFilter? avatarRef;

  final StringNullableWithAggregatesFilter? unionId;

  final StringNullableWithAggregatesFilter? tencentId;

  final StringNullableWithAggregatesFilter? appleId;

  @override
  Map<String, dynamic> toJson() =>
      _$UserScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class ProfileWhereInput implements _i1.JsonSerializable {
  const ProfileWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.user,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileWhereInput.fromJson(Map<String, dynamic> json) =>
      _$ProfileWhereInputFromJson(json);

  final Iterable<ProfileWhereInput>? AND;

  final Iterable<ProfileWhereInput>? OR;

  final Iterable<ProfileWhereInput>? NOT;

  final StringFilter? name;

  final StringFilter? color;

  final StringFilter? icon;

  final IntFilter? userId;

  final BigIntFilter? updateAt;

  final BigIntFilter? syncAt;

  final BigIntFilter? deleteAt;

  final UserRelationFilter? user;

  final CategoryListRelationFilter? categories;

  final TagListRelationFilter? tags;

  final TaskListRelationFilter? tasks;

  final ChannelListRelationFilter? channels;

  final TaskAssignmentListRelationFilter? taskAssignments;

  final ChannelSubscriptionListRelationFilter? channelSubscriptions;

  final ScheduleListRelationFilter? schedules;

  final RecordListRelationFilter? records;

  @override
  Map<String, dynamic> toJson() => _$ProfileWhereInputToJson(this);
}

@_i1.jsonSerializable
class ProfileOrderByWithRelationInput implements _i1.JsonSerializable {
  const ProfileOrderByWithRelationInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.user,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileOrderByWithRelationInput.fromJson(Map<String, dynamic> json) =>
      _$ProfileOrderByWithRelationInputFromJson(json);

  final SortOrder? name;

  final SortOrder? color;

  final SortOrder? icon;

  final SortOrder? userId;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  final UserOrderByWithRelationInput? user;

  final CategoryOrderByRelationAggregateInput? categories;

  final TagOrderByRelationAggregateInput? tags;

  final TaskOrderByRelationAggregateInput? tasks;

  final ChannelOrderByRelationAggregateInput? channels;

  final TaskAssignmentOrderByRelationAggregateInput? taskAssignments;

  final ChannelSubscriptionOrderByRelationAggregateInput? channelSubscriptions;

  final ScheduleOrderByRelationAggregateInput? schedules;

  final RecordOrderByRelationAggregateInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class ProfileWhereUniqueInput implements _i1.JsonSerializable {
  const ProfileWhereUniqueInput({this.userIdName});

  factory ProfileWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$ProfileWhereUniqueInputFromJson(json);

  @JsonKey(name: r'userId_name')
  final ProfileUserIdNameCompoundUniqueInput? userIdName;

  @override
  Map<String, dynamic> toJson() => _$ProfileWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class ProfileOrderByWithAggregationInput implements _i1.JsonSerializable {
  const ProfileOrderByWithAggregationInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory ProfileOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileOrderByWithAggregationInputFromJson(json);

  final SortOrder? name;

  final SortOrder? color;

  final SortOrder? icon;

  final SortOrder? userId;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @JsonKey(name: r'_count')
  final ProfileCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final ProfileAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final ProfileMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final ProfileMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final ProfileSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class ProfileScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const ProfileScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ProfileScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<ProfileScalarWhereWithAggregatesInput>? AND;

  final Iterable<ProfileScalarWhereWithAggregatesInput>? OR;

  final Iterable<ProfileScalarWhereWithAggregatesInput>? NOT;

  final StringWithAggregatesFilter? name;

  final StringWithAggregatesFilter? color;

  final StringWithAggregatesFilter? icon;

  final IntWithAggregatesFilter? userId;

  final BigIntWithAggregatesFilter? updateAt;

  final BigIntWithAggregatesFilter? syncAt;

  final BigIntWithAggregatesFilter? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class TaskWhereInput implements _i1.JsonSerializable {
  const TaskWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.userId,
    this.profile,
    this.parentUuid,
    this.channelUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.owner,
    this.parent,
    this.children,
    this.channel,
    this.assets,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskWhereInput.fromJson(Map<String, dynamic> json) =>
      _$TaskWhereInputFromJson(json);

  final Iterable<TaskWhereInput>? AND;

  final Iterable<TaskWhereInput>? OR;

  final Iterable<TaskWhereInput>? NOT;

  final StringFilter? uuid;

  final StringFilter? title;

  final StringFilter? desc;

  final StringFilter? content;

  final StringNullableFilter? location;

  final BoolFilter? requireLocation;

  final BoolFilter? requireTime;

  final BoolFilter? requireAttachment;

  final IntFilter? userId;

  final StringFilter? profile;

  final StringNullableFilter? parentUuid;

  final StringNullableFilter? channelUuid;

  final BigIntFilter? updateAt;

  final BigIntFilter? syncAt;

  final BigIntFilter? deleteAt;

  final ProfileRelationFilter? owner;

  final TaskRelationFilter? parent;

  final TaskListRelationFilter? children;

  final ChannelRelationFilter? channel;

  final TaskAssetListRelationFilter? assets;

  final TaskAssignmentListRelationFilter? assignments;

  final SessionListRelationFilter? sessions;

  final RecordListRelationFilter? records;

  @override
  Map<String, dynamic> toJson() => _$TaskWhereInputToJson(this);
}

@_i1.jsonSerializable
class TaskOrderByWithRelationInput implements _i1.JsonSerializable {
  const TaskOrderByWithRelationInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.userId,
    this.profile,
    this.parentUuid,
    this.channelUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.owner,
    this.parent,
    this.children,
    this.channel,
    this.assets,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskOrderByWithRelationInput.fromJson(Map<String, dynamic> json) =>
      _$TaskOrderByWithRelationInputFromJson(json);

  final SortOrder? uuid;

  final SortOrder? title;

  final SortOrder? desc;

  final SortOrder? content;

  final SortOrder? location;

  final SortOrder? requireLocation;

  final SortOrder? requireTime;

  final SortOrder? requireAttachment;

  final SortOrder? userId;

  final SortOrder? profile;

  final SortOrder? parentUuid;

  final SortOrder? channelUuid;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  final ProfileOrderByWithRelationInput? owner;

  final TaskOrderByWithRelationInput? parent;

  final TaskOrderByRelationAggregateInput? children;

  final ChannelOrderByWithRelationInput? channel;

  final TaskAssetOrderByRelationAggregateInput? assets;

  final TaskAssignmentOrderByRelationAggregateInput? assignments;

  final SessionOrderByRelationAggregateInput? sessions;

  final RecordOrderByRelationAggregateInput? records;

  @override
  Map<String, dynamic> toJson() => _$TaskOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class TaskWhereUniqueInput implements _i1.JsonSerializable {
  const TaskWhereUniqueInput({this.uuid});

  factory TaskWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$TaskWhereUniqueInputFromJson(json);

  final String? uuid;

  @override
  Map<String, dynamic> toJson() => _$TaskWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class TaskOrderByWithAggregationInput implements _i1.JsonSerializable {
  const TaskOrderByWithAggregationInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.userId,
    this.profile,
    this.parentUuid,
    this.channelUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory TaskOrderByWithAggregationInput.fromJson(Map<String, dynamic> json) =>
      _$TaskOrderByWithAggregationInputFromJson(json);

  final SortOrder? uuid;

  final SortOrder? title;

  final SortOrder? desc;

  final SortOrder? content;

  final SortOrder? location;

  final SortOrder? requireLocation;

  final SortOrder? requireTime;

  final SortOrder? requireAttachment;

  final SortOrder? userId;

  final SortOrder? profile;

  final SortOrder? parentUuid;

  final SortOrder? channelUuid;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @JsonKey(name: r'_count')
  final TaskCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final TaskAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final TaskMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final TaskMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final TaskSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class TaskScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const TaskScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.userId,
    this.profile,
    this.parentUuid,
    this.channelUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<TaskScalarWhereWithAggregatesInput>? AND;

  final Iterable<TaskScalarWhereWithAggregatesInput>? OR;

  final Iterable<TaskScalarWhereWithAggregatesInput>? NOT;

  final StringWithAggregatesFilter? uuid;

  final StringWithAggregatesFilter? title;

  final StringWithAggregatesFilter? desc;

  final StringWithAggregatesFilter? content;

  final StringNullableWithAggregatesFilter? location;

  final BoolWithAggregatesFilter? requireLocation;

  final BoolWithAggregatesFilter? requireTime;

  final BoolWithAggregatesFilter? requireAttachment;

  final IntWithAggregatesFilter? userId;

  final StringWithAggregatesFilter? profile;

  final StringNullableWithAggregatesFilter? parentUuid;

  final StringNullableWithAggregatesFilter? channelUuid;

  final BigIntWithAggregatesFilter? updateAt;

  final BigIntWithAggregatesFilter? syncAt;

  final BigIntWithAggregatesFilter? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetWhereInput implements _i1.JsonSerializable {
  const TaskAssetWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.name,
    this.hash,
    this.assetRef,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.task,
  });

  factory TaskAssetWhereInput.fromJson(Map<String, dynamic> json) =>
      _$TaskAssetWhereInputFromJson(json);

  final Iterable<TaskAssetWhereInput>? AND;

  final Iterable<TaskAssetWhereInput>? OR;

  final Iterable<TaskAssetWhereInput>? NOT;

  final StringFilter? name;

  final StringFilter? hash;

  final StringFilter? assetRef;

  final StringFilter? taskUuid;

  final BigIntFilter? updateAt;

  final BigIntFilter? syncAt;

  final BigIntFilter? deleteAt;

  final TaskRelationFilter? task;

  @override
  Map<String, dynamic> toJson() => _$TaskAssetWhereInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetOrderByWithRelationInput implements _i1.JsonSerializable {
  const TaskAssetOrderByWithRelationInput({
    this.name,
    this.hash,
    this.assetRef,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.task,
  });

  factory TaskAssetOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssetOrderByWithRelationInputFromJson(json);

  final SortOrder? name;

  final SortOrder? hash;

  final SortOrder? assetRef;

  final SortOrder? taskUuid;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  final TaskOrderByWithRelationInput? task;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetWhereUniqueInput implements _i1.JsonSerializable {
  const TaskAssetWhereUniqueInput({this.taskUuidHash});

  factory TaskAssetWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$TaskAssetWhereUniqueInputFromJson(json);

  @JsonKey(name: r'taskUuid_hash')
  final TaskAssetTaskUuidHashCompoundUniqueInput? taskUuidHash;

  @override
  Map<String, dynamic> toJson() => _$TaskAssetWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetOrderByWithAggregationInput implements _i1.JsonSerializable {
  const TaskAssetOrderByWithAggregationInput({
    this.name,
    this.hash,
    this.assetRef,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory TaskAssetOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssetOrderByWithAggregationInputFromJson(json);

  final SortOrder? name;

  final SortOrder? hash;

  final SortOrder? assetRef;

  final SortOrder? taskUuid;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @JsonKey(name: r'_count')
  final TaskAssetCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final TaskAssetAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final TaskAssetMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final TaskAssetMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final TaskAssetSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const TaskAssetScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.name,
    this.hash,
    this.assetRef,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssetScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssetScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<TaskAssetScalarWhereWithAggregatesInput>? AND;

  final Iterable<TaskAssetScalarWhereWithAggregatesInput>? OR;

  final Iterable<TaskAssetScalarWhereWithAggregatesInput>? NOT;

  final StringWithAggregatesFilter? name;

  final StringWithAggregatesFilter? hash;

  final StringWithAggregatesFilter? assetRef;

  final StringWithAggregatesFilter? taskUuid;

  final BigIntWithAggregatesFilter? updateAt;

  final BigIntWithAggregatesFilter? syncAt;

  final BigIntWithAggregatesFilter? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class ChannelWhereInput implements _i1.JsonSerializable {
  const ChannelWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.name,
    this.desc,
    this.color,
    this.imgRef,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.owner,
    this.subscriptions,
    this.tasks,
  });

  factory ChannelWhereInput.fromJson(Map<String, dynamic> json) =>
      _$ChannelWhereInputFromJson(json);

  final Iterable<ChannelWhereInput>? AND;

  final Iterable<ChannelWhereInput>? OR;

  final Iterable<ChannelWhereInput>? NOT;

  final StringFilter? uuid;

  final StringFilter? name;

  final StringFilter? desc;

  final StringFilter? color;

  final StringNullableFilter? imgRef;

  final IntFilter? userId;

  final StringFilter? profileName;

  final BigIntFilter? updateAt;

  final BigIntFilter? syncAt;

  final BigIntFilter? deleteAt;

  final ProfileRelationFilter? owner;

  final ChannelSubscriptionListRelationFilter? subscriptions;

  final TaskListRelationFilter? tasks;

  @override
  Map<String, dynamic> toJson() => _$ChannelWhereInputToJson(this);
}

@_i1.jsonSerializable
class ChannelOrderByWithRelationInput implements _i1.JsonSerializable {
  const ChannelOrderByWithRelationInput({
    this.uuid,
    this.name,
    this.desc,
    this.color,
    this.imgRef,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.owner,
    this.subscriptions,
    this.tasks,
  });

  factory ChannelOrderByWithRelationInput.fromJson(Map<String, dynamic> json) =>
      _$ChannelOrderByWithRelationInputFromJson(json);

  final SortOrder? uuid;

  final SortOrder? name;

  final SortOrder? desc;

  final SortOrder? color;

  final SortOrder? imgRef;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  final ProfileOrderByWithRelationInput? owner;

  final ChannelSubscriptionOrderByRelationAggregateInput? subscriptions;

  final TaskOrderByRelationAggregateInput? tasks;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class ChannelWhereUniqueInput implements _i1.JsonSerializable {
  const ChannelWhereUniqueInput({this.uuid});

  factory ChannelWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$ChannelWhereUniqueInputFromJson(json);

  final String? uuid;

  @override
  Map<String, dynamic> toJson() => _$ChannelWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class ChannelOrderByWithAggregationInput implements _i1.JsonSerializable {
  const ChannelOrderByWithAggregationInput({
    this.uuid,
    this.name,
    this.desc,
    this.color,
    this.imgRef,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory ChannelOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelOrderByWithAggregationInputFromJson(json);

  final SortOrder? uuid;

  final SortOrder? name;

  final SortOrder? desc;

  final SortOrder? color;

  final SortOrder? imgRef;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @JsonKey(name: r'_count')
  final ChannelCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final ChannelAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final ChannelMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final ChannelMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final ChannelSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class ChannelScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const ChannelScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.name,
    this.desc,
    this.color,
    this.imgRef,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<ChannelScalarWhereWithAggregatesInput>? AND;

  final Iterable<ChannelScalarWhereWithAggregatesInput>? OR;

  final Iterable<ChannelScalarWhereWithAggregatesInput>? NOT;

  final StringWithAggregatesFilter? uuid;

  final StringWithAggregatesFilter? name;

  final StringWithAggregatesFilter? desc;

  final StringWithAggregatesFilter? color;

  final StringNullableWithAggregatesFilter? imgRef;

  final IntWithAggregatesFilter? userId;

  final StringWithAggregatesFilter? profileName;

  final BigIntWithAggregatesFilter? updateAt;

  final BigIntWithAggregatesFilter? syncAt;

  final BigIntWithAggregatesFilter? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class SessionWhereInput implements _i1.JsonSerializable {
  const SessionWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.start,
    this.end,
    this.cycle,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.task,
    this.schedules,
    this.records,
  });

  factory SessionWhereInput.fromJson(Map<String, dynamic> json) =>
      _$SessionWhereInputFromJson(json);

  final Iterable<SessionWhereInput>? AND;

  final Iterable<SessionWhereInput>? OR;

  final Iterable<SessionWhereInput>? NOT;

  final StringFilter? uuid;

  final BigIntFilter? start;

  final BigIntFilter? end;

  final BigIntFilter? cycle;

  final StringFilter? taskUuid;

  final BigIntFilter? updateAt;

  final BigIntFilter? syncAt;

  final BigIntFilter? deleteAt;

  final TaskRelationFilter? task;

  final ScheduleListRelationFilter? schedules;

  final RecordListRelationFilter? records;

  @override
  Map<String, dynamic> toJson() => _$SessionWhereInputToJson(this);
}

@_i1.jsonSerializable
class SessionOrderByWithRelationInput implements _i1.JsonSerializable {
  const SessionOrderByWithRelationInput({
    this.uuid,
    this.start,
    this.end,
    this.cycle,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.task,
    this.schedules,
    this.records,
  });

  factory SessionOrderByWithRelationInput.fromJson(Map<String, dynamic> json) =>
      _$SessionOrderByWithRelationInputFromJson(json);

  final SortOrder? uuid;

  final SortOrder? start;

  final SortOrder? end;

  final SortOrder? cycle;

  final SortOrder? taskUuid;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  final TaskOrderByWithRelationInput? task;

  final ScheduleOrderByRelationAggregateInput? schedules;

  final RecordOrderByRelationAggregateInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class SessionWhereUniqueInput implements _i1.JsonSerializable {
  const SessionWhereUniqueInput({this.uuid});

  factory SessionWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$SessionWhereUniqueInputFromJson(json);

  final String? uuid;

  @override
  Map<String, dynamic> toJson() => _$SessionWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class SessionOrderByWithAggregationInput implements _i1.JsonSerializable {
  const SessionOrderByWithAggregationInput({
    this.uuid,
    this.start,
    this.end,
    this.cycle,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory SessionOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionOrderByWithAggregationInputFromJson(json);

  final SortOrder? uuid;

  final SortOrder? start;

  final SortOrder? end;

  final SortOrder? cycle;

  final SortOrder? taskUuid;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @JsonKey(name: r'_count')
  final SessionCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final SessionAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final SessionMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final SessionMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final SessionSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class SessionScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const SessionScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.start,
    this.end,
    this.cycle,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory SessionScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<SessionScalarWhereWithAggregatesInput>? AND;

  final Iterable<SessionScalarWhereWithAggregatesInput>? OR;

  final Iterable<SessionScalarWhereWithAggregatesInput>? NOT;

  final StringWithAggregatesFilter? uuid;

  final BigIntWithAggregatesFilter? start;

  final BigIntWithAggregatesFilter? end;

  final BigIntWithAggregatesFilter? cycle;

  final StringWithAggregatesFilter? taskUuid;

  final BigIntWithAggregatesFilter? updateAt;

  final BigIntWithAggregatesFilter? syncAt;

  final BigIntWithAggregatesFilter? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class RecordWhereInput implements _i1.JsonSerializable {
  const RecordWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.time,
    this.recordIndex,
    this.sessionUuid,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.session,
    this.task,
    this.profile,
    this.attachment,
  });

  factory RecordWhereInput.fromJson(Map<String, dynamic> json) =>
      _$RecordWhereInputFromJson(json);

  final Iterable<RecordWhereInput>? AND;

  final Iterable<RecordWhereInput>? OR;

  final Iterable<RecordWhereInput>? NOT;

  final BigIntFilter? time;

  final IntFilter? recordIndex;

  final StringFilter? sessionUuid;

  final StringFilter? taskUuid;

  final IntFilter? userId;

  final StringFilter? profileName;

  final BigIntFilter? updateAt;

  final BigIntFilter? syncAt;

  final BigIntFilter? deleteAt;

  final SessionRelationFilter? session;

  final TaskRelationFilter? task;

  final ProfileRelationFilter? profile;

  final RecordAttachmentRelationFilter? attachment;

  @override
  Map<String, dynamic> toJson() => _$RecordWhereInputToJson(this);
}

@_i1.jsonSerializable
class RecordOrderByWithRelationInput implements _i1.JsonSerializable {
  const RecordOrderByWithRelationInput({
    this.time,
    this.recordIndex,
    this.sessionUuid,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.session,
    this.task,
    this.profile,
    this.attachment,
  });

  factory RecordOrderByWithRelationInput.fromJson(Map<String, dynamic> json) =>
      _$RecordOrderByWithRelationInputFromJson(json);

  final SortOrder? time;

  final SortOrder? recordIndex;

  final SortOrder? sessionUuid;

  final SortOrder? taskUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  final SessionOrderByWithRelationInput? session;

  final TaskOrderByWithRelationInput? task;

  final ProfileOrderByWithRelationInput? profile;

  final RecordAttachmentOrderByWithRelationInput? attachment;

  @override
  Map<String, dynamic> toJson() => _$RecordOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class RecordWhereUniqueInput implements _i1.JsonSerializable {
  const RecordWhereUniqueInput(
      {this.sessionUuidTaskUuidUserIdProfileNameRecordIndex});

  factory RecordWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$RecordWhereUniqueInputFromJson(json);

  @JsonKey(name: r'sessionUuid_taskUuid_userId_profileName_recordIndex')
  final RecordSessionUuidTaskUuidUserIdProfileNameRecordIndexCompoundUniqueInput?
      sessionUuidTaskUuidUserIdProfileNameRecordIndex;

  @override
  Map<String, dynamic> toJson() => _$RecordWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class RecordOrderByWithAggregationInput implements _i1.JsonSerializable {
  const RecordOrderByWithAggregationInput({
    this.time,
    this.recordIndex,
    this.sessionUuid,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory RecordOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordOrderByWithAggregationInputFromJson(json);

  final SortOrder? time;

  final SortOrder? recordIndex;

  final SortOrder? sessionUuid;

  final SortOrder? taskUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @JsonKey(name: r'_count')
  final RecordCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final RecordAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final RecordMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final RecordMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final RecordSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class RecordScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const RecordScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.time,
    this.recordIndex,
    this.sessionUuid,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory RecordScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<RecordScalarWhereWithAggregatesInput>? AND;

  final Iterable<RecordScalarWhereWithAggregatesInput>? OR;

  final Iterable<RecordScalarWhereWithAggregatesInput>? NOT;

  final BigIntWithAggregatesFilter? time;

  final IntWithAggregatesFilter? recordIndex;

  final StringWithAggregatesFilter? sessionUuid;

  final StringWithAggregatesFilter? taskUuid;

  final IntWithAggregatesFilter? userId;

  final StringWithAggregatesFilter? profileName;

  final BigIntWithAggregatesFilter? updateAt;

  final BigIntWithAggregatesFilter? syncAt;

  final BigIntWithAggregatesFilter? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentWhereInput implements _i1.JsonSerializable {
  const RecordAttachmentWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.hash,
    this.name,
    this.assetRef,
    this.sessionUuid,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.recordIndex,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.record,
  });

  factory RecordAttachmentWhereInput.fromJson(Map<String, dynamic> json) =>
      _$RecordAttachmentWhereInputFromJson(json);

  final Iterable<RecordAttachmentWhereInput>? AND;

  final Iterable<RecordAttachmentWhereInput>? OR;

  final Iterable<RecordAttachmentWhereInput>? NOT;

  final StringFilter? hash;

  final StringFilter? name;

  final StringFilter? assetRef;

  final StringFilter? sessionUuid;

  final StringFilter? taskUuid;

  final IntFilter? userId;

  final StringFilter? profileName;

  final IntFilter? recordIndex;

  final BigIntFilter? updateAt;

  final BigIntFilter? syncAt;

  final BigIntFilter? deleteAt;

  final RecordRelationFilter? record;

  @override
  Map<String, dynamic> toJson() => _$RecordAttachmentWhereInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentOrderByWithRelationInput implements _i1.JsonSerializable {
  const RecordAttachmentOrderByWithRelationInput({
    this.hash,
    this.name,
    this.assetRef,
    this.sessionUuid,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.recordIndex,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.record,
  });

  factory RecordAttachmentOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentOrderByWithRelationInputFromJson(json);

  final SortOrder? hash;

  final SortOrder? name;

  final SortOrder? assetRef;

  final SortOrder? sessionUuid;

  final SortOrder? taskUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? recordIndex;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  final RecordOrderByWithRelationInput? record;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentWhereUniqueInput implements _i1.JsonSerializable {
  const RecordAttachmentWhereUniqueInput(
      {this.sessionUuidTaskUuidUserIdProfileNameRecordIndex});

  factory RecordAttachmentWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentWhereUniqueInputFromJson(json);

  @JsonKey(name: r'sessionUuid_taskUuid_userId_profileName_recordIndex')
  final RecordAttachmentSessionUuidTaskUuidUserIdProfileNameRecordIndexCompoundUniqueInput?
      sessionUuidTaskUuidUserIdProfileNameRecordIndex;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const RecordAttachmentOrderByWithAggregationInput({
    this.hash,
    this.name,
    this.assetRef,
    this.sessionUuid,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.recordIndex,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory RecordAttachmentOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentOrderByWithAggregationInputFromJson(json);

  final SortOrder? hash;

  final SortOrder? name;

  final SortOrder? assetRef;

  final SortOrder? sessionUuid;

  final SortOrder? taskUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? recordIndex;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @JsonKey(name: r'_count')
  final RecordAttachmentCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final RecordAttachmentAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final RecordAttachmentMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final RecordAttachmentMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final RecordAttachmentSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const RecordAttachmentScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.hash,
    this.name,
    this.assetRef,
    this.sessionUuid,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.recordIndex,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory RecordAttachmentScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<RecordAttachmentScalarWhereWithAggregatesInput>? AND;

  final Iterable<RecordAttachmentScalarWhereWithAggregatesInput>? OR;

  final Iterable<RecordAttachmentScalarWhereWithAggregatesInput>? NOT;

  final StringWithAggregatesFilter? hash;

  final StringWithAggregatesFilter? name;

  final StringWithAggregatesFilter? assetRef;

  final StringWithAggregatesFilter? sessionUuid;

  final StringWithAggregatesFilter? taskUuid;

  final IntWithAggregatesFilter? userId;

  final StringWithAggregatesFilter? profileName;

  final IntWithAggregatesFilter? recordIndex;

  final BigIntWithAggregatesFilter? updateAt;

  final BigIntWithAggregatesFilter? syncAt;

  final BigIntWithAggregatesFilter? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class CategoryWhereInput implements _i1.JsonSerializable {
  const CategoryWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.profile,
    this.assignments,
  });

  factory CategoryWhereInput.fromJson(Map<String, dynamic> json) =>
      _$CategoryWhereInputFromJson(json);

  final Iterable<CategoryWhereInput>? AND;

  final Iterable<CategoryWhereInput>? OR;

  final Iterable<CategoryWhereInput>? NOT;

  final StringFilter? name;

  final StringFilter? color;

  final StringFilter? icon;

  final IntFilter? userId;

  final StringFilter? profileName;

  final BigIntFilter? updateAt;

  final BigIntFilter? syncAt;

  final BigIntFilter? deleteAt;

  final ProfileRelationFilter? profile;

  final TaskAssignmentListRelationFilter? assignments;

  @override
  Map<String, dynamic> toJson() => _$CategoryWhereInputToJson(this);
}

@_i1.jsonSerializable
class CategoryOrderByWithRelationInput implements _i1.JsonSerializable {
  const CategoryOrderByWithRelationInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.profile,
    this.assignments,
  });

  factory CategoryOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryOrderByWithRelationInputFromJson(json);

  final SortOrder? name;

  final SortOrder? color;

  final SortOrder? icon;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  final ProfileOrderByWithRelationInput? profile;

  final TaskAssignmentOrderByRelationAggregateInput? assignments;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class CategoryWhereUniqueInput implements _i1.JsonSerializable {
  const CategoryWhereUniqueInput({this.userIdProfileNameName});

  factory CategoryWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$CategoryWhereUniqueInputFromJson(json);

  @JsonKey(name: r'userId_profileName_name')
  final CategoryUserIdProfileNameNameCompoundUniqueInput? userIdProfileNameName;

  @override
  Map<String, dynamic> toJson() => _$CategoryWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class CategoryOrderByWithAggregationInput implements _i1.JsonSerializable {
  const CategoryOrderByWithAggregationInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory CategoryOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryOrderByWithAggregationInputFromJson(json);

  final SortOrder? name;

  final SortOrder? color;

  final SortOrder? icon;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @JsonKey(name: r'_count')
  final CategoryCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final CategoryAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final CategoryMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final CategoryMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final CategorySumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class CategoryScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const CategoryScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory CategoryScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<CategoryScalarWhereWithAggregatesInput>? AND;

  final Iterable<CategoryScalarWhereWithAggregatesInput>? OR;

  final Iterable<CategoryScalarWhereWithAggregatesInput>? NOT;

  final StringWithAggregatesFilter? name;

  final StringWithAggregatesFilter? color;

  final StringWithAggregatesFilter? icon;

  final IntWithAggregatesFilter? userId;

  final StringWithAggregatesFilter? profileName;

  final BigIntWithAggregatesFilter? updateAt;

  final BigIntWithAggregatesFilter? syncAt;

  final BigIntWithAggregatesFilter? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class TagWhereInput implements _i1.JsonSerializable {
  const TagWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.profile,
    this.assignments,
  });

  factory TagWhereInput.fromJson(Map<String, dynamic> json) =>
      _$TagWhereInputFromJson(json);

  final Iterable<TagWhereInput>? AND;

  final Iterable<TagWhereInput>? OR;

  final Iterable<TagWhereInput>? NOT;

  final StringFilter? name;

  final StringFilter? color;

  final StringFilter? icon;

  final IntFilter? userId;

  final StringFilter? profileName;

  final BigIntFilter? updateAt;

  final BigIntFilter? syncAt;

  final BigIntFilter? deleteAt;

  final ProfileRelationFilter? profile;

  final TaskAssignmentTagsListRelationFilter? assignments;

  @override
  Map<String, dynamic> toJson() => _$TagWhereInputToJson(this);
}

@_i1.jsonSerializable
class TagOrderByWithRelationInput implements _i1.JsonSerializable {
  const TagOrderByWithRelationInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.profile,
    this.assignments,
  });

  factory TagOrderByWithRelationInput.fromJson(Map<String, dynamic> json) =>
      _$TagOrderByWithRelationInputFromJson(json);

  final SortOrder? name;

  final SortOrder? color;

  final SortOrder? icon;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  final ProfileOrderByWithRelationInput? profile;

  final TaskAssignmentTagsOrderByRelationAggregateInput? assignments;

  @override
  Map<String, dynamic> toJson() => _$TagOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class TagWhereUniqueInput implements _i1.JsonSerializable {
  const TagWhereUniqueInput({this.userIdProfileNameName});

  factory TagWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$TagWhereUniqueInputFromJson(json);

  @JsonKey(name: r'userId_profileName_name')
  final TagUserIdProfileNameNameCompoundUniqueInput? userIdProfileNameName;

  @override
  Map<String, dynamic> toJson() => _$TagWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class TagOrderByWithAggregationInput implements _i1.JsonSerializable {
  const TagOrderByWithAggregationInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory TagOrderByWithAggregationInput.fromJson(Map<String, dynamic> json) =>
      _$TagOrderByWithAggregationInputFromJson(json);

  final SortOrder? name;

  final SortOrder? color;

  final SortOrder? icon;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @JsonKey(name: r'_count')
  final TagCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final TagAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final TagMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final TagMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final TagSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => _$TagOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class TagScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const TagScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TagScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$TagScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<TagScalarWhereWithAggregatesInput>? AND;

  final Iterable<TagScalarWhereWithAggregatesInput>? OR;

  final Iterable<TagScalarWhereWithAggregatesInput>? NOT;

  final StringWithAggregatesFilter? name;

  final StringWithAggregatesFilter? color;

  final StringWithAggregatesFilter? icon;

  final IntWithAggregatesFilter? userId;

  final StringWithAggregatesFilter? profileName;

  final BigIntWithAggregatesFilter? updateAt;

  final BigIntWithAggregatesFilter? syncAt;

  final BigIntWithAggregatesFilter? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TagScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentWhereInput implements _i1.JsonSerializable {
  const TaskAssignmentWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.status,
    this.priority,
    this.starred,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.categoryName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.task,
    this.profile,
    this.category,
    this.tags,
  });

  factory TaskAssignmentWhereInput.fromJson(Map<String, dynamic> json) =>
      _$TaskAssignmentWhereInputFromJson(json);

  final Iterable<TaskAssignmentWhereInput>? AND;

  final Iterable<TaskAssignmentWhereInput>? OR;

  final Iterable<TaskAssignmentWhereInput>? NOT;

  final EnumTaskAssignmentStatusFilter? status;

  final EnumTaskPriorityFilter? priority;

  final BoolFilter? starred;

  final StringFilter? taskUuid;

  final IntFilter? userId;

  final StringFilter? profileName;

  final StringNullableFilter? categoryName;

  final BigIntFilter? updateAt;

  final BigIntFilter? syncAt;

  final BigIntFilter? deleteAt;

  final TaskRelationFilter? task;

  final ProfileRelationFilter? profile;

  final CategoryRelationFilter? category;

  final TaskAssignmentTagsListRelationFilter? tags;

  @override
  Map<String, dynamic> toJson() => _$TaskAssignmentWhereInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentOrderByWithRelationInput implements _i1.JsonSerializable {
  const TaskAssignmentOrderByWithRelationInput({
    this.status,
    this.priority,
    this.starred,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.categoryName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.task,
    this.profile,
    this.category,
    this.tags,
  });

  factory TaskAssignmentOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentOrderByWithRelationInputFromJson(json);

  final SortOrder? status;

  final SortOrder? priority;

  final SortOrder? starred;

  final SortOrder? taskUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? categoryName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  final TaskOrderByWithRelationInput? task;

  final ProfileOrderByWithRelationInput? profile;

  final CategoryOrderByWithRelationInput? category;

  final TaskAssignmentTagsOrderByRelationAggregateInput? tags;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentWhereUniqueInput implements _i1.JsonSerializable {
  const TaskAssignmentWhereUniqueInput({this.taskUuidUserIdProfileName});

  factory TaskAssignmentWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$TaskAssignmentWhereUniqueInputFromJson(json);

  @JsonKey(name: r'taskUuid_userId_profileName')
  final TaskAssignmentTaskUuidUserIdProfileNameCompoundUniqueInput?
      taskUuidUserIdProfileName;

  @override
  Map<String, dynamic> toJson() => _$TaskAssignmentWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const TaskAssignmentOrderByWithAggregationInput({
    this.status,
    this.priority,
    this.starred,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.categoryName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory TaskAssignmentOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentOrderByWithAggregationInputFromJson(json);

  final SortOrder? status;

  final SortOrder? priority;

  final SortOrder? starred;

  final SortOrder? taskUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? categoryName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @JsonKey(name: r'_count')
  final TaskAssignmentCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final TaskAssignmentAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final TaskAssignmentMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final TaskAssignmentMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final TaskAssignmentSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const TaskAssignmentScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.status,
    this.priority,
    this.starred,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.categoryName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssignmentScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<TaskAssignmentScalarWhereWithAggregatesInput>? AND;

  final Iterable<TaskAssignmentScalarWhereWithAggregatesInput>? OR;

  final Iterable<TaskAssignmentScalarWhereWithAggregatesInput>? NOT;

  final EnumTaskAssignmentStatusWithAggregatesFilter? status;

  final EnumTaskPriorityWithAggregatesFilter? priority;

  final BoolWithAggregatesFilter? starred;

  final StringWithAggregatesFilter? taskUuid;

  final IntWithAggregatesFilter? userId;

  final StringWithAggregatesFilter? profileName;

  final StringNullableWithAggregatesFilter? categoryName;

  final BigIntWithAggregatesFilter? updateAt;

  final BigIntWithAggregatesFilter? syncAt;

  final BigIntWithAggregatesFilter? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsWhereInput implements _i1.JsonSerializable {
  const TaskAssignmentTagsWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.tagName,
    this.assignment,
    this.tag,
  });

  factory TaskAssignmentTagsWhereInput.fromJson(Map<String, dynamic> json) =>
      _$TaskAssignmentTagsWhereInputFromJson(json);

  final Iterable<TaskAssignmentTagsWhereInput>? AND;

  final Iterable<TaskAssignmentTagsWhereInput>? OR;

  final Iterable<TaskAssignmentTagsWhereInput>? NOT;

  final StringFilter? taskUuid;

  final IntFilter? userId;

  final StringFilter? profileName;

  final StringFilter? tagName;

  final TaskAssignmentRelationFilter? assignment;

  final TagRelationFilter? tag;

  @override
  Map<String, dynamic> toJson() => _$TaskAssignmentTagsWhereInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsOrderByWithRelationInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsOrderByWithRelationInput({
    this.taskUuid,
    this.userId,
    this.profileName,
    this.tagName,
    this.assignment,
    this.tag,
  });

  factory TaskAssignmentTagsOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsOrderByWithRelationInputFromJson(json);

  final SortOrder? taskUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? tagName;

  final TaskAssignmentOrderByWithRelationInput? assignment;

  final TagOrderByWithRelationInput? tag;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsWhereUniqueInput implements _i1.JsonSerializable {
  const TaskAssignmentTagsWhereUniqueInput(
      {this.taskUuidUserIdProfileNameTagName});

  factory TaskAssignmentTagsWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsWhereUniqueInputFromJson(json);

  @JsonKey(name: r'taskUuid_userId_profileName_tagName')
  final TaskAssignmentTagsTaskUuidUserIdProfileNameTagNameCompoundUniqueInput?
      taskUuidUserIdProfileNameTagName;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsOrderByWithAggregationInput({
    this.taskUuid,
    this.userId,
    this.profileName,
    this.tagName,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory TaskAssignmentTagsOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsOrderByWithAggregationInputFromJson(json);

  final SortOrder? taskUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? tagName;

  @JsonKey(name: r'_count')
  final TaskAssignmentTagsCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final TaskAssignmentTagsAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final TaskAssignmentTagsMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final TaskAssignmentTagsMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final TaskAssignmentTagsSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.tagName,
  });

  factory TaskAssignmentTagsScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<TaskAssignmentTagsScalarWhereWithAggregatesInput>? AND;

  final Iterable<TaskAssignmentTagsScalarWhereWithAggregatesInput>? OR;

  final Iterable<TaskAssignmentTagsScalarWhereWithAggregatesInput>? NOT;

  final StringWithAggregatesFilter? taskUuid;

  final IntWithAggregatesFilter? userId;

  final StringWithAggregatesFilter? profileName;

  final StringWithAggregatesFilter? tagName;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionWhereInput implements _i1.JsonSerializable {
  const ChannelSubscriptionWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.shareRecord,
    this.channelUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.channel,
    this.profile,
  });

  factory ChannelSubscriptionWhereInput.fromJson(Map<String, dynamic> json) =>
      _$ChannelSubscriptionWhereInputFromJson(json);

  final Iterable<ChannelSubscriptionWhereInput>? AND;

  final Iterable<ChannelSubscriptionWhereInput>? OR;

  final Iterable<ChannelSubscriptionWhereInput>? NOT;

  final BoolFilter? shareRecord;

  final StringFilter? channelUuid;

  final IntFilter? userId;

  final StringFilter? profileName;

  final BigIntFilter? updateAt;

  final BigIntFilter? syncAt;

  final BigIntFilter? deleteAt;

  final ChannelRelationFilter? channel;

  final ProfileRelationFilter? profile;

  @override
  Map<String, dynamic> toJson() => _$ChannelSubscriptionWhereInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionOrderByWithRelationInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionOrderByWithRelationInput({
    this.shareRecord,
    this.channelUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.channel,
    this.profile,
  });

  factory ChannelSubscriptionOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionOrderByWithRelationInputFromJson(json);

  final SortOrder? shareRecord;

  final SortOrder? channelUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  final ChannelOrderByWithRelationInput? channel;

  final ProfileOrderByWithRelationInput? profile;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionWhereUniqueInput implements _i1.JsonSerializable {
  const ChannelSubscriptionWhereUniqueInput(
      {this.channelUuidUserIdProfileName});

  factory ChannelSubscriptionWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionWhereUniqueInputFromJson(json);

  @JsonKey(name: r'channelUuid_userId_profileName')
  final ChannelSubscriptionChannelUuidUserIdProfileNameCompoundUniqueInput?
      channelUuidUserIdProfileName;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionOrderByWithAggregationInput({
    this.shareRecord,
    this.channelUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory ChannelSubscriptionOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionOrderByWithAggregationInputFromJson(json);

  final SortOrder? shareRecord;

  final SortOrder? channelUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @JsonKey(name: r'_count')
  final ChannelSubscriptionCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final ChannelSubscriptionAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final ChannelSubscriptionMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final ChannelSubscriptionMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final ChannelSubscriptionSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.shareRecord,
    this.channelUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelSubscriptionScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<ChannelSubscriptionScalarWhereWithAggregatesInput>? AND;

  final Iterable<ChannelSubscriptionScalarWhereWithAggregatesInput>? OR;

  final Iterable<ChannelSubscriptionScalarWhereWithAggregatesInput>? NOT;

  final BoolWithAggregatesFilter? shareRecord;

  final StringWithAggregatesFilter? channelUuid;

  final IntWithAggregatesFilter? userId;

  final StringWithAggregatesFilter? profileName;

  final BigIntWithAggregatesFilter? updateAt;

  final BigIntWithAggregatesFilter? syncAt;

  final BigIntWithAggregatesFilter? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleWhereInput implements _i1.JsonSerializable {
  const ScheduleWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.relStart,
    this.relEnd,
    this.sessionUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.session,
    this.profile,
  });

  factory ScheduleWhereInput.fromJson(Map<String, dynamic> json) =>
      _$ScheduleWhereInputFromJson(json);

  final Iterable<ScheduleWhereInput>? AND;

  final Iterable<ScheduleWhereInput>? OR;

  final Iterable<ScheduleWhereInput>? NOT;

  final BigIntFilter? relStart;

  final BigIntFilter? relEnd;

  final StringFilter? sessionUuid;

  final IntFilter? userId;

  final StringFilter? profileName;

  final BigIntFilter? updateAt;

  final BigIntFilter? syncAt;

  final BigIntFilter? deleteAt;

  final SessionRelationFilter? session;

  final ProfileRelationFilter? profile;

  @override
  Map<String, dynamic> toJson() => _$ScheduleWhereInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleOrderByWithRelationInput implements _i1.JsonSerializable {
  const ScheduleOrderByWithRelationInput({
    this.relStart,
    this.relEnd,
    this.sessionUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.session,
    this.profile,
  });

  factory ScheduleOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleOrderByWithRelationInputFromJson(json);

  final SortOrder? relStart;

  final SortOrder? relEnd;

  final SortOrder? sessionUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  final SessionOrderByWithRelationInput? session;

  final ProfileOrderByWithRelationInput? profile;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleWhereUniqueInput implements _i1.JsonSerializable {
  const ScheduleWhereUniqueInput({this.sessionUuidUserIdProfileName});

  factory ScheduleWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$ScheduleWhereUniqueInputFromJson(json);

  @JsonKey(name: r'sessionUuid_userId_profileName')
  final ScheduleSessionUuidUserIdProfileNameCompoundUniqueInput?
      sessionUuidUserIdProfileName;

  @override
  Map<String, dynamic> toJson() => _$ScheduleWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleOrderByWithAggregationInput implements _i1.JsonSerializable {
  const ScheduleOrderByWithAggregationInput({
    this.relStart,
    this.relEnd,
    this.sessionUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory ScheduleOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleOrderByWithAggregationInputFromJson(json);

  final SortOrder? relStart;

  final SortOrder? relEnd;

  final SortOrder? sessionUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @JsonKey(name: r'_count')
  final ScheduleCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final ScheduleAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final ScheduleMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final ScheduleMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final ScheduleSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const ScheduleScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.relStart,
    this.relEnd,
    this.sessionUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ScheduleScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<ScheduleScalarWhereWithAggregatesInput>? AND;

  final Iterable<ScheduleScalarWhereWithAggregatesInput>? OR;

  final Iterable<ScheduleScalarWhereWithAggregatesInput>? NOT;

  final BigIntWithAggregatesFilter? relStart;

  final BigIntWithAggregatesFilter? relEnd;

  final StringWithAggregatesFilter? sessionUuid;

  final IntWithAggregatesFilter? userId;

  final StringWithAggregatesFilter? profileName;

  final BigIntWithAggregatesFilter? updateAt;

  final BigIntWithAggregatesFilter? syncAt;

  final BigIntWithAggregatesFilter? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class FileRefWhereInput implements _i1.JsonSerializable {
  const FileRefWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.hash,
    this.count,
  });

  factory FileRefWhereInput.fromJson(Map<String, dynamic> json) =>
      _$FileRefWhereInputFromJson(json);

  final Iterable<FileRefWhereInput>? AND;

  final Iterable<FileRefWhereInput>? OR;

  final Iterable<FileRefWhereInput>? NOT;

  final StringFilter? hash;

  final IntNullableFilter? count;

  @override
  Map<String, dynamic> toJson() => _$FileRefWhereInputToJson(this);
}

@_i1.jsonSerializable
class FileRefOrderByWithRelationInput implements _i1.JsonSerializable {
  const FileRefOrderByWithRelationInput({
    this.hash,
    this.count,
  });

  factory FileRefOrderByWithRelationInput.fromJson(Map<String, dynamic> json) =>
      _$FileRefOrderByWithRelationInputFromJson(json);

  final SortOrder? hash;

  final SortOrder? count;

  @override
  Map<String, dynamic> toJson() =>
      _$FileRefOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class FileRefWhereUniqueInput implements _i1.JsonSerializable {
  const FileRefWhereUniqueInput({this.hash});

  factory FileRefWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$FileRefWhereUniqueInputFromJson(json);

  final String? hash;

  @override
  Map<String, dynamic> toJson() => _$FileRefWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class FileRefOrderByWithAggregationInput implements _i1.JsonSerializable {
  const FileRefOrderByWithAggregationInput({
    this.hash,
    this.count,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory FileRefOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$FileRefOrderByWithAggregationInputFromJson(json);

  final SortOrder? hash;

  final SortOrder? count;

  @JsonKey(name: r'_count')
  final FileRefCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final FileRefAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final FileRefMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final FileRefMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final FileRefSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$FileRefOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class FileRefScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const FileRefScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.hash,
    this.count,
  });

  factory FileRefScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$FileRefScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<FileRefScalarWhereWithAggregatesInput>? AND;

  final Iterable<FileRefScalarWhereWithAggregatesInput>? OR;

  final Iterable<FileRefScalarWhereWithAggregatesInput>? NOT;

  final StringWithAggregatesFilter? hash;

  final IntNullableWithAggregatesFilter? count;

  @override
  Map<String, dynamic> toJson() =>
      _$FileRefScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class UserCreateInput implements _i1.JsonSerializable {
  const UserCreateInput({
    required this.name,
    this.email,
    this.phone,
    required this.password,
    this.avatarRef,
    this.unionId,
    this.tencentId,
    this.appleId,
    this.profiles,
  });

  factory UserCreateInput.fromJson(Map<String, dynamic> json) =>
      _$UserCreateInputFromJson(json);

  final String name;

  final String? email;

  final String? phone;

  final String password;

  final String? avatarRef;

  final String? unionId;

  final String? tencentId;

  final String? appleId;

  final ProfileCreateNestedManyWithoutUserInput? profiles;

  @override
  Map<String, dynamic> toJson() => _$UserCreateInputToJson(this);
}

@_i1.jsonSerializable
class UserUncheckedCreateInput implements _i1.JsonSerializable {
  const UserUncheckedCreateInput({
    this.id,
    required this.name,
    this.email,
    this.phone,
    required this.password,
    this.avatarRef,
    this.unionId,
    this.tencentId,
    this.appleId,
    this.profiles,
  });

  factory UserUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$UserUncheckedCreateInputFromJson(json);

  final int? id;

  final String name;

  final String? email;

  final String? phone;

  final String password;

  final String? avatarRef;

  final String? unionId;

  final String? tencentId;

  final String? appleId;

  final ProfileUncheckedCreateNestedManyWithoutUserInput? profiles;

  @override
  Map<String, dynamic> toJson() => _$UserUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class UserUpdateInput implements _i1.JsonSerializable {
  const UserUpdateInput({
    this.name,
    this.email,
    this.phone,
    this.password,
    this.avatarRef,
    this.unionId,
    this.tencentId,
    this.appleId,
    this.profiles,
  });

  factory UserUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$UserUpdateInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final NullableStringFieldUpdateOperationsInput? email;

  final NullableStringFieldUpdateOperationsInput? phone;

  final StringFieldUpdateOperationsInput? password;

  final NullableStringFieldUpdateOperationsInput? avatarRef;

  final NullableStringFieldUpdateOperationsInput? unionId;

  final NullableStringFieldUpdateOperationsInput? tencentId;

  final NullableStringFieldUpdateOperationsInput? appleId;

  final ProfileUpdateManyWithoutUserNestedInput? profiles;

  @override
  Map<String, dynamic> toJson() => _$UserUpdateInputToJson(this);
}

@_i1.jsonSerializable
class UserUncheckedUpdateInput implements _i1.JsonSerializable {
  const UserUncheckedUpdateInput({
    this.id,
    this.name,
    this.email,
    this.phone,
    this.password,
    this.avatarRef,
    this.unionId,
    this.tencentId,
    this.appleId,
    this.profiles,
  });

  factory UserUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$UserUncheckedUpdateInputFromJson(json);

  final IntFieldUpdateOperationsInput? id;

  final StringFieldUpdateOperationsInput? name;

  final NullableStringFieldUpdateOperationsInput? email;

  final NullableStringFieldUpdateOperationsInput? phone;

  final StringFieldUpdateOperationsInput? password;

  final NullableStringFieldUpdateOperationsInput? avatarRef;

  final NullableStringFieldUpdateOperationsInput? unionId;

  final NullableStringFieldUpdateOperationsInput? tencentId;

  final NullableStringFieldUpdateOperationsInput? appleId;

  final ProfileUncheckedUpdateManyWithoutUserNestedInput? profiles;

  @override
  Map<String, dynamic> toJson() => _$UserUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class UserCreateManyInput implements _i1.JsonSerializable {
  const UserCreateManyInput({
    this.id,
    required this.name,
    this.email,
    this.phone,
    required this.password,
    this.avatarRef,
    this.unionId,
    this.tencentId,
    this.appleId,
  });

  factory UserCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$UserCreateManyInputFromJson(json);

  final int? id;

  final String name;

  final String? email;

  final String? phone;

  final String password;

  final String? avatarRef;

  final String? unionId;

  final String? tencentId;

  final String? appleId;

  @override
  Map<String, dynamic> toJson() => _$UserCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class UserUpdateManyMutationInput implements _i1.JsonSerializable {
  const UserUpdateManyMutationInput({
    this.name,
    this.email,
    this.phone,
    this.password,
    this.avatarRef,
    this.unionId,
    this.tencentId,
    this.appleId,
  });

  factory UserUpdateManyMutationInput.fromJson(Map<String, dynamic> json) =>
      _$UserUpdateManyMutationInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final NullableStringFieldUpdateOperationsInput? email;

  final NullableStringFieldUpdateOperationsInput? phone;

  final StringFieldUpdateOperationsInput? password;

  final NullableStringFieldUpdateOperationsInput? avatarRef;

  final NullableStringFieldUpdateOperationsInput? unionId;

  final NullableStringFieldUpdateOperationsInput? tencentId;

  final NullableStringFieldUpdateOperationsInput? appleId;

  @override
  Map<String, dynamic> toJson() => _$UserUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class UserUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const UserUncheckedUpdateManyInput({
    this.id,
    this.name,
    this.email,
    this.phone,
    this.password,
    this.avatarRef,
    this.unionId,
    this.tencentId,
    this.appleId,
  });

  factory UserUncheckedUpdateManyInput.fromJson(Map<String, dynamic> json) =>
      _$UserUncheckedUpdateManyInputFromJson(json);

  final IntFieldUpdateOperationsInput? id;

  final StringFieldUpdateOperationsInput? name;

  final NullableStringFieldUpdateOperationsInput? email;

  final NullableStringFieldUpdateOperationsInput? phone;

  final StringFieldUpdateOperationsInput? password;

  final NullableStringFieldUpdateOperationsInput? avatarRef;

  final NullableStringFieldUpdateOperationsInput? unionId;

  final NullableStringFieldUpdateOperationsInput? tencentId;

  final NullableStringFieldUpdateOperationsInput? appleId;

  @override
  Map<String, dynamic> toJson() => _$UserUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateInput implements _i1.JsonSerializable {
  const ProfileCreateInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    required this.user,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileCreateInput.fromJson(Map<String, dynamic> json) =>
      _$ProfileCreateInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final UserCreateNestedOneWithoutProfilesInput user;

  final CategoryCreateNestedManyWithoutProfileInput? categories;

  final TagCreateNestedManyWithoutProfileInput? tags;

  final TaskCreateNestedManyWithoutOwnerInput? tasks;

  final ChannelCreateNestedManyWithoutOwnerInput? channels;

  final TaskAssignmentCreateNestedManyWithoutProfileInput? taskAssignments;

  final ChannelSubscriptionCreateNestedManyWithoutProfileInput?
      channelSubscriptions;

  final ScheduleCreateNestedManyWithoutProfileInput? schedules;

  final RecordCreateNestedManyWithoutProfileInput? records;

  @override
  Map<String, dynamic> toJson() => _$ProfileCreateInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUncheckedCreateInput implements _i1.JsonSerializable {
  const ProfileUncheckedCreateInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.userId,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$ProfileUncheckedCreateInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final int userId;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final CategoryUncheckedCreateNestedManyWithoutProfileInput? categories;

  final TagUncheckedCreateNestedManyWithoutProfileInput? tags;

  final TaskUncheckedCreateNestedManyWithoutOwnerInput? tasks;

  final ChannelUncheckedCreateNestedManyWithoutOwnerInput? channels;

  final TaskAssignmentUncheckedCreateNestedManyWithoutProfileInput?
      taskAssignments;

  final ChannelSubscriptionUncheckedCreateNestedManyWithoutProfileInput?
      channelSubscriptions;

  final ScheduleUncheckedCreateNestedManyWithoutProfileInput? schedules;

  final RecordUncheckedCreateNestedManyWithoutProfileInput? records;

  @override
  Map<String, dynamic> toJson() => _$ProfileUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpdateInput implements _i1.JsonSerializable {
  const ProfileUpdateInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.user,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$ProfileUpdateInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final UserUpdateOneRequiredWithoutProfilesNestedInput? user;

  final CategoryUpdateManyWithoutProfileNestedInput? categories;

  final TagUpdateManyWithoutProfileNestedInput? tags;

  final TaskUpdateManyWithoutOwnerNestedInput? tasks;

  final ChannelUpdateManyWithoutOwnerNestedInput? channels;

  final TaskAssignmentUpdateManyWithoutProfileNestedInput? taskAssignments;

  final ChannelSubscriptionUpdateManyWithoutProfileNestedInput?
      channelSubscriptions;

  final ScheduleUpdateManyWithoutProfileNestedInput? schedules;

  final RecordUpdateManyWithoutProfileNestedInput? records;

  @override
  Map<String, dynamic> toJson() => _$ProfileUpdateInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUncheckedUpdateInput implements _i1.JsonSerializable {
  const ProfileUncheckedUpdateInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$ProfileUncheckedUpdateInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final IntFieldUpdateOperationsInput? userId;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final CategoryUncheckedUpdateManyWithoutProfileNestedInput? categories;

  final TagUncheckedUpdateManyWithoutProfileNestedInput? tags;

  final TaskUncheckedUpdateManyWithoutOwnerNestedInput? tasks;

  final ChannelUncheckedUpdateManyWithoutOwnerNestedInput? channels;

  final TaskAssignmentUncheckedUpdateManyWithoutProfileNestedInput?
      taskAssignments;

  final ChannelSubscriptionUncheckedUpdateManyWithoutProfileNestedInput?
      channelSubscriptions;

  final ScheduleUncheckedUpdateManyWithoutProfileNestedInput? schedules;

  final RecordUncheckedUpdateManyWithoutProfileNestedInput? records;

  @override
  Map<String, dynamic> toJson() => _$ProfileUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateManyInput implements _i1.JsonSerializable {
  const ProfileCreateManyInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.userId,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
  });

  factory ProfileCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$ProfileCreateManyInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final int userId;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$ProfileCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpdateManyMutationInput implements _i1.JsonSerializable {
  const ProfileUpdateManyMutationInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ProfileUpdateManyMutationInput.fromJson(Map<String, dynamic> json) =>
      _$ProfileUpdateManyMutationInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$ProfileUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const ProfileUncheckedUpdateManyInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ProfileUncheckedUpdateManyInput.fromJson(Map<String, dynamic> json) =>
      _$ProfileUncheckedUpdateManyInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final IntFieldUpdateOperationsInput? userId;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateInput implements _i1.JsonSerializable {
  const TaskCreateInput({
    required this.uuid,
    required this.title,
    required this.desc,
    required this.content,
    this.location,
    required this.requireLocation,
    required this.requireTime,
    required this.requireAttachment,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    required this.owner,
    this.parent,
    this.children,
    this.channel,
    this.assets,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskCreateInput.fromJson(Map<String, dynamic> json) =>
      _$TaskCreateInputFromJson(json);

  final String uuid;

  final String title;

  final String desc;

  final String content;

  final String? location;

  final bool requireLocation;

  final bool requireTime;

  final bool requireAttachment;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final ProfileCreateNestedOneWithoutTasksInput owner;

  final TaskCreateNestedOneWithoutChildrenInput? parent;

  final TaskCreateNestedManyWithoutParentInput? children;

  final ChannelCreateNestedOneWithoutTasksInput? channel;

  final TaskAssetCreateNestedManyWithoutTaskInput? assets;

  final TaskAssignmentCreateNestedManyWithoutTaskInput? assignments;

  final SessionCreateNestedManyWithoutTaskInput? sessions;

  final RecordCreateNestedManyWithoutTaskInput? records;

  @override
  Map<String, dynamic> toJson() => _$TaskCreateInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedCreateInput implements _i1.JsonSerializable {
  const TaskUncheckedCreateInput({
    required this.uuid,
    required this.title,
    required this.desc,
    required this.content,
    this.location,
    required this.requireLocation,
    required this.requireTime,
    required this.requireAttachment,
    required this.userId,
    required this.profile,
    this.parentUuid,
    this.channelUuid,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.children,
    this.assets,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$TaskUncheckedCreateInputFromJson(json);

  final String uuid;

  final String title;

  final String desc;

  final String content;

  final String? location;

  final bool requireLocation;

  final bool requireTime;

  final bool requireAttachment;

  final int userId;

  final String profile;

  final String? parentUuid;

  final String? channelUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final TaskUncheckedCreateNestedManyWithoutParentInput? children;

  final TaskAssetUncheckedCreateNestedManyWithoutTaskInput? assets;

  final TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput? assignments;

  final SessionUncheckedCreateNestedManyWithoutTaskInput? sessions;

  final RecordUncheckedCreateNestedManyWithoutTaskInput? records;

  @override
  Map<String, dynamic> toJson() => _$TaskUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpdateInput implements _i1.JsonSerializable {
  const TaskUpdateInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.owner,
    this.parent,
    this.children,
    this.channel,
    this.assets,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$TaskUpdateInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? title;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? content;

  final NullableStringFieldUpdateOperationsInput? location;

  final BoolFieldUpdateOperationsInput? requireLocation;

  final BoolFieldUpdateOperationsInput? requireTime;

  final BoolFieldUpdateOperationsInput? requireAttachment;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ProfileUpdateOneRequiredWithoutTasksNestedInput? owner;

  final TaskUpdateOneWithoutChildrenNestedInput? parent;

  final TaskUpdateManyWithoutParentNestedInput? children;

  final ChannelUpdateOneWithoutTasksNestedInput? channel;

  final TaskAssetUpdateManyWithoutTaskNestedInput? assets;

  final TaskAssignmentUpdateManyWithoutTaskNestedInput? assignments;

  final SessionUpdateManyWithoutTaskNestedInput? sessions;

  final RecordUpdateManyWithoutTaskNestedInput? records;

  @override
  Map<String, dynamic> toJson() => _$TaskUpdateInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedUpdateInput implements _i1.JsonSerializable {
  const TaskUncheckedUpdateInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.userId,
    this.profile,
    this.parentUuid,
    this.channelUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.children,
    this.assets,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$TaskUncheckedUpdateInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? title;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? content;

  final NullableStringFieldUpdateOperationsInput? location;

  final BoolFieldUpdateOperationsInput? requireLocation;

  final BoolFieldUpdateOperationsInput? requireTime;

  final BoolFieldUpdateOperationsInput? requireAttachment;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profile;

  final NullableStringFieldUpdateOperationsInput? parentUuid;

  final NullableStringFieldUpdateOperationsInput? channelUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskUncheckedUpdateManyWithoutParentNestedInput? children;

  final TaskAssetUncheckedUpdateManyWithoutTaskNestedInput? assets;

  final TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput? assignments;

  final SessionUncheckedUpdateManyWithoutTaskNestedInput? sessions;

  final RecordUncheckedUpdateManyWithoutTaskNestedInput? records;

  @override
  Map<String, dynamic> toJson() => _$TaskUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateManyInput implements _i1.JsonSerializable {
  const TaskCreateManyInput({
    required this.uuid,
    required this.title,
    required this.desc,
    required this.content,
    this.location,
    required this.requireLocation,
    required this.requireTime,
    required this.requireAttachment,
    required this.userId,
    required this.profile,
    this.parentUuid,
    this.channelUuid,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
  });

  factory TaskCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$TaskCreateManyInputFromJson(json);

  final String uuid;

  final String title;

  final String desc;

  final String content;

  final String? location;

  final bool requireLocation;

  final bool requireTime;

  final bool requireAttachment;

  final int userId;

  final String profile;

  final String? parentUuid;

  final String? channelUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TaskCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpdateManyMutationInput implements _i1.JsonSerializable {
  const TaskUpdateManyMutationInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskUpdateManyMutationInput.fromJson(Map<String, dynamic> json) =>
      _$TaskUpdateManyMutationInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? title;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? content;

  final NullableStringFieldUpdateOperationsInput? location;

  final BoolFieldUpdateOperationsInput? requireLocation;

  final BoolFieldUpdateOperationsInput? requireTime;

  final BoolFieldUpdateOperationsInput? requireAttachment;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TaskUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const TaskUncheckedUpdateManyInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.userId,
    this.profile,
    this.parentUuid,
    this.channelUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskUncheckedUpdateManyInput.fromJson(Map<String, dynamic> json) =>
      _$TaskUncheckedUpdateManyInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? title;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? content;

  final NullableStringFieldUpdateOperationsInput? location;

  final BoolFieldUpdateOperationsInput? requireLocation;

  final BoolFieldUpdateOperationsInput? requireTime;

  final BoolFieldUpdateOperationsInput? requireAttachment;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profile;

  final NullableStringFieldUpdateOperationsInput? parentUuid;

  final NullableStringFieldUpdateOperationsInput? channelUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TaskUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetCreateInput implements _i1.JsonSerializable {
  const TaskAssetCreateInput({
    required this.name,
    required this.hash,
    required this.assetRef,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    required this.task,
  });

  factory TaskAssetCreateInput.fromJson(Map<String, dynamic> json) =>
      _$TaskAssetCreateInputFromJson(json);

  final String name;

  final String hash;

  final String assetRef;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final TaskCreateNestedOneWithoutAssetsInput task;

  @override
  Map<String, dynamic> toJson() => _$TaskAssetCreateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetUncheckedCreateInput implements _i1.JsonSerializable {
  const TaskAssetUncheckedCreateInput({
    required this.name,
    required this.hash,
    required this.assetRef,
    required this.taskUuid,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
  });

  factory TaskAssetUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$TaskAssetUncheckedCreateInputFromJson(json);

  final String name;

  final String hash;

  final String assetRef;

  final String taskUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TaskAssetUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetUpdateInput implements _i1.JsonSerializable {
  const TaskAssetUpdateInput({
    this.name,
    this.hash,
    this.assetRef,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.task,
  });

  factory TaskAssetUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$TaskAssetUpdateInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? hash;

  final StringFieldUpdateOperationsInput? assetRef;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskUpdateOneRequiredWithoutAssetsNestedInput? task;

  @override
  Map<String, dynamic> toJson() => _$TaskAssetUpdateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetUncheckedUpdateInput implements _i1.JsonSerializable {
  const TaskAssetUncheckedUpdateInput({
    this.name,
    this.hash,
    this.assetRef,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssetUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$TaskAssetUncheckedUpdateInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? hash;

  final StringFieldUpdateOperationsInput? assetRef;

  final StringFieldUpdateOperationsInput? taskUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TaskAssetUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetCreateManyInput implements _i1.JsonSerializable {
  const TaskAssetCreateManyInput({
    required this.name,
    required this.hash,
    required this.assetRef,
    required this.taskUuid,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
  });

  factory TaskAssetCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$TaskAssetCreateManyInputFromJson(json);

  final String name;

  final String hash;

  final String assetRef;

  final String taskUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TaskAssetCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetUpdateManyMutationInput implements _i1.JsonSerializable {
  const TaskAssetUpdateManyMutationInput({
    this.name,
    this.hash,
    this.assetRef,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssetUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssetUpdateManyMutationInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? hash;

  final StringFieldUpdateOperationsInput? assetRef;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const TaskAssetUncheckedUpdateManyInput({
    this.name,
    this.hash,
    this.assetRef,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssetUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssetUncheckedUpdateManyInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? hash;

  final StringFieldUpdateOperationsInput? assetRef;

  final StringFieldUpdateOperationsInput? taskUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class ChannelCreateInput implements _i1.JsonSerializable {
  const ChannelCreateInput({
    required this.uuid,
    required this.name,
    required this.desc,
    required this.color,
    this.imgRef,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    required this.owner,
    this.subscriptions,
    this.tasks,
  });

  factory ChannelCreateInput.fromJson(Map<String, dynamic> json) =>
      _$ChannelCreateInputFromJson(json);

  final String uuid;

  final String name;

  final String desc;

  final String color;

  final String? imgRef;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final ProfileCreateNestedOneWithoutChannelsInput owner;

  final ChannelSubscriptionCreateNestedManyWithoutChannelInput? subscriptions;

  final TaskCreateNestedManyWithoutChannelInput? tasks;

  @override
  Map<String, dynamic> toJson() => _$ChannelCreateInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUncheckedCreateInput implements _i1.JsonSerializable {
  const ChannelUncheckedCreateInput({
    required this.uuid,
    required this.name,
    required this.desc,
    required this.color,
    this.imgRef,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.subscriptions,
    this.tasks,
  });

  factory ChannelUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$ChannelUncheckedCreateInputFromJson(json);

  final String uuid;

  final String name;

  final String desc;

  final String color;

  final String? imgRef;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final ChannelSubscriptionUncheckedCreateNestedManyWithoutChannelInput?
      subscriptions;

  final TaskUncheckedCreateNestedManyWithoutChannelInput? tasks;

  @override
  Map<String, dynamic> toJson() => _$ChannelUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUpdateInput implements _i1.JsonSerializable {
  const ChannelUpdateInput({
    this.uuid,
    this.name,
    this.desc,
    this.color,
    this.imgRef,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.owner,
    this.subscriptions,
    this.tasks,
  });

  factory ChannelUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$ChannelUpdateInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? color;

  final NullableStringFieldUpdateOperationsInput? imgRef;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ProfileUpdateOneRequiredWithoutChannelsNestedInput? owner;

  final ChannelSubscriptionUpdateManyWithoutChannelNestedInput? subscriptions;

  final TaskUpdateManyWithoutChannelNestedInput? tasks;

  @override
  Map<String, dynamic> toJson() => _$ChannelUpdateInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUncheckedUpdateInput implements _i1.JsonSerializable {
  const ChannelUncheckedUpdateInput({
    this.uuid,
    this.name,
    this.desc,
    this.color,
    this.imgRef,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.subscriptions,
    this.tasks,
  });

  factory ChannelUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$ChannelUncheckedUpdateInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? color;

  final NullableStringFieldUpdateOperationsInput? imgRef;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ChannelSubscriptionUncheckedUpdateManyWithoutChannelNestedInput?
      subscriptions;

  final TaskUncheckedUpdateManyWithoutChannelNestedInput? tasks;

  @override
  Map<String, dynamic> toJson() => _$ChannelUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class ChannelCreateManyInput implements _i1.JsonSerializable {
  const ChannelCreateManyInput({
    required this.uuid,
    required this.name,
    required this.desc,
    required this.color,
    this.imgRef,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
  });

  factory ChannelCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$ChannelCreateManyInputFromJson(json);

  final String uuid;

  final String name;

  final String desc;

  final String color;

  final String? imgRef;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$ChannelCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUpdateManyMutationInput implements _i1.JsonSerializable {
  const ChannelUpdateManyMutationInput({
    this.uuid,
    this.name,
    this.desc,
    this.color,
    this.imgRef,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelUpdateManyMutationInput.fromJson(Map<String, dynamic> json) =>
      _$ChannelUpdateManyMutationInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? color;

  final NullableStringFieldUpdateOperationsInput? imgRef;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$ChannelUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const ChannelUncheckedUpdateManyInput({
    this.uuid,
    this.name,
    this.desc,
    this.color,
    this.imgRef,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelUncheckedUpdateManyInput.fromJson(Map<String, dynamic> json) =>
      _$ChannelUncheckedUpdateManyInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? color;

  final NullableStringFieldUpdateOperationsInput? imgRef;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class SessionCreateInput implements _i1.JsonSerializable {
  const SessionCreateInput({
    required this.uuid,
    required this.start,
    required this.end,
    required this.cycle,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    required this.task,
    this.schedules,
    this.records,
  });

  factory SessionCreateInput.fromJson(Map<String, dynamic> json) =>
      _$SessionCreateInputFromJson(json);

  final String uuid;

  final BigInt start;

  final BigInt end;

  final BigInt cycle;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final TaskCreateNestedOneWithoutSessionsInput task;

  final ScheduleCreateNestedManyWithoutSessionInput? schedules;

  final RecordCreateNestedManyWithoutSessionInput? records;

  @override
  Map<String, dynamic> toJson() => _$SessionCreateInputToJson(this);
}

@_i1.jsonSerializable
class SessionUncheckedCreateInput implements _i1.JsonSerializable {
  const SessionUncheckedCreateInput({
    required this.uuid,
    required this.start,
    required this.end,
    required this.cycle,
    required this.taskUuid,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    this.schedules,
    this.records,
  });

  factory SessionUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$SessionUncheckedCreateInputFromJson(json);

  final String uuid;

  final BigInt start;

  final BigInt end;

  final BigInt cycle;

  final String taskUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final ScheduleUncheckedCreateNestedManyWithoutSessionInput? schedules;

  final RecordUncheckedCreateNestedManyWithoutSessionInput? records;

  @override
  Map<String, dynamic> toJson() => _$SessionUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class SessionUpdateInput implements _i1.JsonSerializable {
  const SessionUpdateInput({
    this.uuid,
    this.start,
    this.end,
    this.cycle,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.task,
    this.schedules,
    this.records,
  });

  factory SessionUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$SessionUpdateInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final BigIntFieldUpdateOperationsInput? start;

  final BigIntFieldUpdateOperationsInput? end;

  final BigIntFieldUpdateOperationsInput? cycle;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskUpdateOneRequiredWithoutSessionsNestedInput? task;

  final ScheduleUpdateManyWithoutSessionNestedInput? schedules;

  final RecordUpdateManyWithoutSessionNestedInput? records;

  @override
  Map<String, dynamic> toJson() => _$SessionUpdateInputToJson(this);
}

@_i1.jsonSerializable
class SessionUncheckedUpdateInput implements _i1.JsonSerializable {
  const SessionUncheckedUpdateInput({
    this.uuid,
    this.start,
    this.end,
    this.cycle,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.schedules,
    this.records,
  });

  factory SessionUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$SessionUncheckedUpdateInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final BigIntFieldUpdateOperationsInput? start;

  final BigIntFieldUpdateOperationsInput? end;

  final BigIntFieldUpdateOperationsInput? cycle;

  final StringFieldUpdateOperationsInput? taskUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ScheduleUncheckedUpdateManyWithoutSessionNestedInput? schedules;

  final RecordUncheckedUpdateManyWithoutSessionNestedInput? records;

  @override
  Map<String, dynamic> toJson() => _$SessionUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class SessionCreateManyInput implements _i1.JsonSerializable {
  const SessionCreateManyInput({
    required this.uuid,
    required this.start,
    required this.end,
    required this.cycle,
    required this.taskUuid,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory SessionCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$SessionCreateManyInputFromJson(json);

  final String uuid;

  final BigInt start;

  final BigInt end;

  final BigInt cycle;

  final String taskUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$SessionCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class SessionUpdateManyMutationInput implements _i1.JsonSerializable {
  const SessionUpdateManyMutationInput({
    this.uuid,
    this.start,
    this.end,
    this.cycle,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory SessionUpdateManyMutationInput.fromJson(Map<String, dynamic> json) =>
      _$SessionUpdateManyMutationInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final BigIntFieldUpdateOperationsInput? start;

  final BigIntFieldUpdateOperationsInput? end;

  final BigIntFieldUpdateOperationsInput? cycle;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$SessionUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class SessionUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const SessionUncheckedUpdateManyInput({
    this.uuid,
    this.start,
    this.end,
    this.cycle,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory SessionUncheckedUpdateManyInput.fromJson(Map<String, dynamic> json) =>
      _$SessionUncheckedUpdateManyInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final BigIntFieldUpdateOperationsInput? start;

  final BigIntFieldUpdateOperationsInput? end;

  final BigIntFieldUpdateOperationsInput? cycle;

  final StringFieldUpdateOperationsInput? taskUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class RecordCreateInput implements _i1.JsonSerializable {
  const RecordCreateInput({
    required this.time,
    required this.recordIndex,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    required this.session,
    required this.task,
    required this.profile,
    this.attachment,
  });

  factory RecordCreateInput.fromJson(Map<String, dynamic> json) =>
      _$RecordCreateInputFromJson(json);

  final BigInt time;

  final int recordIndex;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final SessionCreateNestedOneWithoutRecordsInput session;

  final TaskCreateNestedOneWithoutRecordsInput task;

  final ProfileCreateNestedOneWithoutRecordsInput profile;

  final RecordAttachmentCreateNestedOneWithoutRecordInput? attachment;

  @override
  Map<String, dynamic> toJson() => _$RecordCreateInputToJson(this);
}

@_i1.jsonSerializable
class RecordUncheckedCreateInput implements _i1.JsonSerializable {
  const RecordUncheckedCreateInput({
    required this.time,
    required this.recordIndex,
    required this.sessionUuid,
    required this.taskUuid,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    this.attachment,
  });

  factory RecordUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$RecordUncheckedCreateInputFromJson(json);

  final BigInt time;

  final int recordIndex;

  final String sessionUuid;

  final String taskUuid;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final RecordAttachmentUncheckedCreateNestedOneWithoutRecordInput? attachment;

  @override
  Map<String, dynamic> toJson() => _$RecordUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class RecordUpdateInput implements _i1.JsonSerializable {
  const RecordUpdateInput({
    this.time,
    this.recordIndex,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.session,
    this.task,
    this.profile,
    this.attachment,
  });

  factory RecordUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$RecordUpdateInputFromJson(json);

  final BigIntFieldUpdateOperationsInput? time;

  final IntFieldUpdateOperationsInput? recordIndex;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final SessionUpdateOneRequiredWithoutRecordsNestedInput? session;

  final TaskUpdateOneRequiredWithoutRecordsNestedInput? task;

  final ProfileUpdateOneRequiredWithoutRecordsNestedInput? profile;

  final RecordAttachmentUpdateOneWithoutRecordNestedInput? attachment;

  @override
  Map<String, dynamic> toJson() => _$RecordUpdateInputToJson(this);
}

@_i1.jsonSerializable
class RecordUncheckedUpdateInput implements _i1.JsonSerializable {
  const RecordUncheckedUpdateInput({
    this.time,
    this.recordIndex,
    this.sessionUuid,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.attachment,
  });

  factory RecordUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$RecordUncheckedUpdateInputFromJson(json);

  final BigIntFieldUpdateOperationsInput? time;

  final IntFieldUpdateOperationsInput? recordIndex;

  final StringFieldUpdateOperationsInput? sessionUuid;

  final StringFieldUpdateOperationsInput? taskUuid;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final RecordAttachmentUncheckedUpdateOneWithoutRecordNestedInput? attachment;

  @override
  Map<String, dynamic> toJson() => _$RecordUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class RecordCreateManyInput implements _i1.JsonSerializable {
  const RecordCreateManyInput({
    required this.time,
    required this.recordIndex,
    required this.sessionUuid,
    required this.taskUuid,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory RecordCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$RecordCreateManyInputFromJson(json);

  final BigInt time;

  final int recordIndex;

  final String sessionUuid;

  final String taskUuid;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$RecordCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class RecordUpdateManyMutationInput implements _i1.JsonSerializable {
  const RecordUpdateManyMutationInput({
    this.time,
    this.recordIndex,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory RecordUpdateManyMutationInput.fromJson(Map<String, dynamic> json) =>
      _$RecordUpdateManyMutationInputFromJson(json);

  final BigIntFieldUpdateOperationsInput? time;

  final IntFieldUpdateOperationsInput? recordIndex;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$RecordUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class RecordUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const RecordUncheckedUpdateManyInput({
    this.time,
    this.recordIndex,
    this.sessionUuid,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory RecordUncheckedUpdateManyInput.fromJson(Map<String, dynamic> json) =>
      _$RecordUncheckedUpdateManyInputFromJson(json);

  final BigIntFieldUpdateOperationsInput? time;

  final IntFieldUpdateOperationsInput? recordIndex;

  final StringFieldUpdateOperationsInput? sessionUuid;

  final StringFieldUpdateOperationsInput? taskUuid;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$RecordUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentCreateInput implements _i1.JsonSerializable {
  const RecordAttachmentCreateInput({
    required this.hash,
    required this.name,
    required this.assetRef,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    required this.record,
  });

  factory RecordAttachmentCreateInput.fromJson(Map<String, dynamic> json) =>
      _$RecordAttachmentCreateInputFromJson(json);

  final String hash;

  final String name;

  final String assetRef;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final RecordCreateNestedOneWithoutAttachmentInput record;

  @override
  Map<String, dynamic> toJson() => _$RecordAttachmentCreateInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentUncheckedCreateInput implements _i1.JsonSerializable {
  const RecordAttachmentUncheckedCreateInput({
    required this.hash,
    required this.name,
    required this.assetRef,
    required this.sessionUuid,
    required this.taskUuid,
    required this.userId,
    required this.profileName,
    required this.recordIndex,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory RecordAttachmentUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentUncheckedCreateInputFromJson(json);

  final String hash;

  final String name;

  final String assetRef;

  final String sessionUuid;

  final String taskUuid;

  final int userId;

  final String profileName;

  final int recordIndex;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentUpdateInput implements _i1.JsonSerializable {
  const RecordAttachmentUpdateInput({
    this.hash,
    this.name,
    this.assetRef,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.record,
  });

  factory RecordAttachmentUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$RecordAttachmentUpdateInputFromJson(json);

  final StringFieldUpdateOperationsInput? hash;

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? assetRef;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final RecordUpdateOneRequiredWithoutAttachmentNestedInput? record;

  @override
  Map<String, dynamic> toJson() => _$RecordAttachmentUpdateInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentUncheckedUpdateInput implements _i1.JsonSerializable {
  const RecordAttachmentUncheckedUpdateInput({
    this.hash,
    this.name,
    this.assetRef,
    this.sessionUuid,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.recordIndex,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory RecordAttachmentUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentUncheckedUpdateInputFromJson(json);

  final StringFieldUpdateOperationsInput? hash;

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? assetRef;

  final StringFieldUpdateOperationsInput? sessionUuid;

  final StringFieldUpdateOperationsInput? taskUuid;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final IntFieldUpdateOperationsInput? recordIndex;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentCreateManyInput implements _i1.JsonSerializable {
  const RecordAttachmentCreateManyInput({
    required this.hash,
    required this.name,
    required this.assetRef,
    required this.sessionUuid,
    required this.taskUuid,
    required this.userId,
    required this.profileName,
    required this.recordIndex,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory RecordAttachmentCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$RecordAttachmentCreateManyInputFromJson(json);

  final String hash;

  final String name;

  final String assetRef;

  final String sessionUuid;

  final String taskUuid;

  final int userId;

  final String profileName;

  final int recordIndex;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentUpdateManyMutationInput implements _i1.JsonSerializable {
  const RecordAttachmentUpdateManyMutationInput({
    this.hash,
    this.name,
    this.assetRef,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory RecordAttachmentUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentUpdateManyMutationInputFromJson(json);

  final StringFieldUpdateOperationsInput? hash;

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? assetRef;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const RecordAttachmentUncheckedUpdateManyInput({
    this.hash,
    this.name,
    this.assetRef,
    this.sessionUuid,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.recordIndex,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory RecordAttachmentUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentUncheckedUpdateManyInputFromJson(json);

  final StringFieldUpdateOperationsInput? hash;

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? assetRef;

  final StringFieldUpdateOperationsInput? sessionUuid;

  final StringFieldUpdateOperationsInput? taskUuid;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final IntFieldUpdateOperationsInput? recordIndex;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class CategoryCreateInput implements _i1.JsonSerializable {
  const CategoryCreateInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    required this.profile,
    this.assignments,
  });

  factory CategoryCreateInput.fromJson(Map<String, dynamic> json) =>
      _$CategoryCreateInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final ProfileCreateNestedOneWithoutCategoriesInput profile;

  final TaskAssignmentCreateNestedManyWithoutCategoryInput? assignments;

  @override
  Map<String, dynamic> toJson() => _$CategoryCreateInputToJson(this);
}

@_i1.jsonSerializable
class CategoryUncheckedCreateInput implements _i1.JsonSerializable {
  const CategoryUncheckedCreateInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    this.assignments,
  });

  factory CategoryUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$CategoryUncheckedCreateInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final TaskAssignmentUncheckedCreateNestedManyWithoutCategoryInput?
      assignments;

  @override
  Map<String, dynamic> toJson() => _$CategoryUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class CategoryUpdateInput implements _i1.JsonSerializable {
  const CategoryUpdateInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.profile,
    this.assignments,
  });

  factory CategoryUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$CategoryUpdateInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ProfileUpdateOneRequiredWithoutCategoriesNestedInput? profile;

  final TaskAssignmentUpdateManyWithoutCategoryNestedInput? assignments;

  @override
  Map<String, dynamic> toJson() => _$CategoryUpdateInputToJson(this);
}

@_i1.jsonSerializable
class CategoryUncheckedUpdateInput implements _i1.JsonSerializable {
  const CategoryUncheckedUpdateInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.assignments,
  });

  factory CategoryUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$CategoryUncheckedUpdateInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskAssignmentUncheckedUpdateManyWithoutCategoryNestedInput?
      assignments;

  @override
  Map<String, dynamic> toJson() => _$CategoryUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class CategoryCreateManyInput implements _i1.JsonSerializable {
  const CategoryCreateManyInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory CategoryCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$CategoryCreateManyInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$CategoryCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class CategoryUpdateManyMutationInput implements _i1.JsonSerializable {
  const CategoryUpdateManyMutationInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory CategoryUpdateManyMutationInput.fromJson(Map<String, dynamic> json) =>
      _$CategoryUpdateManyMutationInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class CategoryUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const CategoryUncheckedUpdateManyInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory CategoryUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryUncheckedUpdateManyInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class TagCreateInput implements _i1.JsonSerializable {
  const TagCreateInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    required this.profile,
    this.assignments,
  });

  factory TagCreateInput.fromJson(Map<String, dynamic> json) =>
      _$TagCreateInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final ProfileCreateNestedOneWithoutTagsInput profile;

  final TaskAssignmentTagsCreateNestedManyWithoutTagInput? assignments;

  @override
  Map<String, dynamic> toJson() => _$TagCreateInputToJson(this);
}

@_i1.jsonSerializable
class TagUncheckedCreateInput implements _i1.JsonSerializable {
  const TagUncheckedCreateInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    this.assignments,
  });

  factory TagUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$TagUncheckedCreateInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final TaskAssignmentTagsUncheckedCreateNestedManyWithoutTagInput? assignments;

  @override
  Map<String, dynamic> toJson() => _$TagUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class TagUpdateInput implements _i1.JsonSerializable {
  const TagUpdateInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.profile,
    this.assignments,
  });

  factory TagUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$TagUpdateInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ProfileUpdateOneRequiredWithoutTagsNestedInput? profile;

  final TaskAssignmentTagsUpdateManyWithoutTagNestedInput? assignments;

  @override
  Map<String, dynamic> toJson() => _$TagUpdateInputToJson(this);
}

@_i1.jsonSerializable
class TagUncheckedUpdateInput implements _i1.JsonSerializable {
  const TagUncheckedUpdateInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.assignments,
  });

  factory TagUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$TagUncheckedUpdateInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskAssignmentTagsUncheckedUpdateManyWithoutTagNestedInput? assignments;

  @override
  Map<String, dynamic> toJson() => _$TagUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class TagCreateManyInput implements _i1.JsonSerializable {
  const TagCreateManyInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory TagCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$TagCreateManyInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TagCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class TagUpdateManyMutationInput implements _i1.JsonSerializable {
  const TagUpdateManyMutationInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TagUpdateManyMutationInput.fromJson(Map<String, dynamic> json) =>
      _$TagUpdateManyMutationInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TagUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class TagUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const TagUncheckedUpdateManyInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TagUncheckedUpdateManyInput.fromJson(Map<String, dynamic> json) =>
      _$TagUncheckedUpdateManyInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TagUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentCreateInput implements _i1.JsonSerializable {
  const TaskAssignmentCreateInput({
    required this.status,
    required this.priority,
    required this.starred,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    required this.task,
    required this.profile,
    this.category,
    this.tags,
  });

  factory TaskAssignmentCreateInput.fromJson(Map<String, dynamic> json) =>
      _$TaskAssignmentCreateInputFromJson(json);

  final TaskAssignmentStatus status;

  final TaskPriority priority;

  final bool starred;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final TaskCreateNestedOneWithoutAssignmentsInput task;

  final ProfileCreateNestedOneWithoutTaskAssignmentsInput profile;

  final CategoryCreateNestedOneWithoutAssignmentsInput? category;

  final TaskAssignmentTagsCreateNestedManyWithoutAssignmentInput? tags;

  @override
  Map<String, dynamic> toJson() => _$TaskAssignmentCreateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUncheckedCreateInput implements _i1.JsonSerializable {
  const TaskAssignmentUncheckedCreateInput({
    required this.status,
    required this.priority,
    required this.starred,
    required this.taskUuid,
    required this.userId,
    required this.profileName,
    this.categoryName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    this.tags,
  });

  factory TaskAssignmentUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUncheckedCreateInputFromJson(json);

  final TaskAssignmentStatus status;

  final TaskPriority priority;

  final bool starred;

  final String taskUuid;

  final int userId;

  final String profileName;

  final String? categoryName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final TaskAssignmentTagsUncheckedCreateNestedManyWithoutAssignmentInput? tags;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUpdateInput implements _i1.JsonSerializable {
  const TaskAssignmentUpdateInput({
    this.status,
    this.priority,
    this.starred,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.task,
    this.profile,
    this.category,
    this.tags,
  });

  factory TaskAssignmentUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$TaskAssignmentUpdateInputFromJson(json);

  final TaskAssignmentStatus? status;

  final TaskPriority? priority;

  final BoolFieldUpdateOperationsInput? starred;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskUpdateOneRequiredWithoutAssignmentsNestedInput? task;

  final ProfileUpdateOneRequiredWithoutTaskAssignmentsNestedInput? profile;

  final CategoryUpdateOneWithoutAssignmentsNestedInput? category;

  final TaskAssignmentTagsUpdateManyWithoutAssignmentNestedInput? tags;

  @override
  Map<String, dynamic> toJson() => _$TaskAssignmentUpdateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUncheckedUpdateInput implements _i1.JsonSerializable {
  const TaskAssignmentUncheckedUpdateInput({
    this.status,
    this.priority,
    this.starred,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.categoryName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.tags,
  });

  factory TaskAssignmentUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUncheckedUpdateInputFromJson(json);

  final TaskAssignmentStatus? status;

  final TaskPriority? priority;

  final BoolFieldUpdateOperationsInput? starred;

  final StringFieldUpdateOperationsInput? taskUuid;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final NullableStringFieldUpdateOperationsInput? categoryName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskAssignmentTagsUncheckedUpdateManyWithoutAssignmentNestedInput? tags;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentCreateManyInput implements _i1.JsonSerializable {
  const TaskAssignmentCreateManyInput({
    required this.status,
    required this.priority,
    required this.starred,
    required this.taskUuid,
    required this.userId,
    required this.profileName,
    this.categoryName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory TaskAssignmentCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$TaskAssignmentCreateManyInputFromJson(json);

  final TaskAssignmentStatus status;

  final TaskPriority priority;

  final bool starred;

  final String taskUuid;

  final int userId;

  final String profileName;

  final String? categoryName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TaskAssignmentCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUpdateManyMutationInput implements _i1.JsonSerializable {
  const TaskAssignmentUpdateManyMutationInput({
    this.status,
    this.priority,
    this.starred,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssignmentUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUpdateManyMutationInputFromJson(json);

  final TaskAssignmentStatus? status;

  final TaskPriority? priority;

  final BoolFieldUpdateOperationsInput? starred;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const TaskAssignmentUncheckedUpdateManyInput({
    this.status,
    this.priority,
    this.starred,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.categoryName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssignmentUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUncheckedUpdateManyInputFromJson(json);

  final TaskAssignmentStatus? status;

  final TaskPriority? priority;

  final BoolFieldUpdateOperationsInput? starred;

  final StringFieldUpdateOperationsInput? taskUuid;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final NullableStringFieldUpdateOperationsInput? categoryName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsCreateInput implements _i1.JsonSerializable {
  const TaskAssignmentTagsCreateInput({
    required this.assignment,
    required this.tag,
  });

  factory TaskAssignmentTagsCreateInput.fromJson(Map<String, dynamic> json) =>
      _$TaskAssignmentTagsCreateInputFromJson(json);

  final TaskAssignmentCreateNestedOneWithoutTagsInput assignment;

  final TagCreateNestedOneWithoutAssignmentsInput tag;

  @override
  Map<String, dynamic> toJson() => _$TaskAssignmentTagsCreateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUncheckedCreateInput implements _i1.JsonSerializable {
  const TaskAssignmentTagsUncheckedCreateInput({
    required this.taskUuid,
    required this.userId,
    required this.profileName,
    required this.tagName,
  });

  factory TaskAssignmentTagsUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUncheckedCreateInputFromJson(json);

  final String taskUuid;

  final int userId;

  final String profileName;

  final String tagName;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUpdateInput implements _i1.JsonSerializable {
  const TaskAssignmentTagsUpdateInput({
    this.assignment,
    this.tag,
  });

  factory TaskAssignmentTagsUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUpdateInputFromJson(json);

  final TaskAssignmentUpdateOneRequiredWithoutTagsNestedInput? assignment;

  final TagUpdateOneRequiredWithoutAssignmentsNestedInput? tag;

  @override
  Map<String, dynamic> toJson() => _$TaskAssignmentTagsUpdateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUncheckedUpdateInput implements _i1.JsonSerializable {
  const TaskAssignmentTagsUncheckedUpdateInput({
    this.taskUuid,
    this.userId,
    this.profileName,
    this.tagName,
  });

  factory TaskAssignmentTagsUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUncheckedUpdateInputFromJson(json);

  final StringFieldUpdateOperationsInput? taskUuid;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final StringFieldUpdateOperationsInput? tagName;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsCreateManyInput implements _i1.JsonSerializable {
  const TaskAssignmentTagsCreateManyInput({
    required this.taskUuid,
    required this.userId,
    required this.profileName,
    required this.tagName,
  });

  factory TaskAssignmentTagsCreateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsCreateManyInputFromJson(json);

  final String taskUuid;

  final int userId;

  final String profileName;

  final String tagName;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUpdateManyMutationInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsUpdateManyMutationInput();

  factory TaskAssignmentTagsUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUpdateManyMutationInputFromJson(json);

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUncheckedUpdateManyInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsUncheckedUpdateManyInput({
    this.taskUuid,
    this.userId,
    this.profileName,
    this.tagName,
  });

  factory TaskAssignmentTagsUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUncheckedUpdateManyInputFromJson(json);

  final StringFieldUpdateOperationsInput? taskUuid;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final StringFieldUpdateOperationsInput? tagName;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionCreateInput implements _i1.JsonSerializable {
  const ChannelSubscriptionCreateInput({
    required this.shareRecord,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    required this.channel,
    required this.profile,
  });

  factory ChannelSubscriptionCreateInput.fromJson(Map<String, dynamic> json) =>
      _$ChannelSubscriptionCreateInputFromJson(json);

  final bool shareRecord;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final ChannelCreateNestedOneWithoutSubscriptionsInput channel;

  final ProfileCreateNestedOneWithoutChannelSubscriptionsInput profile;

  @override
  Map<String, dynamic> toJson() => _$ChannelSubscriptionCreateInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUncheckedCreateInput implements _i1.JsonSerializable {
  const ChannelSubscriptionUncheckedCreateInput({
    required this.shareRecord,
    required this.channelUuid,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory ChannelSubscriptionUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionUncheckedCreateInputFromJson(json);

  final bool shareRecord;

  final String channelUuid;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUpdateInput implements _i1.JsonSerializable {
  const ChannelSubscriptionUpdateInput({
    this.shareRecord,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.channel,
    this.profile,
  });

  factory ChannelSubscriptionUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$ChannelSubscriptionUpdateInputFromJson(json);

  final BoolFieldUpdateOperationsInput? shareRecord;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ChannelUpdateOneRequiredWithoutSubscriptionsNestedInput? channel;

  final ProfileUpdateOneRequiredWithoutChannelSubscriptionsNestedInput? profile;

  @override
  Map<String, dynamic> toJson() => _$ChannelSubscriptionUpdateInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUncheckedUpdateInput implements _i1.JsonSerializable {
  const ChannelSubscriptionUncheckedUpdateInput({
    this.shareRecord,
    this.channelUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelSubscriptionUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionUncheckedUpdateInputFromJson(json);

  final BoolFieldUpdateOperationsInput? shareRecord;

  final StringFieldUpdateOperationsInput? channelUuid;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionCreateManyInput implements _i1.JsonSerializable {
  const ChannelSubscriptionCreateManyInput({
    required this.shareRecord,
    required this.channelUuid,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory ChannelSubscriptionCreateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionCreateManyInputFromJson(json);

  final bool shareRecord;

  final String channelUuid;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUpdateManyMutationInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionUpdateManyMutationInput({
    this.shareRecord,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelSubscriptionUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionUpdateManyMutationInputFromJson(json);

  final BoolFieldUpdateOperationsInput? shareRecord;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUncheckedUpdateManyInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionUncheckedUpdateManyInput({
    this.shareRecord,
    this.channelUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelSubscriptionUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionUncheckedUpdateManyInputFromJson(json);

  final BoolFieldUpdateOperationsInput? shareRecord;

  final StringFieldUpdateOperationsInput? channelUuid;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleCreateInput implements _i1.JsonSerializable {
  const ScheduleCreateInput({
    required this.relStart,
    required this.relEnd,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    required this.session,
    required this.profile,
  });

  factory ScheduleCreateInput.fromJson(Map<String, dynamic> json) =>
      _$ScheduleCreateInputFromJson(json);

  final BigInt relStart;

  final BigInt relEnd;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final SessionCreateNestedOneWithoutSchedulesInput session;

  final ProfileCreateNestedOneWithoutSchedulesInput profile;

  @override
  Map<String, dynamic> toJson() => _$ScheduleCreateInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleUncheckedCreateInput implements _i1.JsonSerializable {
  const ScheduleUncheckedCreateInput({
    required this.relStart,
    required this.relEnd,
    required this.sessionUuid,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory ScheduleUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$ScheduleUncheckedCreateInputFromJson(json);

  final BigInt relStart;

  final BigInt relEnd;

  final String sessionUuid;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$ScheduleUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleUpdateInput implements _i1.JsonSerializable {
  const ScheduleUpdateInput({
    this.relStart,
    this.relEnd,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.session,
    this.profile,
  });

  factory ScheduleUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$ScheduleUpdateInputFromJson(json);

  final BigIntFieldUpdateOperationsInput? relStart;

  final BigIntFieldUpdateOperationsInput? relEnd;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final SessionUpdateOneRequiredWithoutSchedulesNestedInput? session;

  final ProfileUpdateOneRequiredWithoutSchedulesNestedInput? profile;

  @override
  Map<String, dynamic> toJson() => _$ScheduleUpdateInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleUncheckedUpdateInput implements _i1.JsonSerializable {
  const ScheduleUncheckedUpdateInput({
    this.relStart,
    this.relEnd,
    this.sessionUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ScheduleUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$ScheduleUncheckedUpdateInputFromJson(json);

  final BigIntFieldUpdateOperationsInput? relStart;

  final BigIntFieldUpdateOperationsInput? relEnd;

  final StringFieldUpdateOperationsInput? sessionUuid;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$ScheduleUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleCreateManyInput implements _i1.JsonSerializable {
  const ScheduleCreateManyInput({
    required this.relStart,
    required this.relEnd,
    required this.sessionUuid,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory ScheduleCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$ScheduleCreateManyInputFromJson(json);

  final BigInt relStart;

  final BigInt relEnd;

  final String sessionUuid;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$ScheduleCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleUpdateManyMutationInput implements _i1.JsonSerializable {
  const ScheduleUpdateManyMutationInput({
    this.relStart,
    this.relEnd,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ScheduleUpdateManyMutationInput.fromJson(Map<String, dynamic> json) =>
      _$ScheduleUpdateManyMutationInputFromJson(json);

  final BigIntFieldUpdateOperationsInput? relStart;

  final BigIntFieldUpdateOperationsInput? relEnd;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const ScheduleUncheckedUpdateManyInput({
    this.relStart,
    this.relEnd,
    this.sessionUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ScheduleUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleUncheckedUpdateManyInputFromJson(json);

  final BigIntFieldUpdateOperationsInput? relStart;

  final BigIntFieldUpdateOperationsInput? relEnd;

  final StringFieldUpdateOperationsInput? sessionUuid;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class FileRefCreateInput implements _i1.JsonSerializable {
  const FileRefCreateInput({
    required this.hash,
    this.count,
  });

  factory FileRefCreateInput.fromJson(Map<String, dynamic> json) =>
      _$FileRefCreateInputFromJson(json);

  final String hash;

  final int? count;

  @override
  Map<String, dynamic> toJson() => _$FileRefCreateInputToJson(this);
}

@_i1.jsonSerializable
class FileRefUncheckedCreateInput implements _i1.JsonSerializable {
  const FileRefUncheckedCreateInput({
    required this.hash,
    this.count,
  });

  factory FileRefUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$FileRefUncheckedCreateInputFromJson(json);

  final String hash;

  final int? count;

  @override
  Map<String, dynamic> toJson() => _$FileRefUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class FileRefUpdateInput implements _i1.JsonSerializable {
  const FileRefUpdateInput({
    this.hash,
    this.count,
  });

  factory FileRefUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$FileRefUpdateInputFromJson(json);

  final StringFieldUpdateOperationsInput? hash;

  final NullableIntFieldUpdateOperationsInput? count;

  @override
  Map<String, dynamic> toJson() => _$FileRefUpdateInputToJson(this);
}

@_i1.jsonSerializable
class FileRefUncheckedUpdateInput implements _i1.JsonSerializable {
  const FileRefUncheckedUpdateInput({
    this.hash,
    this.count,
  });

  factory FileRefUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$FileRefUncheckedUpdateInputFromJson(json);

  final StringFieldUpdateOperationsInput? hash;

  final NullableIntFieldUpdateOperationsInput? count;

  @override
  Map<String, dynamic> toJson() => _$FileRefUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class FileRefCreateManyInput implements _i1.JsonSerializable {
  const FileRefCreateManyInput({
    required this.hash,
    this.count,
  });

  factory FileRefCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$FileRefCreateManyInputFromJson(json);

  final String hash;

  final int? count;

  @override
  Map<String, dynamic> toJson() => _$FileRefCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class FileRefUpdateManyMutationInput implements _i1.JsonSerializable {
  const FileRefUpdateManyMutationInput({
    this.hash,
    this.count,
  });

  factory FileRefUpdateManyMutationInput.fromJson(Map<String, dynamic> json) =>
      _$FileRefUpdateManyMutationInputFromJson(json);

  final StringFieldUpdateOperationsInput? hash;

  final NullableIntFieldUpdateOperationsInput? count;

  @override
  Map<String, dynamic> toJson() => _$FileRefUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class FileRefUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const FileRefUncheckedUpdateManyInput({
    this.hash,
    this.count,
  });

  factory FileRefUncheckedUpdateManyInput.fromJson(Map<String, dynamic> json) =>
      _$FileRefUncheckedUpdateManyInputFromJson(json);

  final StringFieldUpdateOperationsInput? hash;

  final NullableIntFieldUpdateOperationsInput? count;

  @override
  Map<String, dynamic> toJson() =>
      _$FileRefUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class IntFilter implements _i1.JsonSerializable {
  const IntFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory IntFilter.fromJson(Map<String, dynamic> json) =>
      _$IntFilterFromJson(json);

  final int? equals;

  @JsonKey(name: r'in')
  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final NestedIntFilter? not;

  @override
  Map<String, dynamic> toJson() => _$IntFilterToJson(this);
}

@_i1.jsonSerializable
class StringFilter implements _i1.JsonSerializable {
  const StringFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.mode,
    this.not,
  });

  factory StringFilter.fromJson(Map<String, dynamic> json) =>
      _$StringFilterFromJson(json);

  final String? equals;

  @JsonKey(name: r'in')
  final Iterable<String>? $in;

  final Iterable<String>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final QueryMode? mode;

  final NestedStringFilter? not;

  @override
  Map<String, dynamic> toJson() => _$StringFilterToJson(this);
}

@_i1.jsonSerializable
class StringNullableFilter implements _i1.JsonSerializable {
  const StringNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.mode,
    this.not,
  });

  factory StringNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$StringNullableFilterFromJson(json);

  final String? equals;

  @JsonKey(name: r'in')
  final Iterable<String>? $in;

  final Iterable<String>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final QueryMode? mode;

  final NestedStringNullableFilter? not;

  @override
  Map<String, dynamic> toJson() => _$StringNullableFilterToJson(this);
}

@_i1.jsonSerializable
class ProfileListRelationFilter implements _i1.JsonSerializable {
  const ProfileListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  factory ProfileListRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$ProfileListRelationFilterFromJson(json);

  final ProfileWhereInput? every;

  final ProfileWhereInput? some;

  final ProfileWhereInput? none;

  @override
  Map<String, dynamic> toJson() => _$ProfileListRelationFilterToJson(this);
}

@_i1.jsonSerializable
class ProfileOrderByRelationAggregateInput implements _i1.JsonSerializable {
  const ProfileOrderByRelationAggregateInput({this.$count});

  factory ProfileOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: r'_count')
  final SortOrder? $count;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileOrderByRelationAggregateInputToJson(this);
}

@_i1.jsonSerializable
class UserCountOrderByAggregateInput implements _i1.JsonSerializable {
  const UserCountOrderByAggregateInput({
    this.id,
    this.name,
    this.email,
    this.phone,
    this.password,
    this.avatarRef,
    this.unionId,
    this.tencentId,
    this.appleId,
  });

  factory UserCountOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$UserCountOrderByAggregateInputFromJson(json);

  final SortOrder? id;

  final SortOrder? name;

  final SortOrder? email;

  final SortOrder? phone;

  final SortOrder? password;

  final SortOrder? avatarRef;

  final SortOrder? unionId;

  final SortOrder? tencentId;

  final SortOrder? appleId;

  @override
  Map<String, dynamic> toJson() => _$UserCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class UserAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const UserAvgOrderByAggregateInput({this.id});

  factory UserAvgOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$UserAvgOrderByAggregateInputFromJson(json);

  final SortOrder? id;

  @override
  Map<String, dynamic> toJson() => _$UserAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class UserMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const UserMaxOrderByAggregateInput({
    this.id,
    this.name,
    this.email,
    this.phone,
    this.password,
    this.avatarRef,
    this.unionId,
    this.tencentId,
    this.appleId,
  });

  factory UserMaxOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$UserMaxOrderByAggregateInputFromJson(json);

  final SortOrder? id;

  final SortOrder? name;

  final SortOrder? email;

  final SortOrder? phone;

  final SortOrder? password;

  final SortOrder? avatarRef;

  final SortOrder? unionId;

  final SortOrder? tencentId;

  final SortOrder? appleId;

  @override
  Map<String, dynamic> toJson() => _$UserMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class UserMinOrderByAggregateInput implements _i1.JsonSerializable {
  const UserMinOrderByAggregateInput({
    this.id,
    this.name,
    this.email,
    this.phone,
    this.password,
    this.avatarRef,
    this.unionId,
    this.tencentId,
    this.appleId,
  });

  factory UserMinOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$UserMinOrderByAggregateInputFromJson(json);

  final SortOrder? id;

  final SortOrder? name;

  final SortOrder? email;

  final SortOrder? phone;

  final SortOrder? password;

  final SortOrder? avatarRef;

  final SortOrder? unionId;

  final SortOrder? tencentId;

  final SortOrder? appleId;

  @override
  Map<String, dynamic> toJson() => _$UserMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class UserSumOrderByAggregateInput implements _i1.JsonSerializable {
  const UserSumOrderByAggregateInput({this.id});

  factory UserSumOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$UserSumOrderByAggregateInputFromJson(json);

  final SortOrder? id;

  @override
  Map<String, dynamic> toJson() => _$UserSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class IntWithAggregatesFilter implements _i1.JsonSerializable {
  const IntWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory IntWithAggregatesFilter.fromJson(Map<String, dynamic> json) =>
      _$IntWithAggregatesFilterFromJson(json);

  final int? equals;

  @JsonKey(name: r'in')
  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final NestedIntWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntFilter? $count;

  @JsonKey(name: r'_avg')
  final NestedFloatFilter? $avg;

  @JsonKey(name: r'_sum')
  final NestedIntFilter? $sum;

  @JsonKey(name: r'_min')
  final NestedIntFilter? $min;

  @JsonKey(name: r'_max')
  final NestedIntFilter? $max;

  @override
  Map<String, dynamic> toJson() => _$IntWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class StringWithAggregatesFilter implements _i1.JsonSerializable {
  const StringWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.mode,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  factory StringWithAggregatesFilter.fromJson(Map<String, dynamic> json) =>
      _$StringWithAggregatesFilterFromJson(json);

  final String? equals;

  @JsonKey(name: r'in')
  final Iterable<String>? $in;

  final Iterable<String>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final QueryMode? mode;

  final NestedStringWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntFilter? $count;

  @JsonKey(name: r'_min')
  final NestedStringFilter? $min;

  @JsonKey(name: r'_max')
  final NestedStringFilter? $max;

  @override
  Map<String, dynamic> toJson() => _$StringWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class StringNullableWithAggregatesFilter implements _i1.JsonSerializable {
  const StringNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.mode,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  factory StringNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$StringNullableWithAggregatesFilterFromJson(json);

  final String? equals;

  @JsonKey(name: r'in')
  final Iterable<String>? $in;

  final Iterable<String>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final QueryMode? mode;

  final NestedStringNullableWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntNullableFilter? $count;

  @JsonKey(name: r'_min')
  final NestedStringNullableFilter? $min;

  @JsonKey(name: r'_max')
  final NestedStringNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() =>
      _$StringNullableWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class BigIntFilter implements _i1.JsonSerializable {
  const BigIntFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory BigIntFilter.fromJson(Map<String, dynamic> json) =>
      _$BigIntFilterFromJson(json);

  final BigInt? equals;

  @JsonKey(name: r'in')
  final Iterable<BigInt>? $in;

  final Iterable<BigInt>? notIn;

  final BigInt? lt;

  final BigInt? lte;

  final BigInt? gt;

  final BigInt? gte;

  final NestedBigIntFilter? not;

  @override
  Map<String, dynamic> toJson() => _$BigIntFilterToJson(this);
}

@_i1.jsonSerializable
class UserRelationFilter implements _i1.JsonSerializable {
  const UserRelationFilter({
    this.$is,
    this.isNot,
  });

  factory UserRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$UserRelationFilterFromJson(json);

  @JsonKey(name: r'is')
  final UserWhereInput? $is;

  final UserWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => _$UserRelationFilterToJson(this);
}

@_i1.jsonSerializable
class CategoryListRelationFilter implements _i1.JsonSerializable {
  const CategoryListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  factory CategoryListRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$CategoryListRelationFilterFromJson(json);

  final CategoryWhereInput? every;

  final CategoryWhereInput? some;

  final CategoryWhereInput? none;

  @override
  Map<String, dynamic> toJson() => _$CategoryListRelationFilterToJson(this);
}

@_i1.jsonSerializable
class TagListRelationFilter implements _i1.JsonSerializable {
  const TagListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  factory TagListRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$TagListRelationFilterFromJson(json);

  final TagWhereInput? every;

  final TagWhereInput? some;

  final TagWhereInput? none;

  @override
  Map<String, dynamic> toJson() => _$TagListRelationFilterToJson(this);
}

@_i1.jsonSerializable
class TaskListRelationFilter implements _i1.JsonSerializable {
  const TaskListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  factory TaskListRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$TaskListRelationFilterFromJson(json);

  final TaskWhereInput? every;

  final TaskWhereInput? some;

  final TaskWhereInput? none;

  @override
  Map<String, dynamic> toJson() => _$TaskListRelationFilterToJson(this);
}

@_i1.jsonSerializable
class ChannelListRelationFilter implements _i1.JsonSerializable {
  const ChannelListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  factory ChannelListRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$ChannelListRelationFilterFromJson(json);

  final ChannelWhereInput? every;

  final ChannelWhereInput? some;

  final ChannelWhereInput? none;

  @override
  Map<String, dynamic> toJson() => _$ChannelListRelationFilterToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentListRelationFilter implements _i1.JsonSerializable {
  const TaskAssignmentListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  factory TaskAssignmentListRelationFilter.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentListRelationFilterFromJson(json);

  final TaskAssignmentWhereInput? every;

  final TaskAssignmentWhereInput? some;

  final TaskAssignmentWhereInput? none;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentListRelationFilterToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionListRelationFilter implements _i1.JsonSerializable {
  const ChannelSubscriptionListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  factory ChannelSubscriptionListRelationFilter.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionListRelationFilterFromJson(json);

  final ChannelSubscriptionWhereInput? every;

  final ChannelSubscriptionWhereInput? some;

  final ChannelSubscriptionWhereInput? none;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionListRelationFilterToJson(this);
}

@_i1.jsonSerializable
class ScheduleListRelationFilter implements _i1.JsonSerializable {
  const ScheduleListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  factory ScheduleListRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$ScheduleListRelationFilterFromJson(json);

  final ScheduleWhereInput? every;

  final ScheduleWhereInput? some;

  final ScheduleWhereInput? none;

  @override
  Map<String, dynamic> toJson() => _$ScheduleListRelationFilterToJson(this);
}

@_i1.jsonSerializable
class RecordListRelationFilter implements _i1.JsonSerializable {
  const RecordListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  factory RecordListRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$RecordListRelationFilterFromJson(json);

  final RecordWhereInput? every;

  final RecordWhereInput? some;

  final RecordWhereInput? none;

  @override
  Map<String, dynamic> toJson() => _$RecordListRelationFilterToJson(this);
}

@_i1.jsonSerializable
class CategoryOrderByRelationAggregateInput implements _i1.JsonSerializable {
  const CategoryOrderByRelationAggregateInput({this.$count});

  factory CategoryOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: r'_count')
  final SortOrder? $count;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryOrderByRelationAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TagOrderByRelationAggregateInput implements _i1.JsonSerializable {
  const TagOrderByRelationAggregateInput({this.$count});

  factory TagOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$TagOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: r'_count')
  final SortOrder? $count;

  @override
  Map<String, dynamic> toJson() =>
      _$TagOrderByRelationAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TaskOrderByRelationAggregateInput implements _i1.JsonSerializable {
  const TaskOrderByRelationAggregateInput({this.$count});

  factory TaskOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: r'_count')
  final SortOrder? $count;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskOrderByRelationAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ChannelOrderByRelationAggregateInput implements _i1.JsonSerializable {
  const ChannelOrderByRelationAggregateInput({this.$count});

  factory ChannelOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: r'_count')
  final SortOrder? $count;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelOrderByRelationAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentOrderByRelationAggregateInput
    implements _i1.JsonSerializable {
  const TaskAssignmentOrderByRelationAggregateInput({this.$count});

  factory TaskAssignmentOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: r'_count')
  final SortOrder? $count;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentOrderByRelationAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionOrderByRelationAggregateInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionOrderByRelationAggregateInput({this.$count});

  factory ChannelSubscriptionOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: r'_count')
  final SortOrder? $count;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionOrderByRelationAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleOrderByRelationAggregateInput implements _i1.JsonSerializable {
  const ScheduleOrderByRelationAggregateInput({this.$count});

  factory ScheduleOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: r'_count')
  final SortOrder? $count;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleOrderByRelationAggregateInputToJson(this);
}

@_i1.jsonSerializable
class RecordOrderByRelationAggregateInput implements _i1.JsonSerializable {
  const RecordOrderByRelationAggregateInput({this.$count});

  factory RecordOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: r'_count')
  final SortOrder? $count;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordOrderByRelationAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUserIdNameCompoundUniqueInput implements _i1.JsonSerializable {
  const ProfileUserIdNameCompoundUniqueInput({
    required this.userId,
    required this.name,
  });

  factory ProfileUserIdNameCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUserIdNameCompoundUniqueInputFromJson(json);

  final int userId;

  final String name;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUserIdNameCompoundUniqueInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCountOrderByAggregateInput implements _i1.JsonSerializable {
  const ProfileCountOrderByAggregateInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ProfileCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCountOrderByAggregateInputFromJson(json);

  final SortOrder? name;

  final SortOrder? color;

  final SortOrder? icon;

  final SortOrder? userId;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ProfileAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const ProfileAvgOrderByAggregateInput({
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ProfileAvgOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$ProfileAvgOrderByAggregateInputFromJson(json);

  final SortOrder? userId;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ProfileMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const ProfileMaxOrderByAggregateInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ProfileMaxOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$ProfileMaxOrderByAggregateInputFromJson(json);

  final SortOrder? name;

  final SortOrder? color;

  final SortOrder? icon;

  final SortOrder? userId;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ProfileMinOrderByAggregateInput implements _i1.JsonSerializable {
  const ProfileMinOrderByAggregateInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ProfileMinOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$ProfileMinOrderByAggregateInputFromJson(json);

  final SortOrder? name;

  final SortOrder? color;

  final SortOrder? icon;

  final SortOrder? userId;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ProfileSumOrderByAggregateInput implements _i1.JsonSerializable {
  const ProfileSumOrderByAggregateInput({
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ProfileSumOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$ProfileSumOrderByAggregateInputFromJson(json);

  final SortOrder? userId;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class BigIntWithAggregatesFilter implements _i1.JsonSerializable {
  const BigIntWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory BigIntWithAggregatesFilter.fromJson(Map<String, dynamic> json) =>
      _$BigIntWithAggregatesFilterFromJson(json);

  final BigInt? equals;

  @JsonKey(name: r'in')
  final Iterable<BigInt>? $in;

  final Iterable<BigInt>? notIn;

  final BigInt? lt;

  final BigInt? lte;

  final BigInt? gt;

  final BigInt? gte;

  final NestedBigIntWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntFilter? $count;

  @JsonKey(name: r'_avg')
  final NestedFloatFilter? $avg;

  @JsonKey(name: r'_sum')
  final NestedBigIntFilter? $sum;

  @JsonKey(name: r'_min')
  final NestedBigIntFilter? $min;

  @JsonKey(name: r'_max')
  final NestedBigIntFilter? $max;

  @override
  Map<String, dynamic> toJson() => _$BigIntWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class BoolFilter implements _i1.JsonSerializable {
  const BoolFilter({
    this.equals,
    this.not,
  });

  factory BoolFilter.fromJson(Map<String, dynamic> json) =>
      _$BoolFilterFromJson(json);

  final bool? equals;

  final NestedBoolFilter? not;

  @override
  Map<String, dynamic> toJson() => _$BoolFilterToJson(this);
}

@_i1.jsonSerializable
class ProfileRelationFilter implements _i1.JsonSerializable {
  const ProfileRelationFilter({
    this.$is,
    this.isNot,
  });

  factory ProfileRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$ProfileRelationFilterFromJson(json);

  @JsonKey(name: r'is')
  final ProfileWhereInput? $is;

  final ProfileWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => _$ProfileRelationFilterToJson(this);
}

@_i1.jsonSerializable
class TaskRelationFilter implements _i1.JsonSerializable {
  const TaskRelationFilter({
    this.$is,
    this.isNot,
  });

  factory TaskRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$TaskRelationFilterFromJson(json);

  @JsonKey(name: r'is')
  final TaskWhereInput? $is;

  final TaskWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => _$TaskRelationFilterToJson(this);
}

@_i1.jsonSerializable
class ChannelRelationFilter implements _i1.JsonSerializable {
  const ChannelRelationFilter({
    this.$is,
    this.isNot,
  });

  factory ChannelRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$ChannelRelationFilterFromJson(json);

  @JsonKey(name: r'is')
  final ChannelWhereInput? $is;

  final ChannelWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => _$ChannelRelationFilterToJson(this);
}

@_i1.jsonSerializable
class TaskAssetListRelationFilter implements _i1.JsonSerializable {
  const TaskAssetListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  factory TaskAssetListRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$TaskAssetListRelationFilterFromJson(json);

  final TaskAssetWhereInput? every;

  final TaskAssetWhereInput? some;

  final TaskAssetWhereInput? none;

  @override
  Map<String, dynamic> toJson() => _$TaskAssetListRelationFilterToJson(this);
}

@_i1.jsonSerializable
class SessionListRelationFilter implements _i1.JsonSerializable {
  const SessionListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  factory SessionListRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$SessionListRelationFilterFromJson(json);

  final SessionWhereInput? every;

  final SessionWhereInput? some;

  final SessionWhereInput? none;

  @override
  Map<String, dynamic> toJson() => _$SessionListRelationFilterToJson(this);
}

@_i1.jsonSerializable
class TaskAssetOrderByRelationAggregateInput implements _i1.JsonSerializable {
  const TaskAssetOrderByRelationAggregateInput({this.$count});

  factory TaskAssetOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssetOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: r'_count')
  final SortOrder? $count;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetOrderByRelationAggregateInputToJson(this);
}

@_i1.jsonSerializable
class SessionOrderByRelationAggregateInput implements _i1.JsonSerializable {
  const SessionOrderByRelationAggregateInput({this.$count});

  factory SessionOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: r'_count')
  final SortOrder? $count;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionOrderByRelationAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TaskCountOrderByAggregateInput implements _i1.JsonSerializable {
  const TaskCountOrderByAggregateInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.userId,
    this.profile,
    this.parentUuid,
    this.channelUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskCountOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$TaskCountOrderByAggregateInputFromJson(json);

  final SortOrder? uuid;

  final SortOrder? title;

  final SortOrder? desc;

  final SortOrder? content;

  final SortOrder? location;

  final SortOrder? requireLocation;

  final SortOrder? requireTime;

  final SortOrder? requireAttachment;

  final SortOrder? userId;

  final SortOrder? profile;

  final SortOrder? parentUuid;

  final SortOrder? channelUuid;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TaskCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const TaskAvgOrderByAggregateInput({
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAvgOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$TaskAvgOrderByAggregateInputFromJson(json);

  final SortOrder? userId;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TaskAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TaskMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const TaskMaxOrderByAggregateInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.userId,
    this.profile,
    this.parentUuid,
    this.channelUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskMaxOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$TaskMaxOrderByAggregateInputFromJson(json);

  final SortOrder? uuid;

  final SortOrder? title;

  final SortOrder? desc;

  final SortOrder? content;

  final SortOrder? location;

  final SortOrder? requireLocation;

  final SortOrder? requireTime;

  final SortOrder? requireAttachment;

  final SortOrder? userId;

  final SortOrder? profile;

  final SortOrder? parentUuid;

  final SortOrder? channelUuid;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TaskMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TaskMinOrderByAggregateInput implements _i1.JsonSerializable {
  const TaskMinOrderByAggregateInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.userId,
    this.profile,
    this.parentUuid,
    this.channelUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskMinOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$TaskMinOrderByAggregateInputFromJson(json);

  final SortOrder? uuid;

  final SortOrder? title;

  final SortOrder? desc;

  final SortOrder? content;

  final SortOrder? location;

  final SortOrder? requireLocation;

  final SortOrder? requireTime;

  final SortOrder? requireAttachment;

  final SortOrder? userId;

  final SortOrder? profile;

  final SortOrder? parentUuid;

  final SortOrder? channelUuid;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TaskMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TaskSumOrderByAggregateInput implements _i1.JsonSerializable {
  const TaskSumOrderByAggregateInput({
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskSumOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$TaskSumOrderByAggregateInputFromJson(json);

  final SortOrder? userId;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TaskSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class BoolWithAggregatesFilter implements _i1.JsonSerializable {
  const BoolWithAggregatesFilter({
    this.equals,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  factory BoolWithAggregatesFilter.fromJson(Map<String, dynamic> json) =>
      _$BoolWithAggregatesFilterFromJson(json);

  final bool? equals;

  final NestedBoolWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntFilter? $count;

  @JsonKey(name: r'_min')
  final NestedBoolFilter? $min;

  @JsonKey(name: r'_max')
  final NestedBoolFilter? $max;

  @override
  Map<String, dynamic> toJson() => _$BoolWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class TaskAssetTaskUuidHashCompoundUniqueInput implements _i1.JsonSerializable {
  const TaskAssetTaskUuidHashCompoundUniqueInput({
    required this.taskUuid,
    required this.hash,
  });

  factory TaskAssetTaskUuidHashCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssetTaskUuidHashCompoundUniqueInputFromJson(json);

  final String taskUuid;

  final String hash;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetTaskUuidHashCompoundUniqueInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetCountOrderByAggregateInput implements _i1.JsonSerializable {
  const TaskAssetCountOrderByAggregateInput({
    this.name,
    this.hash,
    this.assetRef,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssetCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssetCountOrderByAggregateInputFromJson(json);

  final SortOrder? name;

  final SortOrder? hash;

  final SortOrder? assetRef;

  final SortOrder? taskUuid;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const TaskAssetAvgOrderByAggregateInput({
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssetAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssetAvgOrderByAggregateInputFromJson(json);

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const TaskAssetMaxOrderByAggregateInput({
    this.name,
    this.hash,
    this.assetRef,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssetMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssetMaxOrderByAggregateInputFromJson(json);

  final SortOrder? name;

  final SortOrder? hash;

  final SortOrder? assetRef;

  final SortOrder? taskUuid;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetMinOrderByAggregateInput implements _i1.JsonSerializable {
  const TaskAssetMinOrderByAggregateInput({
    this.name,
    this.hash,
    this.assetRef,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssetMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssetMinOrderByAggregateInputFromJson(json);

  final SortOrder? name;

  final SortOrder? hash;

  final SortOrder? assetRef;

  final SortOrder? taskUuid;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetSumOrderByAggregateInput implements _i1.JsonSerializable {
  const TaskAssetSumOrderByAggregateInput({
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssetSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssetSumOrderByAggregateInputFromJson(json);

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ChannelCountOrderByAggregateInput implements _i1.JsonSerializable {
  const ChannelCountOrderByAggregateInput({
    this.uuid,
    this.name,
    this.desc,
    this.color,
    this.imgRef,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelCountOrderByAggregateInputFromJson(json);

  final SortOrder? uuid;

  final SortOrder? name;

  final SortOrder? desc;

  final SortOrder? color;

  final SortOrder? imgRef;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ChannelAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const ChannelAvgOrderByAggregateInput({
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelAvgOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$ChannelAvgOrderByAggregateInputFromJson(json);

  final SortOrder? userId;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ChannelMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const ChannelMaxOrderByAggregateInput({
    this.uuid,
    this.name,
    this.desc,
    this.color,
    this.imgRef,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelMaxOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$ChannelMaxOrderByAggregateInputFromJson(json);

  final SortOrder? uuid;

  final SortOrder? name;

  final SortOrder? desc;

  final SortOrder? color;

  final SortOrder? imgRef;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ChannelMinOrderByAggregateInput implements _i1.JsonSerializable {
  const ChannelMinOrderByAggregateInput({
    this.uuid,
    this.name,
    this.desc,
    this.color,
    this.imgRef,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelMinOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$ChannelMinOrderByAggregateInputFromJson(json);

  final SortOrder? uuid;

  final SortOrder? name;

  final SortOrder? desc;

  final SortOrder? color;

  final SortOrder? imgRef;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSumOrderByAggregateInput implements _i1.JsonSerializable {
  const ChannelSumOrderByAggregateInput({
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelSumOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$ChannelSumOrderByAggregateInputFromJson(json);

  final SortOrder? userId;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class SessionCountOrderByAggregateInput implements _i1.JsonSerializable {
  const SessionCountOrderByAggregateInput({
    this.uuid,
    this.start,
    this.end,
    this.cycle,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory SessionCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionCountOrderByAggregateInputFromJson(json);

  final SortOrder? uuid;

  final SortOrder? start;

  final SortOrder? end;

  final SortOrder? cycle;

  final SortOrder? taskUuid;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class SessionAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const SessionAvgOrderByAggregateInput({
    this.start,
    this.end,
    this.cycle,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory SessionAvgOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$SessionAvgOrderByAggregateInputFromJson(json);

  final SortOrder? start;

  final SortOrder? end;

  final SortOrder? cycle;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class SessionMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const SessionMaxOrderByAggregateInput({
    this.uuid,
    this.start,
    this.end,
    this.cycle,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory SessionMaxOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$SessionMaxOrderByAggregateInputFromJson(json);

  final SortOrder? uuid;

  final SortOrder? start;

  final SortOrder? end;

  final SortOrder? cycle;

  final SortOrder? taskUuid;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class SessionMinOrderByAggregateInput implements _i1.JsonSerializable {
  const SessionMinOrderByAggregateInput({
    this.uuid,
    this.start,
    this.end,
    this.cycle,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory SessionMinOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$SessionMinOrderByAggregateInputFromJson(json);

  final SortOrder? uuid;

  final SortOrder? start;

  final SortOrder? end;

  final SortOrder? cycle;

  final SortOrder? taskUuid;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class SessionSumOrderByAggregateInput implements _i1.JsonSerializable {
  const SessionSumOrderByAggregateInput({
    this.start,
    this.end,
    this.cycle,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory SessionSumOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$SessionSumOrderByAggregateInputFromJson(json);

  final SortOrder? start;

  final SortOrder? end;

  final SortOrder? cycle;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class SessionRelationFilter implements _i1.JsonSerializable {
  const SessionRelationFilter({
    this.$is,
    this.isNot,
  });

  factory SessionRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$SessionRelationFilterFromJson(json);

  @JsonKey(name: r'is')
  final SessionWhereInput? $is;

  final SessionWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => _$SessionRelationFilterToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentRelationFilter implements _i1.JsonSerializable {
  const RecordAttachmentRelationFilter({
    this.$is,
    this.isNot,
  });

  factory RecordAttachmentRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$RecordAttachmentRelationFilterFromJson(json);

  @JsonKey(name: r'is')
  final RecordAttachmentWhereInput? $is;

  final RecordAttachmentWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => _$RecordAttachmentRelationFilterToJson(this);
}

@_i1.jsonSerializable
class RecordSessionUuidTaskUuidUserIdProfileNameRecordIndexCompoundUniqueInput
    implements _i1.JsonSerializable {
  const RecordSessionUuidTaskUuidUserIdProfileNameRecordIndexCompoundUniqueInput({
    required this.sessionUuid,
    required this.taskUuid,
    required this.userId,
    required this.profileName,
    required this.recordIndex,
  });

  factory RecordSessionUuidTaskUuidUserIdProfileNameRecordIndexCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordSessionUuidTaskUuidUserIdProfileNameRecordIndexCompoundUniqueInputFromJson(
          json);

  final String sessionUuid;

  final String taskUuid;

  final int userId;

  final String profileName;

  final int recordIndex;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordSessionUuidTaskUuidUserIdProfileNameRecordIndexCompoundUniqueInputToJson(
          this);
}

@_i1.jsonSerializable
class RecordCountOrderByAggregateInput implements _i1.JsonSerializable {
  const RecordCountOrderByAggregateInput({
    this.time,
    this.recordIndex,
    this.sessionUuid,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory RecordCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordCountOrderByAggregateInputFromJson(json);

  final SortOrder? time;

  final SortOrder? recordIndex;

  final SortOrder? sessionUuid;

  final SortOrder? taskUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class RecordAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const RecordAvgOrderByAggregateInput({
    this.time,
    this.recordIndex,
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory RecordAvgOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$RecordAvgOrderByAggregateInputFromJson(json);

  final SortOrder? time;

  final SortOrder? recordIndex;

  final SortOrder? userId;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$RecordAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class RecordMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const RecordMaxOrderByAggregateInput({
    this.time,
    this.recordIndex,
    this.sessionUuid,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory RecordMaxOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$RecordMaxOrderByAggregateInputFromJson(json);

  final SortOrder? time;

  final SortOrder? recordIndex;

  final SortOrder? sessionUuid;

  final SortOrder? taskUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$RecordMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class RecordMinOrderByAggregateInput implements _i1.JsonSerializable {
  const RecordMinOrderByAggregateInput({
    this.time,
    this.recordIndex,
    this.sessionUuid,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory RecordMinOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$RecordMinOrderByAggregateInputFromJson(json);

  final SortOrder? time;

  final SortOrder? recordIndex;

  final SortOrder? sessionUuid;

  final SortOrder? taskUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$RecordMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class RecordSumOrderByAggregateInput implements _i1.JsonSerializable {
  const RecordSumOrderByAggregateInput({
    this.time,
    this.recordIndex,
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory RecordSumOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$RecordSumOrderByAggregateInputFromJson(json);

  final SortOrder? time;

  final SortOrder? recordIndex;

  final SortOrder? userId;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$RecordSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class RecordRelationFilter implements _i1.JsonSerializable {
  const RecordRelationFilter({
    this.$is,
    this.isNot,
  });

  factory RecordRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$RecordRelationFilterFromJson(json);

  @JsonKey(name: r'is')
  final RecordWhereInput? $is;

  final RecordWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => _$RecordRelationFilterToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentSessionUuidTaskUuidUserIdProfileNameRecordIndexCompoundUniqueInput
    implements _i1.JsonSerializable {
  const RecordAttachmentSessionUuidTaskUuidUserIdProfileNameRecordIndexCompoundUniqueInput({
    required this.sessionUuid,
    required this.taskUuid,
    required this.userId,
    required this.profileName,
    required this.recordIndex,
  });

  factory RecordAttachmentSessionUuidTaskUuidUserIdProfileNameRecordIndexCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentSessionUuidTaskUuidUserIdProfileNameRecordIndexCompoundUniqueInputFromJson(
          json);

  final String sessionUuid;

  final String taskUuid;

  final int userId;

  final String profileName;

  final int recordIndex;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentSessionUuidTaskUuidUserIdProfileNameRecordIndexCompoundUniqueInputToJson(
          this);
}

@_i1.jsonSerializable
class RecordAttachmentCountOrderByAggregateInput
    implements _i1.JsonSerializable {
  const RecordAttachmentCountOrderByAggregateInput({
    this.hash,
    this.name,
    this.assetRef,
    this.sessionUuid,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.recordIndex,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory RecordAttachmentCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentCountOrderByAggregateInputFromJson(json);

  final SortOrder? hash;

  final SortOrder? name;

  final SortOrder? assetRef;

  final SortOrder? sessionUuid;

  final SortOrder? taskUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? recordIndex;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const RecordAttachmentAvgOrderByAggregateInput({
    this.userId,
    this.recordIndex,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory RecordAttachmentAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentAvgOrderByAggregateInputFromJson(json);

  final SortOrder? userId;

  final SortOrder? recordIndex;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const RecordAttachmentMaxOrderByAggregateInput({
    this.hash,
    this.name,
    this.assetRef,
    this.sessionUuid,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.recordIndex,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory RecordAttachmentMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentMaxOrderByAggregateInputFromJson(json);

  final SortOrder? hash;

  final SortOrder? name;

  final SortOrder? assetRef;

  final SortOrder? sessionUuid;

  final SortOrder? taskUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? recordIndex;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentMinOrderByAggregateInput implements _i1.JsonSerializable {
  const RecordAttachmentMinOrderByAggregateInput({
    this.hash,
    this.name,
    this.assetRef,
    this.sessionUuid,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.recordIndex,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory RecordAttachmentMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentMinOrderByAggregateInputFromJson(json);

  final SortOrder? hash;

  final SortOrder? name;

  final SortOrder? assetRef;

  final SortOrder? sessionUuid;

  final SortOrder? taskUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? recordIndex;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentSumOrderByAggregateInput implements _i1.JsonSerializable {
  const RecordAttachmentSumOrderByAggregateInput({
    this.userId,
    this.recordIndex,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory RecordAttachmentSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentSumOrderByAggregateInputFromJson(json);

  final SortOrder? userId;

  final SortOrder? recordIndex;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CategoryUserIdProfileNameNameCompoundUniqueInput
    implements _i1.JsonSerializable {
  const CategoryUserIdProfileNameNameCompoundUniqueInput({
    required this.userId,
    required this.profileName,
    required this.name,
  });

  factory CategoryUserIdProfileNameNameCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryUserIdProfileNameNameCompoundUniqueInputFromJson(json);

  final int userId;

  final String profileName;

  final String name;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryUserIdProfileNameNameCompoundUniqueInputToJson(this);
}

@_i1.jsonSerializable
class CategoryCountOrderByAggregateInput implements _i1.JsonSerializable {
  const CategoryCountOrderByAggregateInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory CategoryCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryCountOrderByAggregateInputFromJson(json);

  final SortOrder? name;

  final SortOrder? color;

  final SortOrder? icon;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CategoryAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const CategoryAvgOrderByAggregateInput({
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory CategoryAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryAvgOrderByAggregateInputFromJson(json);

  final SortOrder? userId;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CategoryMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const CategoryMaxOrderByAggregateInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory CategoryMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryMaxOrderByAggregateInputFromJson(json);

  final SortOrder? name;

  final SortOrder? color;

  final SortOrder? icon;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CategoryMinOrderByAggregateInput implements _i1.JsonSerializable {
  const CategoryMinOrderByAggregateInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory CategoryMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryMinOrderByAggregateInputFromJson(json);

  final SortOrder? name;

  final SortOrder? color;

  final SortOrder? icon;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CategorySumOrderByAggregateInput implements _i1.JsonSerializable {
  const CategorySumOrderByAggregateInput({
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory CategorySumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategorySumOrderByAggregateInputFromJson(json);

  final SortOrder? userId;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$CategorySumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsListRelationFilter implements _i1.JsonSerializable {
  const TaskAssignmentTagsListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  factory TaskAssignmentTagsListRelationFilter.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsListRelationFilterFromJson(json);

  final TaskAssignmentTagsWhereInput? every;

  final TaskAssignmentTagsWhereInput? some;

  final TaskAssignmentTagsWhereInput? none;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsListRelationFilterToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsOrderByRelationAggregateInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsOrderByRelationAggregateInput({this.$count});

  factory TaskAssignmentTagsOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: r'_count')
  final SortOrder? $count;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsOrderByRelationAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TagUserIdProfileNameNameCompoundUniqueInput
    implements _i1.JsonSerializable {
  const TagUserIdProfileNameNameCompoundUniqueInput({
    required this.userId,
    required this.profileName,
    required this.name,
  });

  factory TagUserIdProfileNameNameCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$TagUserIdProfileNameNameCompoundUniqueInputFromJson(json);

  final int userId;

  final String profileName;

  final String name;

  @override
  Map<String, dynamic> toJson() =>
      _$TagUserIdProfileNameNameCompoundUniqueInputToJson(this);
}

@_i1.jsonSerializable
class TagCountOrderByAggregateInput implements _i1.JsonSerializable {
  const TagCountOrderByAggregateInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TagCountOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$TagCountOrderByAggregateInputFromJson(json);

  final SortOrder? name;

  final SortOrder? color;

  final SortOrder? icon;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TagCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TagAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const TagAvgOrderByAggregateInput({
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TagAvgOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$TagAvgOrderByAggregateInputFromJson(json);

  final SortOrder? userId;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TagAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TagMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const TagMaxOrderByAggregateInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TagMaxOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$TagMaxOrderByAggregateInputFromJson(json);

  final SortOrder? name;

  final SortOrder? color;

  final SortOrder? icon;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TagMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TagMinOrderByAggregateInput implements _i1.JsonSerializable {
  const TagMinOrderByAggregateInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TagMinOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$TagMinOrderByAggregateInputFromJson(json);

  final SortOrder? name;

  final SortOrder? color;

  final SortOrder? icon;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TagMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TagSumOrderByAggregateInput implements _i1.JsonSerializable {
  const TagSumOrderByAggregateInput({
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TagSumOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$TagSumOrderByAggregateInputFromJson(json);

  final SortOrder? userId;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TagSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class EnumTaskAssignmentStatusFilter implements _i1.JsonSerializable {
  const EnumTaskAssignmentStatusFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  factory EnumTaskAssignmentStatusFilter.fromJson(Map<String, dynamic> json) =>
      _$EnumTaskAssignmentStatusFilterFromJson(json);

  final TaskAssignmentStatus? equals;

  @JsonKey(name: r'in')
  final Iterable<TaskAssignmentStatus>? $in;

  final Iterable<TaskAssignmentStatus>? notIn;

  final TaskAssignmentStatus? not;

  @override
  Map<String, dynamic> toJson() => _$EnumTaskAssignmentStatusFilterToJson(this);
}

@_i1.jsonSerializable
class EnumTaskPriorityFilter implements _i1.JsonSerializable {
  const EnumTaskPriorityFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  factory EnumTaskPriorityFilter.fromJson(Map<String, dynamic> json) =>
      _$EnumTaskPriorityFilterFromJson(json);

  final TaskPriority? equals;

  @JsonKey(name: r'in')
  final Iterable<TaskPriority>? $in;

  final Iterable<TaskPriority>? notIn;

  final TaskPriority? not;

  @override
  Map<String, dynamic> toJson() => _$EnumTaskPriorityFilterToJson(this);
}

@_i1.jsonSerializable
class CategoryRelationFilter implements _i1.JsonSerializable {
  const CategoryRelationFilter({
    this.$is,
    this.isNot,
  });

  factory CategoryRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$CategoryRelationFilterFromJson(json);

  @JsonKey(name: r'is')
  final CategoryWhereInput? $is;

  final CategoryWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => _$CategoryRelationFilterToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTaskUuidUserIdProfileNameCompoundUniqueInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTaskUuidUserIdProfileNameCompoundUniqueInput({
    required this.taskUuid,
    required this.userId,
    required this.profileName,
  });

  factory TaskAssignmentTaskUuidUserIdProfileNameCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTaskUuidUserIdProfileNameCompoundUniqueInputFromJson(
          json);

  final String taskUuid;

  final int userId;

  final String profileName;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTaskUuidUserIdProfileNameCompoundUniqueInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentCountOrderByAggregateInput implements _i1.JsonSerializable {
  const TaskAssignmentCountOrderByAggregateInput({
    this.status,
    this.priority,
    this.starred,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.categoryName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssignmentCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentCountOrderByAggregateInputFromJson(json);

  final SortOrder? status;

  final SortOrder? priority;

  final SortOrder? starred;

  final SortOrder? taskUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? categoryName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const TaskAssignmentAvgOrderByAggregateInput({
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssignmentAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentAvgOrderByAggregateInputFromJson(json);

  final SortOrder? userId;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const TaskAssignmentMaxOrderByAggregateInput({
    this.status,
    this.priority,
    this.starred,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.categoryName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssignmentMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentMaxOrderByAggregateInputFromJson(json);

  final SortOrder? status;

  final SortOrder? priority;

  final SortOrder? starred;

  final SortOrder? taskUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? categoryName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentMinOrderByAggregateInput implements _i1.JsonSerializable {
  const TaskAssignmentMinOrderByAggregateInput({
    this.status,
    this.priority,
    this.starred,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.categoryName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssignmentMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentMinOrderByAggregateInputFromJson(json);

  final SortOrder? status;

  final SortOrder? priority;

  final SortOrder? starred;

  final SortOrder? taskUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? categoryName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentSumOrderByAggregateInput implements _i1.JsonSerializable {
  const TaskAssignmentSumOrderByAggregateInput({
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssignmentSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentSumOrderByAggregateInputFromJson(json);

  final SortOrder? userId;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class EnumTaskAssignmentStatusWithAggregatesFilter
    implements _i1.JsonSerializable {
  const EnumTaskAssignmentStatusWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  factory EnumTaskAssignmentStatusWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$EnumTaskAssignmentStatusWithAggregatesFilterFromJson(json);

  final TaskAssignmentStatus? equals;

  @JsonKey(name: r'in')
  final Iterable<TaskAssignmentStatus>? $in;

  final Iterable<TaskAssignmentStatus>? notIn;

  final TaskAssignmentStatus? not;

  @JsonKey(name: r'_count')
  final NestedIntFilter? $count;

  @JsonKey(name: r'_min')
  final NestedEnumTaskAssignmentStatusFilter? $min;

  @JsonKey(name: r'_max')
  final NestedEnumTaskAssignmentStatusFilter? $max;

  @override
  Map<String, dynamic> toJson() =>
      _$EnumTaskAssignmentStatusWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class EnumTaskPriorityWithAggregatesFilter implements _i1.JsonSerializable {
  const EnumTaskPriorityWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  factory EnumTaskPriorityWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$EnumTaskPriorityWithAggregatesFilterFromJson(json);

  final TaskPriority? equals;

  @JsonKey(name: r'in')
  final Iterable<TaskPriority>? $in;

  final Iterable<TaskPriority>? notIn;

  final TaskPriority? not;

  @JsonKey(name: r'_count')
  final NestedIntFilter? $count;

  @JsonKey(name: r'_min')
  final NestedEnumTaskPriorityFilter? $min;

  @JsonKey(name: r'_max')
  final NestedEnumTaskPriorityFilter? $max;

  @override
  Map<String, dynamic> toJson() =>
      _$EnumTaskPriorityWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentRelationFilter implements _i1.JsonSerializable {
  const TaskAssignmentRelationFilter({
    this.$is,
    this.isNot,
  });

  factory TaskAssignmentRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$TaskAssignmentRelationFilterFromJson(json);

  @JsonKey(name: r'is')
  final TaskAssignmentWhereInput? $is;

  final TaskAssignmentWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => _$TaskAssignmentRelationFilterToJson(this);
}

@_i1.jsonSerializable
class TagRelationFilter implements _i1.JsonSerializable {
  const TagRelationFilter({
    this.$is,
    this.isNot,
  });

  factory TagRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$TagRelationFilterFromJson(json);

  @JsonKey(name: r'is')
  final TagWhereInput? $is;

  final TagWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => _$TagRelationFilterToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsTaskUuidUserIdProfileNameTagNameCompoundUniqueInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsTaskUuidUserIdProfileNameTagNameCompoundUniqueInput({
    required this.taskUuid,
    required this.userId,
    required this.profileName,
    required this.tagName,
  });

  factory TaskAssignmentTagsTaskUuidUserIdProfileNameTagNameCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsTaskUuidUserIdProfileNameTagNameCompoundUniqueInputFromJson(
          json);

  final String taskUuid;

  final int userId;

  final String profileName;

  final String tagName;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsTaskUuidUserIdProfileNameTagNameCompoundUniqueInputToJson(
          this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsCountOrderByAggregateInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsCountOrderByAggregateInput({
    this.taskUuid,
    this.userId,
    this.profileName,
    this.tagName,
  });

  factory TaskAssignmentTagsCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsCountOrderByAggregateInputFromJson(json);

  final SortOrder? taskUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? tagName;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsAvgOrderByAggregateInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsAvgOrderByAggregateInput({this.userId});

  factory TaskAssignmentTagsAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsAvgOrderByAggregateInputFromJson(json);

  final SortOrder? userId;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsMaxOrderByAggregateInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsMaxOrderByAggregateInput({
    this.taskUuid,
    this.userId,
    this.profileName,
    this.tagName,
  });

  factory TaskAssignmentTagsMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsMaxOrderByAggregateInputFromJson(json);

  final SortOrder? taskUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? tagName;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsMinOrderByAggregateInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsMinOrderByAggregateInput({
    this.taskUuid,
    this.userId,
    this.profileName,
    this.tagName,
  });

  factory TaskAssignmentTagsMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsMinOrderByAggregateInputFromJson(json);

  final SortOrder? taskUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? tagName;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsSumOrderByAggregateInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsSumOrderByAggregateInput({this.userId});

  factory TaskAssignmentTagsSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsSumOrderByAggregateInputFromJson(json);

  final SortOrder? userId;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionChannelUuidUserIdProfileNameCompoundUniqueInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionChannelUuidUserIdProfileNameCompoundUniqueInput({
    required this.channelUuid,
    required this.userId,
    required this.profileName,
  });

  factory ChannelSubscriptionChannelUuidUserIdProfileNameCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionChannelUuidUserIdProfileNameCompoundUniqueInputFromJson(
          json);

  final String channelUuid;

  final int userId;

  final String profileName;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionChannelUuidUserIdProfileNameCompoundUniqueInputToJson(
          this);
}

@_i1.jsonSerializable
class ChannelSubscriptionCountOrderByAggregateInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionCountOrderByAggregateInput({
    this.shareRecord,
    this.channelUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelSubscriptionCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionCountOrderByAggregateInputFromJson(json);

  final SortOrder? shareRecord;

  final SortOrder? channelUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionAvgOrderByAggregateInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionAvgOrderByAggregateInput({
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelSubscriptionAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionAvgOrderByAggregateInputFromJson(json);

  final SortOrder? userId;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionMaxOrderByAggregateInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionMaxOrderByAggregateInput({
    this.shareRecord,
    this.channelUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelSubscriptionMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionMaxOrderByAggregateInputFromJson(json);

  final SortOrder? shareRecord;

  final SortOrder? channelUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionMinOrderByAggregateInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionMinOrderByAggregateInput({
    this.shareRecord,
    this.channelUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelSubscriptionMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionMinOrderByAggregateInputFromJson(json);

  final SortOrder? shareRecord;

  final SortOrder? channelUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionSumOrderByAggregateInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionSumOrderByAggregateInput({
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelSubscriptionSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionSumOrderByAggregateInputFromJson(json);

  final SortOrder? userId;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleSessionUuidUserIdProfileNameCompoundUniqueInput
    implements _i1.JsonSerializable {
  const ScheduleSessionUuidUserIdProfileNameCompoundUniqueInput({
    required this.sessionUuid,
    required this.userId,
    required this.profileName,
  });

  factory ScheduleSessionUuidUserIdProfileNameCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleSessionUuidUserIdProfileNameCompoundUniqueInputFromJson(json);

  final String sessionUuid;

  final int userId;

  final String profileName;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleSessionUuidUserIdProfileNameCompoundUniqueInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleCountOrderByAggregateInput implements _i1.JsonSerializable {
  const ScheduleCountOrderByAggregateInput({
    this.relStart,
    this.relEnd,
    this.sessionUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ScheduleCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleCountOrderByAggregateInputFromJson(json);

  final SortOrder? relStart;

  final SortOrder? relEnd;

  final SortOrder? sessionUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const ScheduleAvgOrderByAggregateInput({
    this.relStart,
    this.relEnd,
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ScheduleAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleAvgOrderByAggregateInputFromJson(json);

  final SortOrder? relStart;

  final SortOrder? relEnd;

  final SortOrder? userId;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const ScheduleMaxOrderByAggregateInput({
    this.relStart,
    this.relEnd,
    this.sessionUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ScheduleMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleMaxOrderByAggregateInputFromJson(json);

  final SortOrder? relStart;

  final SortOrder? relEnd;

  final SortOrder? sessionUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleMinOrderByAggregateInput implements _i1.JsonSerializable {
  const ScheduleMinOrderByAggregateInput({
    this.relStart,
    this.relEnd,
    this.sessionUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ScheduleMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleMinOrderByAggregateInputFromJson(json);

  final SortOrder? relStart;

  final SortOrder? relEnd;

  final SortOrder? sessionUuid;

  final SortOrder? userId;

  final SortOrder? profileName;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleSumOrderByAggregateInput implements _i1.JsonSerializable {
  const ScheduleSumOrderByAggregateInput({
    this.relStart,
    this.relEnd,
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ScheduleSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleSumOrderByAggregateInputFromJson(json);

  final SortOrder? relStart;

  final SortOrder? relEnd;

  final SortOrder? userId;

  final SortOrder? updateAt;

  final SortOrder? syncAt;

  final SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class IntNullableFilter implements _i1.JsonSerializable {
  const IntNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory IntNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$IntNullableFilterFromJson(json);

  final int? equals;

  @JsonKey(name: r'in')
  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final NestedIntNullableFilter? not;

  @override
  Map<String, dynamic> toJson() => _$IntNullableFilterToJson(this);
}

@_i1.jsonSerializable
class FileRefCountOrderByAggregateInput implements _i1.JsonSerializable {
  const FileRefCountOrderByAggregateInput({
    this.hash,
    this.count,
  });

  factory FileRefCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$FileRefCountOrderByAggregateInputFromJson(json);

  final SortOrder? hash;

  final SortOrder? count;

  @override
  Map<String, dynamic> toJson() =>
      _$FileRefCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class FileRefAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const FileRefAvgOrderByAggregateInput({this.count});

  factory FileRefAvgOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$FileRefAvgOrderByAggregateInputFromJson(json);

  final SortOrder? count;

  @override
  Map<String, dynamic> toJson() =>
      _$FileRefAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class FileRefMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const FileRefMaxOrderByAggregateInput({
    this.hash,
    this.count,
  });

  factory FileRefMaxOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$FileRefMaxOrderByAggregateInputFromJson(json);

  final SortOrder? hash;

  final SortOrder? count;

  @override
  Map<String, dynamic> toJson() =>
      _$FileRefMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class FileRefMinOrderByAggregateInput implements _i1.JsonSerializable {
  const FileRefMinOrderByAggregateInput({
    this.hash,
    this.count,
  });

  factory FileRefMinOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$FileRefMinOrderByAggregateInputFromJson(json);

  final SortOrder? hash;

  final SortOrder? count;

  @override
  Map<String, dynamic> toJson() =>
      _$FileRefMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class FileRefSumOrderByAggregateInput implements _i1.JsonSerializable {
  const FileRefSumOrderByAggregateInput({this.count});

  factory FileRefSumOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$FileRefSumOrderByAggregateInputFromJson(json);

  final SortOrder? count;

  @override
  Map<String, dynamic> toJson() =>
      _$FileRefSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class IntNullableWithAggregatesFilter implements _i1.JsonSerializable {
  const IntNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory IntNullableWithAggregatesFilter.fromJson(Map<String, dynamic> json) =>
      _$IntNullableWithAggregatesFilterFromJson(json);

  final int? equals;

  @JsonKey(name: r'in')
  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final NestedIntNullableWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntNullableFilter? $count;

  @JsonKey(name: r'_avg')
  final NestedFloatNullableFilter? $avg;

  @JsonKey(name: r'_sum')
  final NestedIntNullableFilter? $sum;

  @JsonKey(name: r'_min')
  final NestedIntNullableFilter? $min;

  @JsonKey(name: r'_max')
  final NestedIntNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() =>
      _$IntNullableWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateNestedManyWithoutUserInput implements _i1.JsonSerializable {
  const ProfileCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory ProfileCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateNestedManyWithoutUserInputFromJson(json);

  final Iterable<ProfileCreateWithoutUserInput>? create;

  final Iterable<ProfileCreateOrConnectWithoutUserInput>? connectOrCreate;

  final ProfileCreateManyUserInputEnvelope? createMany;

  final Iterable<ProfileWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateNestedManyWithoutUserInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUncheckedCreateNestedManyWithoutUserInput
    implements _i1.JsonSerializable {
  const ProfileUncheckedCreateNestedManyWithoutUserInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory ProfileUncheckedCreateNestedManyWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUncheckedCreateNestedManyWithoutUserInputFromJson(json);

  final Iterable<ProfileCreateWithoutUserInput>? create;

  final Iterable<ProfileCreateOrConnectWithoutUserInput>? connectOrCreate;

  final ProfileCreateManyUserInputEnvelope? createMany;

  final Iterable<ProfileWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUncheckedCreateNestedManyWithoutUserInputToJson(this);
}

@_i1.jsonSerializable
class StringFieldUpdateOperationsInput implements _i1.JsonSerializable {
  const StringFieldUpdateOperationsInput({this.set});

  factory StringFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$StringFieldUpdateOperationsInputFromJson(json);

  final String? set;

  @override
  Map<String, dynamic> toJson() =>
      _$StringFieldUpdateOperationsInputToJson(this);
}

@_i1.jsonSerializable
class NullableStringFieldUpdateOperationsInput implements _i1.JsonSerializable {
  const NullableStringFieldUpdateOperationsInput({this.set});

  factory NullableStringFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$NullableStringFieldUpdateOperationsInputFromJson(json);

  final String? set;

  @override
  Map<String, dynamic> toJson() =>
      _$NullableStringFieldUpdateOperationsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpdateManyWithoutUserNestedInput implements _i1.JsonSerializable {
  const ProfileUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory ProfileUpdateManyWithoutUserNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUpdateManyWithoutUserNestedInputFromJson(json);

  final Iterable<ProfileCreateWithoutUserInput>? create;

  final Iterable<ProfileCreateOrConnectWithoutUserInput>? connectOrCreate;

  final Iterable<ProfileUpsertWithWhereUniqueWithoutUserInput>? upsert;

  final ProfileCreateManyUserInputEnvelope? createMany;

  final Iterable<ProfileWhereUniqueInput>? set;

  final Iterable<ProfileWhereUniqueInput>? disconnect;

  final Iterable<ProfileWhereUniqueInput>? delete;

  final Iterable<ProfileWhereUniqueInput>? connect;

  final Iterable<ProfileUpdateWithWhereUniqueWithoutUserInput>? update;

  final Iterable<ProfileUpdateManyWithWhereWithoutUserInput>? updateMany;

  final Iterable<ProfileScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUpdateManyWithoutUserNestedInputToJson(this);
}

@_i1.jsonSerializable
class IntFieldUpdateOperationsInput implements _i1.JsonSerializable {
  const IntFieldUpdateOperationsInput({
    this.set,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  factory IntFieldUpdateOperationsInput.fromJson(Map<String, dynamic> json) =>
      _$IntFieldUpdateOperationsInputFromJson(json);

  final int? set;

  final int? increment;

  final int? decrement;

  final int? multiply;

  final int? divide;

  @override
  Map<String, dynamic> toJson() => _$IntFieldUpdateOperationsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUncheckedUpdateManyWithoutUserNestedInput
    implements _i1.JsonSerializable {
  const ProfileUncheckedUpdateManyWithoutUserNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory ProfileUncheckedUpdateManyWithoutUserNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUncheckedUpdateManyWithoutUserNestedInputFromJson(json);

  final Iterable<ProfileCreateWithoutUserInput>? create;

  final Iterable<ProfileCreateOrConnectWithoutUserInput>? connectOrCreate;

  final Iterable<ProfileUpsertWithWhereUniqueWithoutUserInput>? upsert;

  final ProfileCreateManyUserInputEnvelope? createMany;

  final Iterable<ProfileWhereUniqueInput>? set;

  final Iterable<ProfileWhereUniqueInput>? disconnect;

  final Iterable<ProfileWhereUniqueInput>? delete;

  final Iterable<ProfileWhereUniqueInput>? connect;

  final Iterable<ProfileUpdateWithWhereUniqueWithoutUserInput>? update;

  final Iterable<ProfileUpdateManyWithWhereWithoutUserInput>? updateMany;

  final Iterable<ProfileScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUncheckedUpdateManyWithoutUserNestedInputToJson(this);
}

@_i1.jsonSerializable
class UserCreateNestedOneWithoutProfilesInput implements _i1.JsonSerializable {
  const UserCreateNestedOneWithoutProfilesInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory UserCreateNestedOneWithoutProfilesInput.fromJson(
          Map<String, dynamic> json) =>
      _$UserCreateNestedOneWithoutProfilesInputFromJson(json);

  final UserCreateWithoutProfilesInput? create;

  final UserCreateOrConnectWithoutProfilesInput? connectOrCreate;

  final UserWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$UserCreateNestedOneWithoutProfilesInputToJson(this);
}

@_i1.jsonSerializable
class CategoryCreateNestedManyWithoutProfileInput
    implements _i1.JsonSerializable {
  const CategoryCreateNestedManyWithoutProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory CategoryCreateNestedManyWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryCreateNestedManyWithoutProfileInputFromJson(json);

  final Iterable<CategoryCreateWithoutProfileInput>? create;

  final Iterable<CategoryCreateOrConnectWithoutProfileInput>? connectOrCreate;

  final CategoryCreateManyProfileInputEnvelope? createMany;

  final Iterable<CategoryWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryCreateNestedManyWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class TagCreateNestedManyWithoutProfileInput implements _i1.JsonSerializable {
  const TagCreateNestedManyWithoutProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory TagCreateNestedManyWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$TagCreateNestedManyWithoutProfileInputFromJson(json);

  final Iterable<TagCreateWithoutProfileInput>? create;

  final Iterable<TagCreateOrConnectWithoutProfileInput>? connectOrCreate;

  final TagCreateManyProfileInputEnvelope? createMany;

  final Iterable<TagWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TagCreateNestedManyWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateNestedManyWithoutOwnerInput implements _i1.JsonSerializable {
  const TaskCreateNestedManyWithoutOwnerInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory TaskCreateNestedManyWithoutOwnerInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskCreateNestedManyWithoutOwnerInputFromJson(json);

  final Iterable<TaskCreateWithoutOwnerInput>? create;

  final Iterable<TaskCreateOrConnectWithoutOwnerInput>? connectOrCreate;

  final TaskCreateManyOwnerInputEnvelope? createMany;

  final Iterable<TaskWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskCreateNestedManyWithoutOwnerInputToJson(this);
}

@_i1.jsonSerializable
class ChannelCreateNestedManyWithoutOwnerInput implements _i1.JsonSerializable {
  const ChannelCreateNestedManyWithoutOwnerInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory ChannelCreateNestedManyWithoutOwnerInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelCreateNestedManyWithoutOwnerInputFromJson(json);

  final Iterable<ChannelCreateWithoutOwnerInput>? create;

  final Iterable<ChannelCreateOrConnectWithoutOwnerInput>? connectOrCreate;

  final ChannelCreateManyOwnerInputEnvelope? createMany;

  final Iterable<ChannelWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelCreateNestedManyWithoutOwnerInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentCreateNestedManyWithoutProfileInput
    implements _i1.JsonSerializable {
  const TaskAssignmentCreateNestedManyWithoutProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory TaskAssignmentCreateNestedManyWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentCreateNestedManyWithoutProfileInputFromJson(json);

  final Iterable<TaskAssignmentCreateWithoutProfileInput>? create;

  final Iterable<TaskAssignmentCreateOrConnectWithoutProfileInput>?
      connectOrCreate;

  final TaskAssignmentCreateManyProfileInputEnvelope? createMany;

  final Iterable<TaskAssignmentWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentCreateNestedManyWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionCreateNestedManyWithoutProfileInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionCreateNestedManyWithoutProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory ChannelSubscriptionCreateNestedManyWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionCreateNestedManyWithoutProfileInputFromJson(json);

  final Iterable<ChannelSubscriptionCreateWithoutProfileInput>? create;

  final Iterable<ChannelSubscriptionCreateOrConnectWithoutProfileInput>?
      connectOrCreate;

  final ChannelSubscriptionCreateManyProfileInputEnvelope? createMany;

  final Iterable<ChannelSubscriptionWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionCreateNestedManyWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleCreateNestedManyWithoutProfileInput
    implements _i1.JsonSerializable {
  const ScheduleCreateNestedManyWithoutProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory ScheduleCreateNestedManyWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleCreateNestedManyWithoutProfileInputFromJson(json);

  final Iterable<ScheduleCreateWithoutProfileInput>? create;

  final Iterable<ScheduleCreateOrConnectWithoutProfileInput>? connectOrCreate;

  final ScheduleCreateManyProfileInputEnvelope? createMany;

  final Iterable<ScheduleWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleCreateNestedManyWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class RecordCreateNestedManyWithoutProfileInput
    implements _i1.JsonSerializable {
  const RecordCreateNestedManyWithoutProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory RecordCreateNestedManyWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordCreateNestedManyWithoutProfileInputFromJson(json);

  final Iterable<RecordCreateWithoutProfileInput>? create;

  final Iterable<RecordCreateOrConnectWithoutProfileInput>? connectOrCreate;

  final RecordCreateManyProfileInputEnvelope? createMany;

  final Iterable<RecordWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordCreateNestedManyWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class CategoryUncheckedCreateNestedManyWithoutProfileInput
    implements _i1.JsonSerializable {
  const CategoryUncheckedCreateNestedManyWithoutProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory CategoryUncheckedCreateNestedManyWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryUncheckedCreateNestedManyWithoutProfileInputFromJson(json);

  final Iterable<CategoryCreateWithoutProfileInput>? create;

  final Iterable<CategoryCreateOrConnectWithoutProfileInput>? connectOrCreate;

  final CategoryCreateManyProfileInputEnvelope? createMany;

  final Iterable<CategoryWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryUncheckedCreateNestedManyWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class TagUncheckedCreateNestedManyWithoutProfileInput
    implements _i1.JsonSerializable {
  const TagUncheckedCreateNestedManyWithoutProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory TagUncheckedCreateNestedManyWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$TagUncheckedCreateNestedManyWithoutProfileInputFromJson(json);

  final Iterable<TagCreateWithoutProfileInput>? create;

  final Iterable<TagCreateOrConnectWithoutProfileInput>? connectOrCreate;

  final TagCreateManyProfileInputEnvelope? createMany;

  final Iterable<TagWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TagUncheckedCreateNestedManyWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedCreateNestedManyWithoutOwnerInput
    implements _i1.JsonSerializable {
  const TaskUncheckedCreateNestedManyWithoutOwnerInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory TaskUncheckedCreateNestedManyWithoutOwnerInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUncheckedCreateNestedManyWithoutOwnerInputFromJson(json);

  final Iterable<TaskCreateWithoutOwnerInput>? create;

  final Iterable<TaskCreateOrConnectWithoutOwnerInput>? connectOrCreate;

  final TaskCreateManyOwnerInputEnvelope? createMany;

  final Iterable<TaskWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUncheckedCreateNestedManyWithoutOwnerInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUncheckedCreateNestedManyWithoutOwnerInput
    implements _i1.JsonSerializable {
  const ChannelUncheckedCreateNestedManyWithoutOwnerInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory ChannelUncheckedCreateNestedManyWithoutOwnerInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelUncheckedCreateNestedManyWithoutOwnerInputFromJson(json);

  final Iterable<ChannelCreateWithoutOwnerInput>? create;

  final Iterable<ChannelCreateOrConnectWithoutOwnerInput>? connectOrCreate;

  final ChannelCreateManyOwnerInputEnvelope? createMany;

  final Iterable<ChannelWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelUncheckedCreateNestedManyWithoutOwnerInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUncheckedCreateNestedManyWithoutProfileInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUncheckedCreateNestedManyWithoutProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory TaskAssignmentUncheckedCreateNestedManyWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUncheckedCreateNestedManyWithoutProfileInputFromJson(
          json);

  final Iterable<TaskAssignmentCreateWithoutProfileInput>? create;

  final Iterable<TaskAssignmentCreateOrConnectWithoutProfileInput>?
      connectOrCreate;

  final TaskAssignmentCreateManyProfileInputEnvelope? createMany;

  final Iterable<TaskAssignmentWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUncheckedCreateNestedManyWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUncheckedCreateNestedManyWithoutProfileInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionUncheckedCreateNestedManyWithoutProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory ChannelSubscriptionUncheckedCreateNestedManyWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionUncheckedCreateNestedManyWithoutProfileInputFromJson(
          json);

  final Iterable<ChannelSubscriptionCreateWithoutProfileInput>? create;

  final Iterable<ChannelSubscriptionCreateOrConnectWithoutProfileInput>?
      connectOrCreate;

  final ChannelSubscriptionCreateManyProfileInputEnvelope? createMany;

  final Iterable<ChannelSubscriptionWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionUncheckedCreateNestedManyWithoutProfileInputToJson(
          this);
}

@_i1.jsonSerializable
class ScheduleUncheckedCreateNestedManyWithoutProfileInput
    implements _i1.JsonSerializable {
  const ScheduleUncheckedCreateNestedManyWithoutProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory ScheduleUncheckedCreateNestedManyWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleUncheckedCreateNestedManyWithoutProfileInputFromJson(json);

  final Iterable<ScheduleCreateWithoutProfileInput>? create;

  final Iterable<ScheduleCreateOrConnectWithoutProfileInput>? connectOrCreate;

  final ScheduleCreateManyProfileInputEnvelope? createMany;

  final Iterable<ScheduleWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleUncheckedCreateNestedManyWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class RecordUncheckedCreateNestedManyWithoutProfileInput
    implements _i1.JsonSerializable {
  const RecordUncheckedCreateNestedManyWithoutProfileInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory RecordUncheckedCreateNestedManyWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUncheckedCreateNestedManyWithoutProfileInputFromJson(json);

  final Iterable<RecordCreateWithoutProfileInput>? create;

  final Iterable<RecordCreateOrConnectWithoutProfileInput>? connectOrCreate;

  final RecordCreateManyProfileInputEnvelope? createMany;

  final Iterable<RecordWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUncheckedCreateNestedManyWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class BigIntFieldUpdateOperationsInput implements _i1.JsonSerializable {
  const BigIntFieldUpdateOperationsInput({
    this.set,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  factory BigIntFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$BigIntFieldUpdateOperationsInputFromJson(json);

  final BigInt? set;

  final BigInt? increment;

  final BigInt? decrement;

  final BigInt? multiply;

  final BigInt? divide;

  @override
  Map<String, dynamic> toJson() =>
      _$BigIntFieldUpdateOperationsInputToJson(this);
}

@_i1.jsonSerializable
class UserUpdateOneRequiredWithoutProfilesNestedInput
    implements _i1.JsonSerializable {
  const UserUpdateOneRequiredWithoutProfilesNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  factory UserUpdateOneRequiredWithoutProfilesNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$UserUpdateOneRequiredWithoutProfilesNestedInputFromJson(json);

  final UserCreateWithoutProfilesInput? create;

  final UserCreateOrConnectWithoutProfilesInput? connectOrCreate;

  final UserUpsertWithoutProfilesInput? upsert;

  final UserWhereUniqueInput? connect;

  final UserUpdateWithoutProfilesInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$UserUpdateOneRequiredWithoutProfilesNestedInputToJson(this);
}

@_i1.jsonSerializable
class CategoryUpdateManyWithoutProfileNestedInput
    implements _i1.JsonSerializable {
  const CategoryUpdateManyWithoutProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory CategoryUpdateManyWithoutProfileNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryUpdateManyWithoutProfileNestedInputFromJson(json);

  final Iterable<CategoryCreateWithoutProfileInput>? create;

  final Iterable<CategoryCreateOrConnectWithoutProfileInput>? connectOrCreate;

  final Iterable<CategoryUpsertWithWhereUniqueWithoutProfileInput>? upsert;

  final CategoryCreateManyProfileInputEnvelope? createMany;

  final Iterable<CategoryWhereUniqueInput>? set;

  final Iterable<CategoryWhereUniqueInput>? disconnect;

  final Iterable<CategoryWhereUniqueInput>? delete;

  final Iterable<CategoryWhereUniqueInput>? connect;

  final Iterable<CategoryUpdateWithWhereUniqueWithoutProfileInput>? update;

  final Iterable<CategoryUpdateManyWithWhereWithoutProfileInput>? updateMany;

  final Iterable<CategoryScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryUpdateManyWithoutProfileNestedInputToJson(this);
}

@_i1.jsonSerializable
class TagUpdateManyWithoutProfileNestedInput implements _i1.JsonSerializable {
  const TagUpdateManyWithoutProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory TagUpdateManyWithoutProfileNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TagUpdateManyWithoutProfileNestedInputFromJson(json);

  final Iterable<TagCreateWithoutProfileInput>? create;

  final Iterable<TagCreateOrConnectWithoutProfileInput>? connectOrCreate;

  final Iterable<TagUpsertWithWhereUniqueWithoutProfileInput>? upsert;

  final TagCreateManyProfileInputEnvelope? createMany;

  final Iterable<TagWhereUniqueInput>? set;

  final Iterable<TagWhereUniqueInput>? disconnect;

  final Iterable<TagWhereUniqueInput>? delete;

  final Iterable<TagWhereUniqueInput>? connect;

  final Iterable<TagUpdateWithWhereUniqueWithoutProfileInput>? update;

  final Iterable<TagUpdateManyWithWhereWithoutProfileInput>? updateMany;

  final Iterable<TagScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$TagUpdateManyWithoutProfileNestedInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpdateManyWithoutOwnerNestedInput implements _i1.JsonSerializable {
  const TaskUpdateManyWithoutOwnerNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory TaskUpdateManyWithoutOwnerNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUpdateManyWithoutOwnerNestedInputFromJson(json);

  final Iterable<TaskCreateWithoutOwnerInput>? create;

  final Iterable<TaskCreateOrConnectWithoutOwnerInput>? connectOrCreate;

  final Iterable<TaskUpsertWithWhereUniqueWithoutOwnerInput>? upsert;

  final TaskCreateManyOwnerInputEnvelope? createMany;

  final Iterable<TaskWhereUniqueInput>? set;

  final Iterable<TaskWhereUniqueInput>? disconnect;

  final Iterable<TaskWhereUniqueInput>? delete;

  final Iterable<TaskWhereUniqueInput>? connect;

  final Iterable<TaskUpdateWithWhereUniqueWithoutOwnerInput>? update;

  final Iterable<TaskUpdateManyWithWhereWithoutOwnerInput>? updateMany;

  final Iterable<TaskScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUpdateManyWithoutOwnerNestedInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUpdateManyWithoutOwnerNestedInput implements _i1.JsonSerializable {
  const ChannelUpdateManyWithoutOwnerNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory ChannelUpdateManyWithoutOwnerNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelUpdateManyWithoutOwnerNestedInputFromJson(json);

  final Iterable<ChannelCreateWithoutOwnerInput>? create;

  final Iterable<ChannelCreateOrConnectWithoutOwnerInput>? connectOrCreate;

  final Iterable<ChannelUpsertWithWhereUniqueWithoutOwnerInput>? upsert;

  final ChannelCreateManyOwnerInputEnvelope? createMany;

  final Iterable<ChannelWhereUniqueInput>? set;

  final Iterable<ChannelWhereUniqueInput>? disconnect;

  final Iterable<ChannelWhereUniqueInput>? delete;

  final Iterable<ChannelWhereUniqueInput>? connect;

  final Iterable<ChannelUpdateWithWhereUniqueWithoutOwnerInput>? update;

  final Iterable<ChannelUpdateManyWithWhereWithoutOwnerInput>? updateMany;

  final Iterable<ChannelScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelUpdateManyWithoutOwnerNestedInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUpdateManyWithoutProfileNestedInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUpdateManyWithoutProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory TaskAssignmentUpdateManyWithoutProfileNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUpdateManyWithoutProfileNestedInputFromJson(json);

  final Iterable<TaskAssignmentCreateWithoutProfileInput>? create;

  final Iterable<TaskAssignmentCreateOrConnectWithoutProfileInput>?
      connectOrCreate;

  final Iterable<TaskAssignmentUpsertWithWhereUniqueWithoutProfileInput>?
      upsert;

  final TaskAssignmentCreateManyProfileInputEnvelope? createMany;

  final Iterable<TaskAssignmentWhereUniqueInput>? set;

  final Iterable<TaskAssignmentWhereUniqueInput>? disconnect;

  final Iterable<TaskAssignmentWhereUniqueInput>? delete;

  final Iterable<TaskAssignmentWhereUniqueInput>? connect;

  final Iterable<TaskAssignmentUpdateWithWhereUniqueWithoutProfileInput>?
      update;

  final Iterable<TaskAssignmentUpdateManyWithWhereWithoutProfileInput>?
      updateMany;

  final Iterable<TaskAssignmentScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUpdateManyWithoutProfileNestedInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUpdateManyWithoutProfileNestedInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionUpdateManyWithoutProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory ChannelSubscriptionUpdateManyWithoutProfileNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionUpdateManyWithoutProfileNestedInputFromJson(json);

  final Iterable<ChannelSubscriptionCreateWithoutProfileInput>? create;

  final Iterable<ChannelSubscriptionCreateOrConnectWithoutProfileInput>?
      connectOrCreate;

  final Iterable<ChannelSubscriptionUpsertWithWhereUniqueWithoutProfileInput>?
      upsert;

  final ChannelSubscriptionCreateManyProfileInputEnvelope? createMany;

  final Iterable<ChannelSubscriptionWhereUniqueInput>? set;

  final Iterable<ChannelSubscriptionWhereUniqueInput>? disconnect;

  final Iterable<ChannelSubscriptionWhereUniqueInput>? delete;

  final Iterable<ChannelSubscriptionWhereUniqueInput>? connect;

  final Iterable<ChannelSubscriptionUpdateWithWhereUniqueWithoutProfileInput>?
      update;

  final Iterable<ChannelSubscriptionUpdateManyWithWhereWithoutProfileInput>?
      updateMany;

  final Iterable<ChannelSubscriptionScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionUpdateManyWithoutProfileNestedInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleUpdateManyWithoutProfileNestedInput
    implements _i1.JsonSerializable {
  const ScheduleUpdateManyWithoutProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory ScheduleUpdateManyWithoutProfileNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleUpdateManyWithoutProfileNestedInputFromJson(json);

  final Iterable<ScheduleCreateWithoutProfileInput>? create;

  final Iterable<ScheduleCreateOrConnectWithoutProfileInput>? connectOrCreate;

  final Iterable<ScheduleUpsertWithWhereUniqueWithoutProfileInput>? upsert;

  final ScheduleCreateManyProfileInputEnvelope? createMany;

  final Iterable<ScheduleWhereUniqueInput>? set;

  final Iterable<ScheduleWhereUniqueInput>? disconnect;

  final Iterable<ScheduleWhereUniqueInput>? delete;

  final Iterable<ScheduleWhereUniqueInput>? connect;

  final Iterable<ScheduleUpdateWithWhereUniqueWithoutProfileInput>? update;

  final Iterable<ScheduleUpdateManyWithWhereWithoutProfileInput>? updateMany;

  final Iterable<ScheduleScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleUpdateManyWithoutProfileNestedInputToJson(this);
}

@_i1.jsonSerializable
class RecordUpdateManyWithoutProfileNestedInput
    implements _i1.JsonSerializable {
  const RecordUpdateManyWithoutProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory RecordUpdateManyWithoutProfileNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUpdateManyWithoutProfileNestedInputFromJson(json);

  final Iterable<RecordCreateWithoutProfileInput>? create;

  final Iterable<RecordCreateOrConnectWithoutProfileInput>? connectOrCreate;

  final Iterable<RecordUpsertWithWhereUniqueWithoutProfileInput>? upsert;

  final RecordCreateManyProfileInputEnvelope? createMany;

  final Iterable<RecordWhereUniqueInput>? set;

  final Iterable<RecordWhereUniqueInput>? disconnect;

  final Iterable<RecordWhereUniqueInput>? delete;

  final Iterable<RecordWhereUniqueInput>? connect;

  final Iterable<RecordUpdateWithWhereUniqueWithoutProfileInput>? update;

  final Iterable<RecordUpdateManyWithWhereWithoutProfileInput>? updateMany;

  final Iterable<RecordScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUpdateManyWithoutProfileNestedInputToJson(this);
}

@_i1.jsonSerializable
class CategoryUncheckedUpdateManyWithoutProfileNestedInput
    implements _i1.JsonSerializable {
  const CategoryUncheckedUpdateManyWithoutProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory CategoryUncheckedUpdateManyWithoutProfileNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryUncheckedUpdateManyWithoutProfileNestedInputFromJson(json);

  final Iterable<CategoryCreateWithoutProfileInput>? create;

  final Iterable<CategoryCreateOrConnectWithoutProfileInput>? connectOrCreate;

  final Iterable<CategoryUpsertWithWhereUniqueWithoutProfileInput>? upsert;

  final CategoryCreateManyProfileInputEnvelope? createMany;

  final Iterable<CategoryWhereUniqueInput>? set;

  final Iterable<CategoryWhereUniqueInput>? disconnect;

  final Iterable<CategoryWhereUniqueInput>? delete;

  final Iterable<CategoryWhereUniqueInput>? connect;

  final Iterable<CategoryUpdateWithWhereUniqueWithoutProfileInput>? update;

  final Iterable<CategoryUpdateManyWithWhereWithoutProfileInput>? updateMany;

  final Iterable<CategoryScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryUncheckedUpdateManyWithoutProfileNestedInputToJson(this);
}

@_i1.jsonSerializable
class TagUncheckedUpdateManyWithoutProfileNestedInput
    implements _i1.JsonSerializable {
  const TagUncheckedUpdateManyWithoutProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory TagUncheckedUpdateManyWithoutProfileNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TagUncheckedUpdateManyWithoutProfileNestedInputFromJson(json);

  final Iterable<TagCreateWithoutProfileInput>? create;

  final Iterable<TagCreateOrConnectWithoutProfileInput>? connectOrCreate;

  final Iterable<TagUpsertWithWhereUniqueWithoutProfileInput>? upsert;

  final TagCreateManyProfileInputEnvelope? createMany;

  final Iterable<TagWhereUniqueInput>? set;

  final Iterable<TagWhereUniqueInput>? disconnect;

  final Iterable<TagWhereUniqueInput>? delete;

  final Iterable<TagWhereUniqueInput>? connect;

  final Iterable<TagUpdateWithWhereUniqueWithoutProfileInput>? update;

  final Iterable<TagUpdateManyWithWhereWithoutProfileInput>? updateMany;

  final Iterable<TagScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$TagUncheckedUpdateManyWithoutProfileNestedInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedUpdateManyWithoutOwnerNestedInput
    implements _i1.JsonSerializable {
  const TaskUncheckedUpdateManyWithoutOwnerNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory TaskUncheckedUpdateManyWithoutOwnerNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUncheckedUpdateManyWithoutOwnerNestedInputFromJson(json);

  final Iterable<TaskCreateWithoutOwnerInput>? create;

  final Iterable<TaskCreateOrConnectWithoutOwnerInput>? connectOrCreate;

  final Iterable<TaskUpsertWithWhereUniqueWithoutOwnerInput>? upsert;

  final TaskCreateManyOwnerInputEnvelope? createMany;

  final Iterable<TaskWhereUniqueInput>? set;

  final Iterable<TaskWhereUniqueInput>? disconnect;

  final Iterable<TaskWhereUniqueInput>? delete;

  final Iterable<TaskWhereUniqueInput>? connect;

  final Iterable<TaskUpdateWithWhereUniqueWithoutOwnerInput>? update;

  final Iterable<TaskUpdateManyWithWhereWithoutOwnerInput>? updateMany;

  final Iterable<TaskScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUncheckedUpdateManyWithoutOwnerNestedInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUncheckedUpdateManyWithoutOwnerNestedInput
    implements _i1.JsonSerializable {
  const ChannelUncheckedUpdateManyWithoutOwnerNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory ChannelUncheckedUpdateManyWithoutOwnerNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelUncheckedUpdateManyWithoutOwnerNestedInputFromJson(json);

  final Iterable<ChannelCreateWithoutOwnerInput>? create;

  final Iterable<ChannelCreateOrConnectWithoutOwnerInput>? connectOrCreate;

  final Iterable<ChannelUpsertWithWhereUniqueWithoutOwnerInput>? upsert;

  final ChannelCreateManyOwnerInputEnvelope? createMany;

  final Iterable<ChannelWhereUniqueInput>? set;

  final Iterable<ChannelWhereUniqueInput>? disconnect;

  final Iterable<ChannelWhereUniqueInput>? delete;

  final Iterable<ChannelWhereUniqueInput>? connect;

  final Iterable<ChannelUpdateWithWhereUniqueWithoutOwnerInput>? update;

  final Iterable<ChannelUpdateManyWithWhereWithoutOwnerInput>? updateMany;

  final Iterable<ChannelScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelUncheckedUpdateManyWithoutOwnerNestedInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUncheckedUpdateManyWithoutProfileNestedInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUncheckedUpdateManyWithoutProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory TaskAssignmentUncheckedUpdateManyWithoutProfileNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUncheckedUpdateManyWithoutProfileNestedInputFromJson(
          json);

  final Iterable<TaskAssignmentCreateWithoutProfileInput>? create;

  final Iterable<TaskAssignmentCreateOrConnectWithoutProfileInput>?
      connectOrCreate;

  final Iterable<TaskAssignmentUpsertWithWhereUniqueWithoutProfileInput>?
      upsert;

  final TaskAssignmentCreateManyProfileInputEnvelope? createMany;

  final Iterable<TaskAssignmentWhereUniqueInput>? set;

  final Iterable<TaskAssignmentWhereUniqueInput>? disconnect;

  final Iterable<TaskAssignmentWhereUniqueInput>? delete;

  final Iterable<TaskAssignmentWhereUniqueInput>? connect;

  final Iterable<TaskAssignmentUpdateWithWhereUniqueWithoutProfileInput>?
      update;

  final Iterable<TaskAssignmentUpdateManyWithWhereWithoutProfileInput>?
      updateMany;

  final Iterable<TaskAssignmentScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUncheckedUpdateManyWithoutProfileNestedInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUncheckedUpdateManyWithoutProfileNestedInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionUncheckedUpdateManyWithoutProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory ChannelSubscriptionUncheckedUpdateManyWithoutProfileNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionUncheckedUpdateManyWithoutProfileNestedInputFromJson(
          json);

  final Iterable<ChannelSubscriptionCreateWithoutProfileInput>? create;

  final Iterable<ChannelSubscriptionCreateOrConnectWithoutProfileInput>?
      connectOrCreate;

  final Iterable<ChannelSubscriptionUpsertWithWhereUniqueWithoutProfileInput>?
      upsert;

  final ChannelSubscriptionCreateManyProfileInputEnvelope? createMany;

  final Iterable<ChannelSubscriptionWhereUniqueInput>? set;

  final Iterable<ChannelSubscriptionWhereUniqueInput>? disconnect;

  final Iterable<ChannelSubscriptionWhereUniqueInput>? delete;

  final Iterable<ChannelSubscriptionWhereUniqueInput>? connect;

  final Iterable<ChannelSubscriptionUpdateWithWhereUniqueWithoutProfileInput>?
      update;

  final Iterable<ChannelSubscriptionUpdateManyWithWhereWithoutProfileInput>?
      updateMany;

  final Iterable<ChannelSubscriptionScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionUncheckedUpdateManyWithoutProfileNestedInputToJson(
          this);
}

@_i1.jsonSerializable
class ScheduleUncheckedUpdateManyWithoutProfileNestedInput
    implements _i1.JsonSerializable {
  const ScheduleUncheckedUpdateManyWithoutProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory ScheduleUncheckedUpdateManyWithoutProfileNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleUncheckedUpdateManyWithoutProfileNestedInputFromJson(json);

  final Iterable<ScheduleCreateWithoutProfileInput>? create;

  final Iterable<ScheduleCreateOrConnectWithoutProfileInput>? connectOrCreate;

  final Iterable<ScheduleUpsertWithWhereUniqueWithoutProfileInput>? upsert;

  final ScheduleCreateManyProfileInputEnvelope? createMany;

  final Iterable<ScheduleWhereUniqueInput>? set;

  final Iterable<ScheduleWhereUniqueInput>? disconnect;

  final Iterable<ScheduleWhereUniqueInput>? delete;

  final Iterable<ScheduleWhereUniqueInput>? connect;

  final Iterable<ScheduleUpdateWithWhereUniqueWithoutProfileInput>? update;

  final Iterable<ScheduleUpdateManyWithWhereWithoutProfileInput>? updateMany;

  final Iterable<ScheduleScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleUncheckedUpdateManyWithoutProfileNestedInputToJson(this);
}

@_i1.jsonSerializable
class RecordUncheckedUpdateManyWithoutProfileNestedInput
    implements _i1.JsonSerializable {
  const RecordUncheckedUpdateManyWithoutProfileNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory RecordUncheckedUpdateManyWithoutProfileNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUncheckedUpdateManyWithoutProfileNestedInputFromJson(json);

  final Iterable<RecordCreateWithoutProfileInput>? create;

  final Iterable<RecordCreateOrConnectWithoutProfileInput>? connectOrCreate;

  final Iterable<RecordUpsertWithWhereUniqueWithoutProfileInput>? upsert;

  final RecordCreateManyProfileInputEnvelope? createMany;

  final Iterable<RecordWhereUniqueInput>? set;

  final Iterable<RecordWhereUniqueInput>? disconnect;

  final Iterable<RecordWhereUniqueInput>? delete;

  final Iterable<RecordWhereUniqueInput>? connect;

  final Iterable<RecordUpdateWithWhereUniqueWithoutProfileInput>? update;

  final Iterable<RecordUpdateManyWithWhereWithoutProfileInput>? updateMany;

  final Iterable<RecordScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUncheckedUpdateManyWithoutProfileNestedInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateNestedOneWithoutTasksInput implements _i1.JsonSerializable {
  const ProfileCreateNestedOneWithoutTasksInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory ProfileCreateNestedOneWithoutTasksInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateNestedOneWithoutTasksInputFromJson(json);

  final ProfileCreateWithoutTasksInput? create;

  final ProfileCreateOrConnectWithoutTasksInput? connectOrCreate;

  final ProfileWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateNestedOneWithoutTasksInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateNestedOneWithoutChildrenInput implements _i1.JsonSerializable {
  const TaskCreateNestedOneWithoutChildrenInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory TaskCreateNestedOneWithoutChildrenInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskCreateNestedOneWithoutChildrenInputFromJson(json);

  final TaskCreateWithoutChildrenInput? create;

  final TaskCreateOrConnectWithoutChildrenInput? connectOrCreate;

  final TaskWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskCreateNestedOneWithoutChildrenInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateNestedManyWithoutParentInput implements _i1.JsonSerializable {
  const TaskCreateNestedManyWithoutParentInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory TaskCreateNestedManyWithoutParentInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskCreateNestedManyWithoutParentInputFromJson(json);

  final Iterable<TaskCreateWithoutParentInput>? create;

  final Iterable<TaskCreateOrConnectWithoutParentInput>? connectOrCreate;

  final TaskCreateManyParentInputEnvelope? createMany;

  final Iterable<TaskWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskCreateNestedManyWithoutParentInputToJson(this);
}

@_i1.jsonSerializable
class ChannelCreateNestedOneWithoutTasksInput implements _i1.JsonSerializable {
  const ChannelCreateNestedOneWithoutTasksInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory ChannelCreateNestedOneWithoutTasksInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelCreateNestedOneWithoutTasksInputFromJson(json);

  final ChannelCreateWithoutTasksInput? create;

  final ChannelCreateOrConnectWithoutTasksInput? connectOrCreate;

  final ChannelWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelCreateNestedOneWithoutTasksInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetCreateNestedManyWithoutTaskInput
    implements _i1.JsonSerializable {
  const TaskAssetCreateNestedManyWithoutTaskInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory TaskAssetCreateNestedManyWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssetCreateNestedManyWithoutTaskInputFromJson(json);

  final Iterable<TaskAssetCreateWithoutTaskInput>? create;

  final Iterable<TaskAssetCreateOrConnectWithoutTaskInput>? connectOrCreate;

  final TaskAssetCreateManyTaskInputEnvelope? createMany;

  final Iterable<TaskAssetWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetCreateNestedManyWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentCreateNestedManyWithoutTaskInput
    implements _i1.JsonSerializable {
  const TaskAssignmentCreateNestedManyWithoutTaskInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory TaskAssignmentCreateNestedManyWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentCreateNestedManyWithoutTaskInputFromJson(json);

  final Iterable<TaskAssignmentCreateWithoutTaskInput>? create;

  final Iterable<TaskAssignmentCreateOrConnectWithoutTaskInput>?
      connectOrCreate;

  final TaskAssignmentCreateManyTaskInputEnvelope? createMany;

  final Iterable<TaskAssignmentWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentCreateNestedManyWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class SessionCreateNestedManyWithoutTaskInput implements _i1.JsonSerializable {
  const SessionCreateNestedManyWithoutTaskInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory SessionCreateNestedManyWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionCreateNestedManyWithoutTaskInputFromJson(json);

  final Iterable<SessionCreateWithoutTaskInput>? create;

  final Iterable<SessionCreateOrConnectWithoutTaskInput>? connectOrCreate;

  final SessionCreateManyTaskInputEnvelope? createMany;

  final Iterable<SessionWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionCreateNestedManyWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class RecordCreateNestedManyWithoutTaskInput implements _i1.JsonSerializable {
  const RecordCreateNestedManyWithoutTaskInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory RecordCreateNestedManyWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordCreateNestedManyWithoutTaskInputFromJson(json);

  final Iterable<RecordCreateWithoutTaskInput>? create;

  final Iterable<RecordCreateOrConnectWithoutTaskInput>? connectOrCreate;

  final RecordCreateManyTaskInputEnvelope? createMany;

  final Iterable<RecordWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordCreateNestedManyWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedCreateNestedManyWithoutParentInput
    implements _i1.JsonSerializable {
  const TaskUncheckedCreateNestedManyWithoutParentInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory TaskUncheckedCreateNestedManyWithoutParentInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUncheckedCreateNestedManyWithoutParentInputFromJson(json);

  final Iterable<TaskCreateWithoutParentInput>? create;

  final Iterable<TaskCreateOrConnectWithoutParentInput>? connectOrCreate;

  final TaskCreateManyParentInputEnvelope? createMany;

  final Iterable<TaskWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUncheckedCreateNestedManyWithoutParentInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetUncheckedCreateNestedManyWithoutTaskInput
    implements _i1.JsonSerializable {
  const TaskAssetUncheckedCreateNestedManyWithoutTaskInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory TaskAssetUncheckedCreateNestedManyWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssetUncheckedCreateNestedManyWithoutTaskInputFromJson(json);

  final Iterable<TaskAssetCreateWithoutTaskInput>? create;

  final Iterable<TaskAssetCreateOrConnectWithoutTaskInput>? connectOrCreate;

  final TaskAssetCreateManyTaskInputEnvelope? createMany;

  final Iterable<TaskAssetWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetUncheckedCreateNestedManyWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUncheckedCreateNestedManyWithoutTaskInputFromJson(json);

  final Iterable<TaskAssignmentCreateWithoutTaskInput>? create;

  final Iterable<TaskAssignmentCreateOrConnectWithoutTaskInput>?
      connectOrCreate;

  final TaskAssignmentCreateManyTaskInputEnvelope? createMany;

  final Iterable<TaskAssignmentWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUncheckedCreateNestedManyWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class SessionUncheckedCreateNestedManyWithoutTaskInput
    implements _i1.JsonSerializable {
  const SessionUncheckedCreateNestedManyWithoutTaskInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory SessionUncheckedCreateNestedManyWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionUncheckedCreateNestedManyWithoutTaskInputFromJson(json);

  final Iterable<SessionCreateWithoutTaskInput>? create;

  final Iterable<SessionCreateOrConnectWithoutTaskInput>? connectOrCreate;

  final SessionCreateManyTaskInputEnvelope? createMany;

  final Iterable<SessionWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionUncheckedCreateNestedManyWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class RecordUncheckedCreateNestedManyWithoutTaskInput
    implements _i1.JsonSerializable {
  const RecordUncheckedCreateNestedManyWithoutTaskInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory RecordUncheckedCreateNestedManyWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUncheckedCreateNestedManyWithoutTaskInputFromJson(json);

  final Iterable<RecordCreateWithoutTaskInput>? create;

  final Iterable<RecordCreateOrConnectWithoutTaskInput>? connectOrCreate;

  final RecordCreateManyTaskInputEnvelope? createMany;

  final Iterable<RecordWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUncheckedCreateNestedManyWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class BoolFieldUpdateOperationsInput implements _i1.JsonSerializable {
  const BoolFieldUpdateOperationsInput({this.set});

  factory BoolFieldUpdateOperationsInput.fromJson(Map<String, dynamic> json) =>
      _$BoolFieldUpdateOperationsInputFromJson(json);

  final bool? set;

  @override
  Map<String, dynamic> toJson() => _$BoolFieldUpdateOperationsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpdateOneRequiredWithoutTasksNestedInput
    implements _i1.JsonSerializable {
  const ProfileUpdateOneRequiredWithoutTasksNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  factory ProfileUpdateOneRequiredWithoutTasksNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUpdateOneRequiredWithoutTasksNestedInputFromJson(json);

  final ProfileCreateWithoutTasksInput? create;

  final ProfileCreateOrConnectWithoutTasksInput? connectOrCreate;

  final ProfileUpsertWithoutTasksInput? upsert;

  final ProfileWhereUniqueInput? connect;

  final ProfileUpdateWithoutTasksInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUpdateOneRequiredWithoutTasksNestedInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpdateOneWithoutChildrenNestedInput implements _i1.JsonSerializable {
  const TaskUpdateOneWithoutChildrenNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  factory TaskUpdateOneWithoutChildrenNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUpdateOneWithoutChildrenNestedInputFromJson(json);

  final TaskCreateWithoutChildrenInput? create;

  final TaskCreateOrConnectWithoutChildrenInput? connectOrCreate;

  final TaskUpsertWithoutChildrenInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final TaskWhereUniqueInput? connect;

  final TaskUpdateWithoutChildrenInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUpdateOneWithoutChildrenNestedInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpdateManyWithoutParentNestedInput implements _i1.JsonSerializable {
  const TaskUpdateManyWithoutParentNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory TaskUpdateManyWithoutParentNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUpdateManyWithoutParentNestedInputFromJson(json);

  final Iterable<TaskCreateWithoutParentInput>? create;

  final Iterable<TaskCreateOrConnectWithoutParentInput>? connectOrCreate;

  final Iterable<TaskUpsertWithWhereUniqueWithoutParentInput>? upsert;

  final TaskCreateManyParentInputEnvelope? createMany;

  final Iterable<TaskWhereUniqueInput>? set;

  final Iterable<TaskWhereUniqueInput>? disconnect;

  final Iterable<TaskWhereUniqueInput>? delete;

  final Iterable<TaskWhereUniqueInput>? connect;

  final Iterable<TaskUpdateWithWhereUniqueWithoutParentInput>? update;

  final Iterable<TaskUpdateManyWithWhereWithoutParentInput>? updateMany;

  final Iterable<TaskScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUpdateManyWithoutParentNestedInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUpdateOneWithoutTasksNestedInput implements _i1.JsonSerializable {
  const ChannelUpdateOneWithoutTasksNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  factory ChannelUpdateOneWithoutTasksNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelUpdateOneWithoutTasksNestedInputFromJson(json);

  final ChannelCreateWithoutTasksInput? create;

  final ChannelCreateOrConnectWithoutTasksInput? connectOrCreate;

  final ChannelUpsertWithoutTasksInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final ChannelWhereUniqueInput? connect;

  final ChannelUpdateWithoutTasksInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelUpdateOneWithoutTasksNestedInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetUpdateManyWithoutTaskNestedInput
    implements _i1.JsonSerializable {
  const TaskAssetUpdateManyWithoutTaskNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory TaskAssetUpdateManyWithoutTaskNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssetUpdateManyWithoutTaskNestedInputFromJson(json);

  final Iterable<TaskAssetCreateWithoutTaskInput>? create;

  final Iterable<TaskAssetCreateOrConnectWithoutTaskInput>? connectOrCreate;

  final Iterable<TaskAssetUpsertWithWhereUniqueWithoutTaskInput>? upsert;

  final TaskAssetCreateManyTaskInputEnvelope? createMany;

  final Iterable<TaskAssetWhereUniqueInput>? set;

  final Iterable<TaskAssetWhereUniqueInput>? disconnect;

  final Iterable<TaskAssetWhereUniqueInput>? delete;

  final Iterable<TaskAssetWhereUniqueInput>? connect;

  final Iterable<TaskAssetUpdateWithWhereUniqueWithoutTaskInput>? update;

  final Iterable<TaskAssetUpdateManyWithWhereWithoutTaskInput>? updateMany;

  final Iterable<TaskAssetScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetUpdateManyWithoutTaskNestedInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUpdateManyWithoutTaskNestedInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUpdateManyWithoutTaskNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory TaskAssignmentUpdateManyWithoutTaskNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUpdateManyWithoutTaskNestedInputFromJson(json);

  final Iterable<TaskAssignmentCreateWithoutTaskInput>? create;

  final Iterable<TaskAssignmentCreateOrConnectWithoutTaskInput>?
      connectOrCreate;

  final Iterable<TaskAssignmentUpsertWithWhereUniqueWithoutTaskInput>? upsert;

  final TaskAssignmentCreateManyTaskInputEnvelope? createMany;

  final Iterable<TaskAssignmentWhereUniqueInput>? set;

  final Iterable<TaskAssignmentWhereUniqueInput>? disconnect;

  final Iterable<TaskAssignmentWhereUniqueInput>? delete;

  final Iterable<TaskAssignmentWhereUniqueInput>? connect;

  final Iterable<TaskAssignmentUpdateWithWhereUniqueWithoutTaskInput>? update;

  final Iterable<TaskAssignmentUpdateManyWithWhereWithoutTaskInput>? updateMany;

  final Iterable<TaskAssignmentScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUpdateManyWithoutTaskNestedInputToJson(this);
}

@_i1.jsonSerializable
class SessionUpdateManyWithoutTaskNestedInput implements _i1.JsonSerializable {
  const SessionUpdateManyWithoutTaskNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory SessionUpdateManyWithoutTaskNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionUpdateManyWithoutTaskNestedInputFromJson(json);

  final Iterable<SessionCreateWithoutTaskInput>? create;

  final Iterable<SessionCreateOrConnectWithoutTaskInput>? connectOrCreate;

  final Iterable<SessionUpsertWithWhereUniqueWithoutTaskInput>? upsert;

  final SessionCreateManyTaskInputEnvelope? createMany;

  final Iterable<SessionWhereUniqueInput>? set;

  final Iterable<SessionWhereUniqueInput>? disconnect;

  final Iterable<SessionWhereUniqueInput>? delete;

  final Iterable<SessionWhereUniqueInput>? connect;

  final Iterable<SessionUpdateWithWhereUniqueWithoutTaskInput>? update;

  final Iterable<SessionUpdateManyWithWhereWithoutTaskInput>? updateMany;

  final Iterable<SessionScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionUpdateManyWithoutTaskNestedInputToJson(this);
}

@_i1.jsonSerializable
class RecordUpdateManyWithoutTaskNestedInput implements _i1.JsonSerializable {
  const RecordUpdateManyWithoutTaskNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory RecordUpdateManyWithoutTaskNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUpdateManyWithoutTaskNestedInputFromJson(json);

  final Iterable<RecordCreateWithoutTaskInput>? create;

  final Iterable<RecordCreateOrConnectWithoutTaskInput>? connectOrCreate;

  final Iterable<RecordUpsertWithWhereUniqueWithoutTaskInput>? upsert;

  final RecordCreateManyTaskInputEnvelope? createMany;

  final Iterable<RecordWhereUniqueInput>? set;

  final Iterable<RecordWhereUniqueInput>? disconnect;

  final Iterable<RecordWhereUniqueInput>? delete;

  final Iterable<RecordWhereUniqueInput>? connect;

  final Iterable<RecordUpdateWithWhereUniqueWithoutTaskInput>? update;

  final Iterable<RecordUpdateManyWithWhereWithoutTaskInput>? updateMany;

  final Iterable<RecordScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUpdateManyWithoutTaskNestedInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedUpdateManyWithoutParentNestedInput
    implements _i1.JsonSerializable {
  const TaskUncheckedUpdateManyWithoutParentNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory TaskUncheckedUpdateManyWithoutParentNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUncheckedUpdateManyWithoutParentNestedInputFromJson(json);

  final Iterable<TaskCreateWithoutParentInput>? create;

  final Iterable<TaskCreateOrConnectWithoutParentInput>? connectOrCreate;

  final Iterable<TaskUpsertWithWhereUniqueWithoutParentInput>? upsert;

  final TaskCreateManyParentInputEnvelope? createMany;

  final Iterable<TaskWhereUniqueInput>? set;

  final Iterable<TaskWhereUniqueInput>? disconnect;

  final Iterable<TaskWhereUniqueInput>? delete;

  final Iterable<TaskWhereUniqueInput>? connect;

  final Iterable<TaskUpdateWithWhereUniqueWithoutParentInput>? update;

  final Iterable<TaskUpdateManyWithWhereWithoutParentInput>? updateMany;

  final Iterable<TaskScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUncheckedUpdateManyWithoutParentNestedInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetUncheckedUpdateManyWithoutTaskNestedInput
    implements _i1.JsonSerializable {
  const TaskAssetUncheckedUpdateManyWithoutTaskNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory TaskAssetUncheckedUpdateManyWithoutTaskNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssetUncheckedUpdateManyWithoutTaskNestedInputFromJson(json);

  final Iterable<TaskAssetCreateWithoutTaskInput>? create;

  final Iterable<TaskAssetCreateOrConnectWithoutTaskInput>? connectOrCreate;

  final Iterable<TaskAssetUpsertWithWhereUniqueWithoutTaskInput>? upsert;

  final TaskAssetCreateManyTaskInputEnvelope? createMany;

  final Iterable<TaskAssetWhereUniqueInput>? set;

  final Iterable<TaskAssetWhereUniqueInput>? disconnect;

  final Iterable<TaskAssetWhereUniqueInput>? delete;

  final Iterable<TaskAssetWhereUniqueInput>? connect;

  final Iterable<TaskAssetUpdateWithWhereUniqueWithoutTaskInput>? update;

  final Iterable<TaskAssetUpdateManyWithWhereWithoutTaskInput>? updateMany;

  final Iterable<TaskAssetScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetUncheckedUpdateManyWithoutTaskNestedInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInputFromJson(json);

  final Iterable<TaskAssignmentCreateWithoutTaskInput>? create;

  final Iterable<TaskAssignmentCreateOrConnectWithoutTaskInput>?
      connectOrCreate;

  final Iterable<TaskAssignmentUpsertWithWhereUniqueWithoutTaskInput>? upsert;

  final TaskAssignmentCreateManyTaskInputEnvelope? createMany;

  final Iterable<TaskAssignmentWhereUniqueInput>? set;

  final Iterable<TaskAssignmentWhereUniqueInput>? disconnect;

  final Iterable<TaskAssignmentWhereUniqueInput>? delete;

  final Iterable<TaskAssignmentWhereUniqueInput>? connect;

  final Iterable<TaskAssignmentUpdateWithWhereUniqueWithoutTaskInput>? update;

  final Iterable<TaskAssignmentUpdateManyWithWhereWithoutTaskInput>? updateMany;

  final Iterable<TaskAssignmentScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInputToJson(this);
}

@_i1.jsonSerializable
class SessionUncheckedUpdateManyWithoutTaskNestedInput
    implements _i1.JsonSerializable {
  const SessionUncheckedUpdateManyWithoutTaskNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory SessionUncheckedUpdateManyWithoutTaskNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionUncheckedUpdateManyWithoutTaskNestedInputFromJson(json);

  final Iterable<SessionCreateWithoutTaskInput>? create;

  final Iterable<SessionCreateOrConnectWithoutTaskInput>? connectOrCreate;

  final Iterable<SessionUpsertWithWhereUniqueWithoutTaskInput>? upsert;

  final SessionCreateManyTaskInputEnvelope? createMany;

  final Iterable<SessionWhereUniqueInput>? set;

  final Iterable<SessionWhereUniqueInput>? disconnect;

  final Iterable<SessionWhereUniqueInput>? delete;

  final Iterable<SessionWhereUniqueInput>? connect;

  final Iterable<SessionUpdateWithWhereUniqueWithoutTaskInput>? update;

  final Iterable<SessionUpdateManyWithWhereWithoutTaskInput>? updateMany;

  final Iterable<SessionScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionUncheckedUpdateManyWithoutTaskNestedInputToJson(this);
}

@_i1.jsonSerializable
class RecordUncheckedUpdateManyWithoutTaskNestedInput
    implements _i1.JsonSerializable {
  const RecordUncheckedUpdateManyWithoutTaskNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory RecordUncheckedUpdateManyWithoutTaskNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUncheckedUpdateManyWithoutTaskNestedInputFromJson(json);

  final Iterable<RecordCreateWithoutTaskInput>? create;

  final Iterable<RecordCreateOrConnectWithoutTaskInput>? connectOrCreate;

  final Iterable<RecordUpsertWithWhereUniqueWithoutTaskInput>? upsert;

  final RecordCreateManyTaskInputEnvelope? createMany;

  final Iterable<RecordWhereUniqueInput>? set;

  final Iterable<RecordWhereUniqueInput>? disconnect;

  final Iterable<RecordWhereUniqueInput>? delete;

  final Iterable<RecordWhereUniqueInput>? connect;

  final Iterable<RecordUpdateWithWhereUniqueWithoutTaskInput>? update;

  final Iterable<RecordUpdateManyWithWhereWithoutTaskInput>? updateMany;

  final Iterable<RecordScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUncheckedUpdateManyWithoutTaskNestedInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateNestedOneWithoutAssetsInput implements _i1.JsonSerializable {
  const TaskCreateNestedOneWithoutAssetsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory TaskCreateNestedOneWithoutAssetsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskCreateNestedOneWithoutAssetsInputFromJson(json);

  final TaskCreateWithoutAssetsInput? create;

  final TaskCreateOrConnectWithoutAssetsInput? connectOrCreate;

  final TaskWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskCreateNestedOneWithoutAssetsInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpdateOneRequiredWithoutAssetsNestedInput
    implements _i1.JsonSerializable {
  const TaskUpdateOneRequiredWithoutAssetsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  factory TaskUpdateOneRequiredWithoutAssetsNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUpdateOneRequiredWithoutAssetsNestedInputFromJson(json);

  final TaskCreateWithoutAssetsInput? create;

  final TaskCreateOrConnectWithoutAssetsInput? connectOrCreate;

  final TaskUpsertWithoutAssetsInput? upsert;

  final TaskWhereUniqueInput? connect;

  final TaskUpdateWithoutAssetsInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUpdateOneRequiredWithoutAssetsNestedInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateNestedOneWithoutChannelsInput
    implements _i1.JsonSerializable {
  const ProfileCreateNestedOneWithoutChannelsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory ProfileCreateNestedOneWithoutChannelsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateNestedOneWithoutChannelsInputFromJson(json);

  final ProfileCreateWithoutChannelsInput? create;

  final ProfileCreateOrConnectWithoutChannelsInput? connectOrCreate;

  final ProfileWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateNestedOneWithoutChannelsInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionCreateNestedManyWithoutChannelInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionCreateNestedManyWithoutChannelInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory ChannelSubscriptionCreateNestedManyWithoutChannelInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionCreateNestedManyWithoutChannelInputFromJson(json);

  final Iterable<ChannelSubscriptionCreateWithoutChannelInput>? create;

  final Iterable<ChannelSubscriptionCreateOrConnectWithoutChannelInput>?
      connectOrCreate;

  final ChannelSubscriptionCreateManyChannelInputEnvelope? createMany;

  final Iterable<ChannelSubscriptionWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionCreateNestedManyWithoutChannelInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateNestedManyWithoutChannelInput implements _i1.JsonSerializable {
  const TaskCreateNestedManyWithoutChannelInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory TaskCreateNestedManyWithoutChannelInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskCreateNestedManyWithoutChannelInputFromJson(json);

  final Iterable<TaskCreateWithoutChannelInput>? create;

  final Iterable<TaskCreateOrConnectWithoutChannelInput>? connectOrCreate;

  final TaskCreateManyChannelInputEnvelope? createMany;

  final Iterable<TaskWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskCreateNestedManyWithoutChannelInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUncheckedCreateNestedManyWithoutChannelInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionUncheckedCreateNestedManyWithoutChannelInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory ChannelSubscriptionUncheckedCreateNestedManyWithoutChannelInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionUncheckedCreateNestedManyWithoutChannelInputFromJson(
          json);

  final Iterable<ChannelSubscriptionCreateWithoutChannelInput>? create;

  final Iterable<ChannelSubscriptionCreateOrConnectWithoutChannelInput>?
      connectOrCreate;

  final ChannelSubscriptionCreateManyChannelInputEnvelope? createMany;

  final Iterable<ChannelSubscriptionWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionUncheckedCreateNestedManyWithoutChannelInputToJson(
          this);
}

@_i1.jsonSerializable
class TaskUncheckedCreateNestedManyWithoutChannelInput
    implements _i1.JsonSerializable {
  const TaskUncheckedCreateNestedManyWithoutChannelInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory TaskUncheckedCreateNestedManyWithoutChannelInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUncheckedCreateNestedManyWithoutChannelInputFromJson(json);

  final Iterable<TaskCreateWithoutChannelInput>? create;

  final Iterable<TaskCreateOrConnectWithoutChannelInput>? connectOrCreate;

  final TaskCreateManyChannelInputEnvelope? createMany;

  final Iterable<TaskWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUncheckedCreateNestedManyWithoutChannelInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpdateOneRequiredWithoutChannelsNestedInput
    implements _i1.JsonSerializable {
  const ProfileUpdateOneRequiredWithoutChannelsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  factory ProfileUpdateOneRequiredWithoutChannelsNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUpdateOneRequiredWithoutChannelsNestedInputFromJson(json);

  final ProfileCreateWithoutChannelsInput? create;

  final ProfileCreateOrConnectWithoutChannelsInput? connectOrCreate;

  final ProfileUpsertWithoutChannelsInput? upsert;

  final ProfileWhereUniqueInput? connect;

  final ProfileUpdateWithoutChannelsInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUpdateOneRequiredWithoutChannelsNestedInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUpdateManyWithoutChannelNestedInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionUpdateManyWithoutChannelNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory ChannelSubscriptionUpdateManyWithoutChannelNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionUpdateManyWithoutChannelNestedInputFromJson(json);

  final Iterable<ChannelSubscriptionCreateWithoutChannelInput>? create;

  final Iterable<ChannelSubscriptionCreateOrConnectWithoutChannelInput>?
      connectOrCreate;

  final Iterable<ChannelSubscriptionUpsertWithWhereUniqueWithoutChannelInput>?
      upsert;

  final ChannelSubscriptionCreateManyChannelInputEnvelope? createMany;

  final Iterable<ChannelSubscriptionWhereUniqueInput>? set;

  final Iterable<ChannelSubscriptionWhereUniqueInput>? disconnect;

  final Iterable<ChannelSubscriptionWhereUniqueInput>? delete;

  final Iterable<ChannelSubscriptionWhereUniqueInput>? connect;

  final Iterable<ChannelSubscriptionUpdateWithWhereUniqueWithoutChannelInput>?
      update;

  final Iterable<ChannelSubscriptionUpdateManyWithWhereWithoutChannelInput>?
      updateMany;

  final Iterable<ChannelSubscriptionScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionUpdateManyWithoutChannelNestedInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpdateManyWithoutChannelNestedInput implements _i1.JsonSerializable {
  const TaskUpdateManyWithoutChannelNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory TaskUpdateManyWithoutChannelNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUpdateManyWithoutChannelNestedInputFromJson(json);

  final Iterable<TaskCreateWithoutChannelInput>? create;

  final Iterable<TaskCreateOrConnectWithoutChannelInput>? connectOrCreate;

  final Iterable<TaskUpsertWithWhereUniqueWithoutChannelInput>? upsert;

  final TaskCreateManyChannelInputEnvelope? createMany;

  final Iterable<TaskWhereUniqueInput>? set;

  final Iterable<TaskWhereUniqueInput>? disconnect;

  final Iterable<TaskWhereUniqueInput>? delete;

  final Iterable<TaskWhereUniqueInput>? connect;

  final Iterable<TaskUpdateWithWhereUniqueWithoutChannelInput>? update;

  final Iterable<TaskUpdateManyWithWhereWithoutChannelInput>? updateMany;

  final Iterable<TaskScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUpdateManyWithoutChannelNestedInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUncheckedUpdateManyWithoutChannelNestedInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionUncheckedUpdateManyWithoutChannelNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory ChannelSubscriptionUncheckedUpdateManyWithoutChannelNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionUncheckedUpdateManyWithoutChannelNestedInputFromJson(
          json);

  final Iterable<ChannelSubscriptionCreateWithoutChannelInput>? create;

  final Iterable<ChannelSubscriptionCreateOrConnectWithoutChannelInput>?
      connectOrCreate;

  final Iterable<ChannelSubscriptionUpsertWithWhereUniqueWithoutChannelInput>?
      upsert;

  final ChannelSubscriptionCreateManyChannelInputEnvelope? createMany;

  final Iterable<ChannelSubscriptionWhereUniqueInput>? set;

  final Iterable<ChannelSubscriptionWhereUniqueInput>? disconnect;

  final Iterable<ChannelSubscriptionWhereUniqueInput>? delete;

  final Iterable<ChannelSubscriptionWhereUniqueInput>? connect;

  final Iterable<ChannelSubscriptionUpdateWithWhereUniqueWithoutChannelInput>?
      update;

  final Iterable<ChannelSubscriptionUpdateManyWithWhereWithoutChannelInput>?
      updateMany;

  final Iterable<ChannelSubscriptionScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionUncheckedUpdateManyWithoutChannelNestedInputToJson(
          this);
}

@_i1.jsonSerializable
class TaskUncheckedUpdateManyWithoutChannelNestedInput
    implements _i1.JsonSerializable {
  const TaskUncheckedUpdateManyWithoutChannelNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory TaskUncheckedUpdateManyWithoutChannelNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUncheckedUpdateManyWithoutChannelNestedInputFromJson(json);

  final Iterable<TaskCreateWithoutChannelInput>? create;

  final Iterable<TaskCreateOrConnectWithoutChannelInput>? connectOrCreate;

  final Iterable<TaskUpsertWithWhereUniqueWithoutChannelInput>? upsert;

  final TaskCreateManyChannelInputEnvelope? createMany;

  final Iterable<TaskWhereUniqueInput>? set;

  final Iterable<TaskWhereUniqueInput>? disconnect;

  final Iterable<TaskWhereUniqueInput>? delete;

  final Iterable<TaskWhereUniqueInput>? connect;

  final Iterable<TaskUpdateWithWhereUniqueWithoutChannelInput>? update;

  final Iterable<TaskUpdateManyWithWhereWithoutChannelInput>? updateMany;

  final Iterable<TaskScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUncheckedUpdateManyWithoutChannelNestedInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateNestedOneWithoutSessionsInput implements _i1.JsonSerializable {
  const TaskCreateNestedOneWithoutSessionsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory TaskCreateNestedOneWithoutSessionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskCreateNestedOneWithoutSessionsInputFromJson(json);

  final TaskCreateWithoutSessionsInput? create;

  final TaskCreateOrConnectWithoutSessionsInput? connectOrCreate;

  final TaskWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskCreateNestedOneWithoutSessionsInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleCreateNestedManyWithoutSessionInput
    implements _i1.JsonSerializable {
  const ScheduleCreateNestedManyWithoutSessionInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory ScheduleCreateNestedManyWithoutSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleCreateNestedManyWithoutSessionInputFromJson(json);

  final Iterable<ScheduleCreateWithoutSessionInput>? create;

  final Iterable<ScheduleCreateOrConnectWithoutSessionInput>? connectOrCreate;

  final ScheduleCreateManySessionInputEnvelope? createMany;

  final Iterable<ScheduleWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleCreateNestedManyWithoutSessionInputToJson(this);
}

@_i1.jsonSerializable
class RecordCreateNestedManyWithoutSessionInput
    implements _i1.JsonSerializable {
  const RecordCreateNestedManyWithoutSessionInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory RecordCreateNestedManyWithoutSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordCreateNestedManyWithoutSessionInputFromJson(json);

  final Iterable<RecordCreateWithoutSessionInput>? create;

  final Iterable<RecordCreateOrConnectWithoutSessionInput>? connectOrCreate;

  final RecordCreateManySessionInputEnvelope? createMany;

  final Iterable<RecordWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordCreateNestedManyWithoutSessionInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleUncheckedCreateNestedManyWithoutSessionInput
    implements _i1.JsonSerializable {
  const ScheduleUncheckedCreateNestedManyWithoutSessionInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory ScheduleUncheckedCreateNestedManyWithoutSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleUncheckedCreateNestedManyWithoutSessionInputFromJson(json);

  final Iterable<ScheduleCreateWithoutSessionInput>? create;

  final Iterable<ScheduleCreateOrConnectWithoutSessionInput>? connectOrCreate;

  final ScheduleCreateManySessionInputEnvelope? createMany;

  final Iterable<ScheduleWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleUncheckedCreateNestedManyWithoutSessionInputToJson(this);
}

@_i1.jsonSerializable
class RecordUncheckedCreateNestedManyWithoutSessionInput
    implements _i1.JsonSerializable {
  const RecordUncheckedCreateNestedManyWithoutSessionInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory RecordUncheckedCreateNestedManyWithoutSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUncheckedCreateNestedManyWithoutSessionInputFromJson(json);

  final Iterable<RecordCreateWithoutSessionInput>? create;

  final Iterable<RecordCreateOrConnectWithoutSessionInput>? connectOrCreate;

  final RecordCreateManySessionInputEnvelope? createMany;

  final Iterable<RecordWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUncheckedCreateNestedManyWithoutSessionInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpdateOneRequiredWithoutSessionsNestedInput
    implements _i1.JsonSerializable {
  const TaskUpdateOneRequiredWithoutSessionsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  factory TaskUpdateOneRequiredWithoutSessionsNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUpdateOneRequiredWithoutSessionsNestedInputFromJson(json);

  final TaskCreateWithoutSessionsInput? create;

  final TaskCreateOrConnectWithoutSessionsInput? connectOrCreate;

  final TaskUpsertWithoutSessionsInput? upsert;

  final TaskWhereUniqueInput? connect;

  final TaskUpdateWithoutSessionsInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUpdateOneRequiredWithoutSessionsNestedInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleUpdateManyWithoutSessionNestedInput
    implements _i1.JsonSerializable {
  const ScheduleUpdateManyWithoutSessionNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory ScheduleUpdateManyWithoutSessionNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleUpdateManyWithoutSessionNestedInputFromJson(json);

  final Iterable<ScheduleCreateWithoutSessionInput>? create;

  final Iterable<ScheduleCreateOrConnectWithoutSessionInput>? connectOrCreate;

  final Iterable<ScheduleUpsertWithWhereUniqueWithoutSessionInput>? upsert;

  final ScheduleCreateManySessionInputEnvelope? createMany;

  final Iterable<ScheduleWhereUniqueInput>? set;

  final Iterable<ScheduleWhereUniqueInput>? disconnect;

  final Iterable<ScheduleWhereUniqueInput>? delete;

  final Iterable<ScheduleWhereUniqueInput>? connect;

  final Iterable<ScheduleUpdateWithWhereUniqueWithoutSessionInput>? update;

  final Iterable<ScheduleUpdateManyWithWhereWithoutSessionInput>? updateMany;

  final Iterable<ScheduleScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleUpdateManyWithoutSessionNestedInputToJson(this);
}

@_i1.jsonSerializable
class RecordUpdateManyWithoutSessionNestedInput
    implements _i1.JsonSerializable {
  const RecordUpdateManyWithoutSessionNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory RecordUpdateManyWithoutSessionNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUpdateManyWithoutSessionNestedInputFromJson(json);

  final Iterable<RecordCreateWithoutSessionInput>? create;

  final Iterable<RecordCreateOrConnectWithoutSessionInput>? connectOrCreate;

  final Iterable<RecordUpsertWithWhereUniqueWithoutSessionInput>? upsert;

  final RecordCreateManySessionInputEnvelope? createMany;

  final Iterable<RecordWhereUniqueInput>? set;

  final Iterable<RecordWhereUniqueInput>? disconnect;

  final Iterable<RecordWhereUniqueInput>? delete;

  final Iterable<RecordWhereUniqueInput>? connect;

  final Iterable<RecordUpdateWithWhereUniqueWithoutSessionInput>? update;

  final Iterable<RecordUpdateManyWithWhereWithoutSessionInput>? updateMany;

  final Iterable<RecordScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUpdateManyWithoutSessionNestedInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleUncheckedUpdateManyWithoutSessionNestedInput
    implements _i1.JsonSerializable {
  const ScheduleUncheckedUpdateManyWithoutSessionNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory ScheduleUncheckedUpdateManyWithoutSessionNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleUncheckedUpdateManyWithoutSessionNestedInputFromJson(json);

  final Iterable<ScheduleCreateWithoutSessionInput>? create;

  final Iterable<ScheduleCreateOrConnectWithoutSessionInput>? connectOrCreate;

  final Iterable<ScheduleUpsertWithWhereUniqueWithoutSessionInput>? upsert;

  final ScheduleCreateManySessionInputEnvelope? createMany;

  final Iterable<ScheduleWhereUniqueInput>? set;

  final Iterable<ScheduleWhereUniqueInput>? disconnect;

  final Iterable<ScheduleWhereUniqueInput>? delete;

  final Iterable<ScheduleWhereUniqueInput>? connect;

  final Iterable<ScheduleUpdateWithWhereUniqueWithoutSessionInput>? update;

  final Iterable<ScheduleUpdateManyWithWhereWithoutSessionInput>? updateMany;

  final Iterable<ScheduleScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleUncheckedUpdateManyWithoutSessionNestedInputToJson(this);
}

@_i1.jsonSerializable
class RecordUncheckedUpdateManyWithoutSessionNestedInput
    implements _i1.JsonSerializable {
  const RecordUncheckedUpdateManyWithoutSessionNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory RecordUncheckedUpdateManyWithoutSessionNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUncheckedUpdateManyWithoutSessionNestedInputFromJson(json);

  final Iterable<RecordCreateWithoutSessionInput>? create;

  final Iterable<RecordCreateOrConnectWithoutSessionInput>? connectOrCreate;

  final Iterable<RecordUpsertWithWhereUniqueWithoutSessionInput>? upsert;

  final RecordCreateManySessionInputEnvelope? createMany;

  final Iterable<RecordWhereUniqueInput>? set;

  final Iterable<RecordWhereUniqueInput>? disconnect;

  final Iterable<RecordWhereUniqueInput>? delete;

  final Iterable<RecordWhereUniqueInput>? connect;

  final Iterable<RecordUpdateWithWhereUniqueWithoutSessionInput>? update;

  final Iterable<RecordUpdateManyWithWhereWithoutSessionInput>? updateMany;

  final Iterable<RecordScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUncheckedUpdateManyWithoutSessionNestedInputToJson(this);
}

@_i1.jsonSerializable
class SessionCreateNestedOneWithoutRecordsInput
    implements _i1.JsonSerializable {
  const SessionCreateNestedOneWithoutRecordsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory SessionCreateNestedOneWithoutRecordsInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionCreateNestedOneWithoutRecordsInputFromJson(json);

  final SessionCreateWithoutRecordsInput? create;

  final SessionCreateOrConnectWithoutRecordsInput? connectOrCreate;

  final SessionWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionCreateNestedOneWithoutRecordsInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateNestedOneWithoutRecordsInput implements _i1.JsonSerializable {
  const TaskCreateNestedOneWithoutRecordsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory TaskCreateNestedOneWithoutRecordsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskCreateNestedOneWithoutRecordsInputFromJson(json);

  final TaskCreateWithoutRecordsInput? create;

  final TaskCreateOrConnectWithoutRecordsInput? connectOrCreate;

  final TaskWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskCreateNestedOneWithoutRecordsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateNestedOneWithoutRecordsInput
    implements _i1.JsonSerializable {
  const ProfileCreateNestedOneWithoutRecordsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory ProfileCreateNestedOneWithoutRecordsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateNestedOneWithoutRecordsInputFromJson(json);

  final ProfileCreateWithoutRecordsInput? create;

  final ProfileCreateOrConnectWithoutRecordsInput? connectOrCreate;

  final ProfileWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateNestedOneWithoutRecordsInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentCreateNestedOneWithoutRecordInput
    implements _i1.JsonSerializable {
  const RecordAttachmentCreateNestedOneWithoutRecordInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory RecordAttachmentCreateNestedOneWithoutRecordInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentCreateNestedOneWithoutRecordInputFromJson(json);

  final RecordAttachmentCreateWithoutRecordInput? create;

  final RecordAttachmentCreateOrConnectWithoutRecordInput? connectOrCreate;

  final RecordAttachmentWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentCreateNestedOneWithoutRecordInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentUncheckedCreateNestedOneWithoutRecordInput
    implements _i1.JsonSerializable {
  const RecordAttachmentUncheckedCreateNestedOneWithoutRecordInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory RecordAttachmentUncheckedCreateNestedOneWithoutRecordInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentUncheckedCreateNestedOneWithoutRecordInputFromJson(
          json);

  final RecordAttachmentCreateWithoutRecordInput? create;

  final RecordAttachmentCreateOrConnectWithoutRecordInput? connectOrCreate;

  final RecordAttachmentWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentUncheckedCreateNestedOneWithoutRecordInputToJson(this);
}

@_i1.jsonSerializable
class SessionUpdateOneRequiredWithoutRecordsNestedInput
    implements _i1.JsonSerializable {
  const SessionUpdateOneRequiredWithoutRecordsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  factory SessionUpdateOneRequiredWithoutRecordsNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionUpdateOneRequiredWithoutRecordsNestedInputFromJson(json);

  final SessionCreateWithoutRecordsInput? create;

  final SessionCreateOrConnectWithoutRecordsInput? connectOrCreate;

  final SessionUpsertWithoutRecordsInput? upsert;

  final SessionWhereUniqueInput? connect;

  final SessionUpdateWithoutRecordsInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionUpdateOneRequiredWithoutRecordsNestedInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpdateOneRequiredWithoutRecordsNestedInput
    implements _i1.JsonSerializable {
  const TaskUpdateOneRequiredWithoutRecordsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  factory TaskUpdateOneRequiredWithoutRecordsNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUpdateOneRequiredWithoutRecordsNestedInputFromJson(json);

  final TaskCreateWithoutRecordsInput? create;

  final TaskCreateOrConnectWithoutRecordsInput? connectOrCreate;

  final TaskUpsertWithoutRecordsInput? upsert;

  final TaskWhereUniqueInput? connect;

  final TaskUpdateWithoutRecordsInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUpdateOneRequiredWithoutRecordsNestedInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpdateOneRequiredWithoutRecordsNestedInput
    implements _i1.JsonSerializable {
  const ProfileUpdateOneRequiredWithoutRecordsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  factory ProfileUpdateOneRequiredWithoutRecordsNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUpdateOneRequiredWithoutRecordsNestedInputFromJson(json);

  final ProfileCreateWithoutRecordsInput? create;

  final ProfileCreateOrConnectWithoutRecordsInput? connectOrCreate;

  final ProfileUpsertWithoutRecordsInput? upsert;

  final ProfileWhereUniqueInput? connect;

  final ProfileUpdateWithoutRecordsInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUpdateOneRequiredWithoutRecordsNestedInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentUpdateOneWithoutRecordNestedInput
    implements _i1.JsonSerializable {
  const RecordAttachmentUpdateOneWithoutRecordNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  factory RecordAttachmentUpdateOneWithoutRecordNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentUpdateOneWithoutRecordNestedInputFromJson(json);

  final RecordAttachmentCreateWithoutRecordInput? create;

  final RecordAttachmentCreateOrConnectWithoutRecordInput? connectOrCreate;

  final RecordAttachmentUpsertWithoutRecordInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final RecordAttachmentWhereUniqueInput? connect;

  final RecordAttachmentUpdateWithoutRecordInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentUpdateOneWithoutRecordNestedInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentUncheckedUpdateOneWithoutRecordNestedInput
    implements _i1.JsonSerializable {
  const RecordAttachmentUncheckedUpdateOneWithoutRecordNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  factory RecordAttachmentUncheckedUpdateOneWithoutRecordNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentUncheckedUpdateOneWithoutRecordNestedInputFromJson(
          json);

  final RecordAttachmentCreateWithoutRecordInput? create;

  final RecordAttachmentCreateOrConnectWithoutRecordInput? connectOrCreate;

  final RecordAttachmentUpsertWithoutRecordInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final RecordAttachmentWhereUniqueInput? connect;

  final RecordAttachmentUpdateWithoutRecordInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentUncheckedUpdateOneWithoutRecordNestedInputToJson(this);
}

@_i1.jsonSerializable
class RecordCreateNestedOneWithoutAttachmentInput
    implements _i1.JsonSerializable {
  const RecordCreateNestedOneWithoutAttachmentInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory RecordCreateNestedOneWithoutAttachmentInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordCreateNestedOneWithoutAttachmentInputFromJson(json);

  final RecordCreateWithoutAttachmentInput? create;

  final RecordCreateOrConnectWithoutAttachmentInput? connectOrCreate;

  final RecordWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordCreateNestedOneWithoutAttachmentInputToJson(this);
}

@_i1.jsonSerializable
class RecordUpdateOneRequiredWithoutAttachmentNestedInput
    implements _i1.JsonSerializable {
  const RecordUpdateOneRequiredWithoutAttachmentNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  factory RecordUpdateOneRequiredWithoutAttachmentNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUpdateOneRequiredWithoutAttachmentNestedInputFromJson(json);

  final RecordCreateWithoutAttachmentInput? create;

  final RecordCreateOrConnectWithoutAttachmentInput? connectOrCreate;

  final RecordUpsertWithoutAttachmentInput? upsert;

  final RecordWhereUniqueInput? connect;

  final RecordUpdateWithoutAttachmentInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUpdateOneRequiredWithoutAttachmentNestedInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateNestedOneWithoutCategoriesInput
    implements _i1.JsonSerializable {
  const ProfileCreateNestedOneWithoutCategoriesInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory ProfileCreateNestedOneWithoutCategoriesInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateNestedOneWithoutCategoriesInputFromJson(json);

  final ProfileCreateWithoutCategoriesInput? create;

  final ProfileCreateOrConnectWithoutCategoriesInput? connectOrCreate;

  final ProfileWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateNestedOneWithoutCategoriesInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentCreateNestedManyWithoutCategoryInput
    implements _i1.JsonSerializable {
  const TaskAssignmentCreateNestedManyWithoutCategoryInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory TaskAssignmentCreateNestedManyWithoutCategoryInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentCreateNestedManyWithoutCategoryInputFromJson(json);

  final Iterable<TaskAssignmentCreateWithoutCategoryInput>? create;

  final Iterable<TaskAssignmentCreateOrConnectWithoutCategoryInput>?
      connectOrCreate;

  final TaskAssignmentCreateManyCategoryInputEnvelope? createMany;

  final Iterable<TaskAssignmentWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentCreateNestedManyWithoutCategoryInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUncheckedCreateNestedManyWithoutCategoryInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUncheckedCreateNestedManyWithoutCategoryInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory TaskAssignmentUncheckedCreateNestedManyWithoutCategoryInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUncheckedCreateNestedManyWithoutCategoryInputFromJson(
          json);

  final Iterable<TaskAssignmentCreateWithoutCategoryInput>? create;

  final Iterable<TaskAssignmentCreateOrConnectWithoutCategoryInput>?
      connectOrCreate;

  final TaskAssignmentCreateManyCategoryInputEnvelope? createMany;

  final Iterable<TaskAssignmentWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUncheckedCreateNestedManyWithoutCategoryInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpdateOneRequiredWithoutCategoriesNestedInput
    implements _i1.JsonSerializable {
  const ProfileUpdateOneRequiredWithoutCategoriesNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  factory ProfileUpdateOneRequiredWithoutCategoriesNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUpdateOneRequiredWithoutCategoriesNestedInputFromJson(json);

  final ProfileCreateWithoutCategoriesInput? create;

  final ProfileCreateOrConnectWithoutCategoriesInput? connectOrCreate;

  final ProfileUpsertWithoutCategoriesInput? upsert;

  final ProfileWhereUniqueInput? connect;

  final ProfileUpdateWithoutCategoriesInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUpdateOneRequiredWithoutCategoriesNestedInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUpdateManyWithoutCategoryNestedInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUpdateManyWithoutCategoryNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory TaskAssignmentUpdateManyWithoutCategoryNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUpdateManyWithoutCategoryNestedInputFromJson(json);

  final Iterable<TaskAssignmentCreateWithoutCategoryInput>? create;

  final Iterable<TaskAssignmentCreateOrConnectWithoutCategoryInput>?
      connectOrCreate;

  final Iterable<TaskAssignmentUpsertWithWhereUniqueWithoutCategoryInput>?
      upsert;

  final TaskAssignmentCreateManyCategoryInputEnvelope? createMany;

  final Iterable<TaskAssignmentWhereUniqueInput>? set;

  final Iterable<TaskAssignmentWhereUniqueInput>? disconnect;

  final Iterable<TaskAssignmentWhereUniqueInput>? delete;

  final Iterable<TaskAssignmentWhereUniqueInput>? connect;

  final Iterable<TaskAssignmentUpdateWithWhereUniqueWithoutCategoryInput>?
      update;

  final Iterable<TaskAssignmentUpdateManyWithWhereWithoutCategoryInput>?
      updateMany;

  final Iterable<TaskAssignmentScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUpdateManyWithoutCategoryNestedInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUncheckedUpdateManyWithoutCategoryNestedInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUncheckedUpdateManyWithoutCategoryNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory TaskAssignmentUncheckedUpdateManyWithoutCategoryNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUncheckedUpdateManyWithoutCategoryNestedInputFromJson(
          json);

  final Iterable<TaskAssignmentCreateWithoutCategoryInput>? create;

  final Iterable<TaskAssignmentCreateOrConnectWithoutCategoryInput>?
      connectOrCreate;

  final Iterable<TaskAssignmentUpsertWithWhereUniqueWithoutCategoryInput>?
      upsert;

  final TaskAssignmentCreateManyCategoryInputEnvelope? createMany;

  final Iterable<TaskAssignmentWhereUniqueInput>? set;

  final Iterable<TaskAssignmentWhereUniqueInput>? disconnect;

  final Iterable<TaskAssignmentWhereUniqueInput>? delete;

  final Iterable<TaskAssignmentWhereUniqueInput>? connect;

  final Iterable<TaskAssignmentUpdateWithWhereUniqueWithoutCategoryInput>?
      update;

  final Iterable<TaskAssignmentUpdateManyWithWhereWithoutCategoryInput>?
      updateMany;

  final Iterable<TaskAssignmentScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUncheckedUpdateManyWithoutCategoryNestedInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateNestedOneWithoutTagsInput implements _i1.JsonSerializable {
  const ProfileCreateNestedOneWithoutTagsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory ProfileCreateNestedOneWithoutTagsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateNestedOneWithoutTagsInputFromJson(json);

  final ProfileCreateWithoutTagsInput? create;

  final ProfileCreateOrConnectWithoutTagsInput? connectOrCreate;

  final ProfileWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateNestedOneWithoutTagsInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsCreateNestedManyWithoutTagInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsCreateNestedManyWithoutTagInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory TaskAssignmentTagsCreateNestedManyWithoutTagInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsCreateNestedManyWithoutTagInputFromJson(json);

  final Iterable<TaskAssignmentTagsCreateWithoutTagInput>? create;

  final Iterable<TaskAssignmentTagsCreateOrConnectWithoutTagInput>?
      connectOrCreate;

  final TaskAssignmentTagsCreateManyTagInputEnvelope? createMany;

  final Iterable<TaskAssignmentTagsWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsCreateNestedManyWithoutTagInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUncheckedCreateNestedManyWithoutTagInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsUncheckedCreateNestedManyWithoutTagInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory TaskAssignmentTagsUncheckedCreateNestedManyWithoutTagInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUncheckedCreateNestedManyWithoutTagInputFromJson(
          json);

  final Iterable<TaskAssignmentTagsCreateWithoutTagInput>? create;

  final Iterable<TaskAssignmentTagsCreateOrConnectWithoutTagInput>?
      connectOrCreate;

  final TaskAssignmentTagsCreateManyTagInputEnvelope? createMany;

  final Iterable<TaskAssignmentTagsWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsUncheckedCreateNestedManyWithoutTagInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpdateOneRequiredWithoutTagsNestedInput
    implements _i1.JsonSerializable {
  const ProfileUpdateOneRequiredWithoutTagsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  factory ProfileUpdateOneRequiredWithoutTagsNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUpdateOneRequiredWithoutTagsNestedInputFromJson(json);

  final ProfileCreateWithoutTagsInput? create;

  final ProfileCreateOrConnectWithoutTagsInput? connectOrCreate;

  final ProfileUpsertWithoutTagsInput? upsert;

  final ProfileWhereUniqueInput? connect;

  final ProfileUpdateWithoutTagsInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUpdateOneRequiredWithoutTagsNestedInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUpdateManyWithoutTagNestedInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsUpdateManyWithoutTagNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory TaskAssignmentTagsUpdateManyWithoutTagNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUpdateManyWithoutTagNestedInputFromJson(json);

  final Iterable<TaskAssignmentTagsCreateWithoutTagInput>? create;

  final Iterable<TaskAssignmentTagsCreateOrConnectWithoutTagInput>?
      connectOrCreate;

  final Iterable<TaskAssignmentTagsUpsertWithWhereUniqueWithoutTagInput>?
      upsert;

  final TaskAssignmentTagsCreateManyTagInputEnvelope? createMany;

  final Iterable<TaskAssignmentTagsWhereUniqueInput>? set;

  final Iterable<TaskAssignmentTagsWhereUniqueInput>? disconnect;

  final Iterable<TaskAssignmentTagsWhereUniqueInput>? delete;

  final Iterable<TaskAssignmentTagsWhereUniqueInput>? connect;

  final Iterable<TaskAssignmentTagsUpdateWithWhereUniqueWithoutTagInput>?
      update;

  final Iterable<TaskAssignmentTagsUpdateManyWithWhereWithoutTagInput>?
      updateMany;

  final Iterable<TaskAssignmentTagsScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsUpdateManyWithoutTagNestedInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUncheckedUpdateManyWithoutTagNestedInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsUncheckedUpdateManyWithoutTagNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory TaskAssignmentTagsUncheckedUpdateManyWithoutTagNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUncheckedUpdateManyWithoutTagNestedInputFromJson(
          json);

  final Iterable<TaskAssignmentTagsCreateWithoutTagInput>? create;

  final Iterable<TaskAssignmentTagsCreateOrConnectWithoutTagInput>?
      connectOrCreate;

  final Iterable<TaskAssignmentTagsUpsertWithWhereUniqueWithoutTagInput>?
      upsert;

  final TaskAssignmentTagsCreateManyTagInputEnvelope? createMany;

  final Iterable<TaskAssignmentTagsWhereUniqueInput>? set;

  final Iterable<TaskAssignmentTagsWhereUniqueInput>? disconnect;

  final Iterable<TaskAssignmentTagsWhereUniqueInput>? delete;

  final Iterable<TaskAssignmentTagsWhereUniqueInput>? connect;

  final Iterable<TaskAssignmentTagsUpdateWithWhereUniqueWithoutTagInput>?
      update;

  final Iterable<TaskAssignmentTagsUpdateManyWithWhereWithoutTagInput>?
      updateMany;

  final Iterable<TaskAssignmentTagsScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsUncheckedUpdateManyWithoutTagNestedInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateNestedOneWithoutAssignmentsInput
    implements _i1.JsonSerializable {
  const TaskCreateNestedOneWithoutAssignmentsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory TaskCreateNestedOneWithoutAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskCreateNestedOneWithoutAssignmentsInputFromJson(json);

  final TaskCreateWithoutAssignmentsInput? create;

  final TaskCreateOrConnectWithoutAssignmentsInput? connectOrCreate;

  final TaskWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskCreateNestedOneWithoutAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateNestedOneWithoutTaskAssignmentsInput
    implements _i1.JsonSerializable {
  const ProfileCreateNestedOneWithoutTaskAssignmentsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory ProfileCreateNestedOneWithoutTaskAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateNestedOneWithoutTaskAssignmentsInputFromJson(json);

  final ProfileCreateWithoutTaskAssignmentsInput? create;

  final ProfileCreateOrConnectWithoutTaskAssignmentsInput? connectOrCreate;

  final ProfileWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateNestedOneWithoutTaskAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class CategoryCreateNestedOneWithoutAssignmentsInput
    implements _i1.JsonSerializable {
  const CategoryCreateNestedOneWithoutAssignmentsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory CategoryCreateNestedOneWithoutAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryCreateNestedOneWithoutAssignmentsInputFromJson(json);

  final CategoryCreateWithoutAssignmentsInput? create;

  final CategoryCreateOrConnectWithoutAssignmentsInput? connectOrCreate;

  final CategoryWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryCreateNestedOneWithoutAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsCreateNestedManyWithoutAssignmentInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsCreateNestedManyWithoutAssignmentInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory TaskAssignmentTagsCreateNestedManyWithoutAssignmentInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsCreateNestedManyWithoutAssignmentInputFromJson(json);

  final Iterable<TaskAssignmentTagsCreateWithoutAssignmentInput>? create;

  final Iterable<TaskAssignmentTagsCreateOrConnectWithoutAssignmentInput>?
      connectOrCreate;

  final TaskAssignmentTagsCreateManyAssignmentInputEnvelope? createMany;

  final Iterable<TaskAssignmentTagsWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsCreateNestedManyWithoutAssignmentInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUncheckedCreateNestedManyWithoutAssignmentInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsUncheckedCreateNestedManyWithoutAssignmentInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory TaskAssignmentTagsUncheckedCreateNestedManyWithoutAssignmentInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUncheckedCreateNestedManyWithoutAssignmentInputFromJson(
          json);

  final Iterable<TaskAssignmentTagsCreateWithoutAssignmentInput>? create;

  final Iterable<TaskAssignmentTagsCreateOrConnectWithoutAssignmentInput>?
      connectOrCreate;

  final TaskAssignmentTagsCreateManyAssignmentInputEnvelope? createMany;

  final Iterable<TaskAssignmentTagsWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsUncheckedCreateNestedManyWithoutAssignmentInputToJson(
          this);
}

@_i1.jsonSerializable
class EnumTaskAssignmentStatusFieldUpdateOperationsInput
    implements _i1.JsonSerializable {
  const EnumTaskAssignmentStatusFieldUpdateOperationsInput({this.set});

  factory EnumTaskAssignmentStatusFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$EnumTaskAssignmentStatusFieldUpdateOperationsInputFromJson(json);

  final TaskAssignmentStatus? set;

  @override
  Map<String, dynamic> toJson() =>
      _$EnumTaskAssignmentStatusFieldUpdateOperationsInputToJson(this);
}

@_i1.jsonSerializable
class EnumTaskPriorityFieldUpdateOperationsInput
    implements _i1.JsonSerializable {
  const EnumTaskPriorityFieldUpdateOperationsInput({this.set});

  factory EnumTaskPriorityFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$EnumTaskPriorityFieldUpdateOperationsInputFromJson(json);

  final TaskPriority? set;

  @override
  Map<String, dynamic> toJson() =>
      _$EnumTaskPriorityFieldUpdateOperationsInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpdateOneRequiredWithoutAssignmentsNestedInput
    implements _i1.JsonSerializable {
  const TaskUpdateOneRequiredWithoutAssignmentsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  factory TaskUpdateOneRequiredWithoutAssignmentsNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUpdateOneRequiredWithoutAssignmentsNestedInputFromJson(json);

  final TaskCreateWithoutAssignmentsInput? create;

  final TaskCreateOrConnectWithoutAssignmentsInput? connectOrCreate;

  final TaskUpsertWithoutAssignmentsInput? upsert;

  final TaskWhereUniqueInput? connect;

  final TaskUpdateWithoutAssignmentsInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUpdateOneRequiredWithoutAssignmentsNestedInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpdateOneRequiredWithoutTaskAssignmentsNestedInput
    implements _i1.JsonSerializable {
  const ProfileUpdateOneRequiredWithoutTaskAssignmentsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  factory ProfileUpdateOneRequiredWithoutTaskAssignmentsNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUpdateOneRequiredWithoutTaskAssignmentsNestedInputFromJson(json);

  final ProfileCreateWithoutTaskAssignmentsInput? create;

  final ProfileCreateOrConnectWithoutTaskAssignmentsInput? connectOrCreate;

  final ProfileUpsertWithoutTaskAssignmentsInput? upsert;

  final ProfileWhereUniqueInput? connect;

  final ProfileUpdateWithoutTaskAssignmentsInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUpdateOneRequiredWithoutTaskAssignmentsNestedInputToJson(this);
}

@_i1.jsonSerializable
class CategoryUpdateOneWithoutAssignmentsNestedInput
    implements _i1.JsonSerializable {
  const CategoryUpdateOneWithoutAssignmentsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  factory CategoryUpdateOneWithoutAssignmentsNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryUpdateOneWithoutAssignmentsNestedInputFromJson(json);

  final CategoryCreateWithoutAssignmentsInput? create;

  final CategoryCreateOrConnectWithoutAssignmentsInput? connectOrCreate;

  final CategoryUpsertWithoutAssignmentsInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final CategoryWhereUniqueInput? connect;

  final CategoryUpdateWithoutAssignmentsInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryUpdateOneWithoutAssignmentsNestedInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUpdateManyWithoutAssignmentNestedInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsUpdateManyWithoutAssignmentNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory TaskAssignmentTagsUpdateManyWithoutAssignmentNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUpdateManyWithoutAssignmentNestedInputFromJson(json);

  final Iterable<TaskAssignmentTagsCreateWithoutAssignmentInput>? create;

  final Iterable<TaskAssignmentTagsCreateOrConnectWithoutAssignmentInput>?
      connectOrCreate;

  final Iterable<TaskAssignmentTagsUpsertWithWhereUniqueWithoutAssignmentInput>?
      upsert;

  final TaskAssignmentTagsCreateManyAssignmentInputEnvelope? createMany;

  final Iterable<TaskAssignmentTagsWhereUniqueInput>? set;

  final Iterable<TaskAssignmentTagsWhereUniqueInput>? disconnect;

  final Iterable<TaskAssignmentTagsWhereUniqueInput>? delete;

  final Iterable<TaskAssignmentTagsWhereUniqueInput>? connect;

  final Iterable<TaskAssignmentTagsUpdateWithWhereUniqueWithoutAssignmentInput>?
      update;

  final Iterable<TaskAssignmentTagsUpdateManyWithWhereWithoutAssignmentInput>?
      updateMany;

  final Iterable<TaskAssignmentTagsScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsUpdateManyWithoutAssignmentNestedInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUncheckedUpdateManyWithoutAssignmentNestedInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsUncheckedUpdateManyWithoutAssignmentNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory TaskAssignmentTagsUncheckedUpdateManyWithoutAssignmentNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUncheckedUpdateManyWithoutAssignmentNestedInputFromJson(
          json);

  final Iterable<TaskAssignmentTagsCreateWithoutAssignmentInput>? create;

  final Iterable<TaskAssignmentTagsCreateOrConnectWithoutAssignmentInput>?
      connectOrCreate;

  final Iterable<TaskAssignmentTagsUpsertWithWhereUniqueWithoutAssignmentInput>?
      upsert;

  final TaskAssignmentTagsCreateManyAssignmentInputEnvelope? createMany;

  final Iterable<TaskAssignmentTagsWhereUniqueInput>? set;

  final Iterable<TaskAssignmentTagsWhereUniqueInput>? disconnect;

  final Iterable<TaskAssignmentTagsWhereUniqueInput>? delete;

  final Iterable<TaskAssignmentTagsWhereUniqueInput>? connect;

  final Iterable<TaskAssignmentTagsUpdateWithWhereUniqueWithoutAssignmentInput>?
      update;

  final Iterable<TaskAssignmentTagsUpdateManyWithWhereWithoutAssignmentInput>?
      updateMany;

  final Iterable<TaskAssignmentTagsScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsUncheckedUpdateManyWithoutAssignmentNestedInputToJson(
          this);
}

@_i1.jsonSerializable
class TaskAssignmentCreateNestedOneWithoutTagsInput
    implements _i1.JsonSerializable {
  const TaskAssignmentCreateNestedOneWithoutTagsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory TaskAssignmentCreateNestedOneWithoutTagsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentCreateNestedOneWithoutTagsInputFromJson(json);

  final TaskAssignmentCreateWithoutTagsInput? create;

  final TaskAssignmentCreateOrConnectWithoutTagsInput? connectOrCreate;

  final TaskAssignmentWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentCreateNestedOneWithoutTagsInputToJson(this);
}

@_i1.jsonSerializable
class TagCreateNestedOneWithoutAssignmentsInput
    implements _i1.JsonSerializable {
  const TagCreateNestedOneWithoutAssignmentsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory TagCreateNestedOneWithoutAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TagCreateNestedOneWithoutAssignmentsInputFromJson(json);

  final TagCreateWithoutAssignmentsInput? create;

  final TagCreateOrConnectWithoutAssignmentsInput? connectOrCreate;

  final TagWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$TagCreateNestedOneWithoutAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUpdateOneRequiredWithoutTagsNestedInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUpdateOneRequiredWithoutTagsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  factory TaskAssignmentUpdateOneRequiredWithoutTagsNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUpdateOneRequiredWithoutTagsNestedInputFromJson(json);

  final TaskAssignmentCreateWithoutTagsInput? create;

  final TaskAssignmentCreateOrConnectWithoutTagsInput? connectOrCreate;

  final TaskAssignmentUpsertWithoutTagsInput? upsert;

  final TaskAssignmentWhereUniqueInput? connect;

  final TaskAssignmentUpdateWithoutTagsInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUpdateOneRequiredWithoutTagsNestedInputToJson(this);
}

@_i1.jsonSerializable
class TagUpdateOneRequiredWithoutAssignmentsNestedInput
    implements _i1.JsonSerializable {
  const TagUpdateOneRequiredWithoutAssignmentsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  factory TagUpdateOneRequiredWithoutAssignmentsNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$TagUpdateOneRequiredWithoutAssignmentsNestedInputFromJson(json);

  final TagCreateWithoutAssignmentsInput? create;

  final TagCreateOrConnectWithoutAssignmentsInput? connectOrCreate;

  final TagUpsertWithoutAssignmentsInput? upsert;

  final TagWhereUniqueInput? connect;

  final TagUpdateWithoutAssignmentsInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$TagUpdateOneRequiredWithoutAssignmentsNestedInputToJson(this);
}

@_i1.jsonSerializable
class ChannelCreateNestedOneWithoutSubscriptionsInput
    implements _i1.JsonSerializable {
  const ChannelCreateNestedOneWithoutSubscriptionsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory ChannelCreateNestedOneWithoutSubscriptionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelCreateNestedOneWithoutSubscriptionsInputFromJson(json);

  final ChannelCreateWithoutSubscriptionsInput? create;

  final ChannelCreateOrConnectWithoutSubscriptionsInput? connectOrCreate;

  final ChannelWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelCreateNestedOneWithoutSubscriptionsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateNestedOneWithoutChannelSubscriptionsInput
    implements _i1.JsonSerializable {
  const ProfileCreateNestedOneWithoutChannelSubscriptionsInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory ProfileCreateNestedOneWithoutChannelSubscriptionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateNestedOneWithoutChannelSubscriptionsInputFromJson(json);

  final ProfileCreateWithoutChannelSubscriptionsInput? create;

  final ProfileCreateOrConnectWithoutChannelSubscriptionsInput? connectOrCreate;

  final ProfileWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateNestedOneWithoutChannelSubscriptionsInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUpdateOneRequiredWithoutSubscriptionsNestedInput
    implements _i1.JsonSerializable {
  const ChannelUpdateOneRequiredWithoutSubscriptionsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  factory ChannelUpdateOneRequiredWithoutSubscriptionsNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelUpdateOneRequiredWithoutSubscriptionsNestedInputFromJson(json);

  final ChannelCreateWithoutSubscriptionsInput? create;

  final ChannelCreateOrConnectWithoutSubscriptionsInput? connectOrCreate;

  final ChannelUpsertWithoutSubscriptionsInput? upsert;

  final ChannelWhereUniqueInput? connect;

  final ChannelUpdateWithoutSubscriptionsInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelUpdateOneRequiredWithoutSubscriptionsNestedInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpdateOneRequiredWithoutChannelSubscriptionsNestedInput
    implements _i1.JsonSerializable {
  const ProfileUpdateOneRequiredWithoutChannelSubscriptionsNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  factory ProfileUpdateOneRequiredWithoutChannelSubscriptionsNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUpdateOneRequiredWithoutChannelSubscriptionsNestedInputFromJson(
          json);

  final ProfileCreateWithoutChannelSubscriptionsInput? create;

  final ProfileCreateOrConnectWithoutChannelSubscriptionsInput? connectOrCreate;

  final ProfileUpsertWithoutChannelSubscriptionsInput? upsert;

  final ProfileWhereUniqueInput? connect;

  final ProfileUpdateWithoutChannelSubscriptionsInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUpdateOneRequiredWithoutChannelSubscriptionsNestedInputToJson(
          this);
}

@_i1.jsonSerializable
class SessionCreateNestedOneWithoutSchedulesInput
    implements _i1.JsonSerializable {
  const SessionCreateNestedOneWithoutSchedulesInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory SessionCreateNestedOneWithoutSchedulesInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionCreateNestedOneWithoutSchedulesInputFromJson(json);

  final SessionCreateWithoutSchedulesInput? create;

  final SessionCreateOrConnectWithoutSchedulesInput? connectOrCreate;

  final SessionWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionCreateNestedOneWithoutSchedulesInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateNestedOneWithoutSchedulesInput
    implements _i1.JsonSerializable {
  const ProfileCreateNestedOneWithoutSchedulesInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory ProfileCreateNestedOneWithoutSchedulesInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateNestedOneWithoutSchedulesInputFromJson(json);

  final ProfileCreateWithoutSchedulesInput? create;

  final ProfileCreateOrConnectWithoutSchedulesInput? connectOrCreate;

  final ProfileWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateNestedOneWithoutSchedulesInputToJson(this);
}

@_i1.jsonSerializable
class SessionUpdateOneRequiredWithoutSchedulesNestedInput
    implements _i1.JsonSerializable {
  const SessionUpdateOneRequiredWithoutSchedulesNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  factory SessionUpdateOneRequiredWithoutSchedulesNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionUpdateOneRequiredWithoutSchedulesNestedInputFromJson(json);

  final SessionCreateWithoutSchedulesInput? create;

  final SessionCreateOrConnectWithoutSchedulesInput? connectOrCreate;

  final SessionUpsertWithoutSchedulesInput? upsert;

  final SessionWhereUniqueInput? connect;

  final SessionUpdateWithoutSchedulesInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionUpdateOneRequiredWithoutSchedulesNestedInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpdateOneRequiredWithoutSchedulesNestedInput
    implements _i1.JsonSerializable {
  const ProfileUpdateOneRequiredWithoutSchedulesNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.connect,
    this.update,
  });

  factory ProfileUpdateOneRequiredWithoutSchedulesNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUpdateOneRequiredWithoutSchedulesNestedInputFromJson(json);

  final ProfileCreateWithoutSchedulesInput? create;

  final ProfileCreateOrConnectWithoutSchedulesInput? connectOrCreate;

  final ProfileUpsertWithoutSchedulesInput? upsert;

  final ProfileWhereUniqueInput? connect;

  final ProfileUpdateWithoutSchedulesInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUpdateOneRequiredWithoutSchedulesNestedInputToJson(this);
}

@_i1.jsonSerializable
class NullableIntFieldUpdateOperationsInput implements _i1.JsonSerializable {
  const NullableIntFieldUpdateOperationsInput({
    this.set,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  factory NullableIntFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$NullableIntFieldUpdateOperationsInputFromJson(json);

  final int? set;

  final int? increment;

  final int? decrement;

  final int? multiply;

  final int? divide;

  @override
  Map<String, dynamic> toJson() =>
      _$NullableIntFieldUpdateOperationsInputToJson(this);
}

@_i1.jsonSerializable
class NestedIntFilter implements _i1.JsonSerializable {
  const NestedIntFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory NestedIntFilter.fromJson(Map<String, dynamic> json) =>
      _$NestedIntFilterFromJson(json);

  final int? equals;

  @JsonKey(name: r'in')
  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final NestedIntFilter? not;

  @override
  Map<String, dynamic> toJson() => _$NestedIntFilterToJson(this);
}

@_i1.jsonSerializable
class NestedStringFilter implements _i1.JsonSerializable {
  const NestedStringFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
  });

  factory NestedStringFilter.fromJson(Map<String, dynamic> json) =>
      _$NestedStringFilterFromJson(json);

  final String? equals;

  @JsonKey(name: r'in')
  final Iterable<String>? $in;

  final Iterable<String>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final NestedStringFilter? not;

  @override
  Map<String, dynamic> toJson() => _$NestedStringFilterToJson(this);
}

@_i1.jsonSerializable
class NestedStringNullableFilter implements _i1.JsonSerializable {
  const NestedStringNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
  });

  factory NestedStringNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$NestedStringNullableFilterFromJson(json);

  final String? equals;

  @JsonKey(name: r'in')
  final Iterable<String>? $in;

  final Iterable<String>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final NestedStringNullableFilter? not;

  @override
  Map<String, dynamic> toJson() => _$NestedStringNullableFilterToJson(this);
}

@_i1.jsonSerializable
class NestedIntWithAggregatesFilter implements _i1.JsonSerializable {
  const NestedIntWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory NestedIntWithAggregatesFilter.fromJson(Map<String, dynamic> json) =>
      _$NestedIntWithAggregatesFilterFromJson(json);

  final int? equals;

  @JsonKey(name: r'in')
  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final NestedIntWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntFilter? $count;

  @JsonKey(name: r'_avg')
  final NestedFloatFilter? $avg;

  @JsonKey(name: r'_sum')
  final NestedIntFilter? $sum;

  @JsonKey(name: r'_min')
  final NestedIntFilter? $min;

  @JsonKey(name: r'_max')
  final NestedIntFilter? $max;

  @override
  Map<String, dynamic> toJson() => _$NestedIntWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class NestedFloatFilter implements _i1.JsonSerializable {
  const NestedFloatFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory NestedFloatFilter.fromJson(Map<String, dynamic> json) =>
      _$NestedFloatFilterFromJson(json);

  final double? equals;

  @JsonKey(name: r'in')
  final Iterable<double>? $in;

  final Iterable<double>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final NestedFloatFilter? not;

  @override
  Map<String, dynamic> toJson() => _$NestedFloatFilterToJson(this);
}

@_i1.jsonSerializable
class NestedStringWithAggregatesFilter implements _i1.JsonSerializable {
  const NestedStringWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  factory NestedStringWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$NestedStringWithAggregatesFilterFromJson(json);

  final String? equals;

  @JsonKey(name: r'in')
  final Iterable<String>? $in;

  final Iterable<String>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final NestedStringWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntFilter? $count;

  @JsonKey(name: r'_min')
  final NestedStringFilter? $min;

  @JsonKey(name: r'_max')
  final NestedStringFilter? $max;

  @override
  Map<String, dynamic> toJson() =>
      _$NestedStringWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class NestedStringNullableWithAggregatesFilter implements _i1.JsonSerializable {
  const NestedStringNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  factory NestedStringNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$NestedStringNullableWithAggregatesFilterFromJson(json);

  final String? equals;

  @JsonKey(name: r'in')
  final Iterable<String>? $in;

  final Iterable<String>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final NestedStringNullableWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntNullableFilter? $count;

  @JsonKey(name: r'_min')
  final NestedStringNullableFilter? $min;

  @JsonKey(name: r'_max')
  final NestedStringNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() =>
      _$NestedStringNullableWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class NestedIntNullableFilter implements _i1.JsonSerializable {
  const NestedIntNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory NestedIntNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$NestedIntNullableFilterFromJson(json);

  final int? equals;

  @JsonKey(name: r'in')
  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final NestedIntNullableFilter? not;

  @override
  Map<String, dynamic> toJson() => _$NestedIntNullableFilterToJson(this);
}

@_i1.jsonSerializable
class NestedBigIntFilter implements _i1.JsonSerializable {
  const NestedBigIntFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory NestedBigIntFilter.fromJson(Map<String, dynamic> json) =>
      _$NestedBigIntFilterFromJson(json);

  final BigInt? equals;

  @JsonKey(name: r'in')
  final Iterable<BigInt>? $in;

  final Iterable<BigInt>? notIn;

  final BigInt? lt;

  final BigInt? lte;

  final BigInt? gt;

  final BigInt? gte;

  final NestedBigIntFilter? not;

  @override
  Map<String, dynamic> toJson() => _$NestedBigIntFilterToJson(this);
}

@_i1.jsonSerializable
class NestedBigIntWithAggregatesFilter implements _i1.JsonSerializable {
  const NestedBigIntWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory NestedBigIntWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$NestedBigIntWithAggregatesFilterFromJson(json);

  final BigInt? equals;

  @JsonKey(name: r'in')
  final Iterable<BigInt>? $in;

  final Iterable<BigInt>? notIn;

  final BigInt? lt;

  final BigInt? lte;

  final BigInt? gt;

  final BigInt? gte;

  final NestedBigIntWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntFilter? $count;

  @JsonKey(name: r'_avg')
  final NestedFloatFilter? $avg;

  @JsonKey(name: r'_sum')
  final NestedBigIntFilter? $sum;

  @JsonKey(name: r'_min')
  final NestedBigIntFilter? $min;

  @JsonKey(name: r'_max')
  final NestedBigIntFilter? $max;

  @override
  Map<String, dynamic> toJson() =>
      _$NestedBigIntWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class NestedBoolFilter implements _i1.JsonSerializable {
  const NestedBoolFilter({
    this.equals,
    this.not,
  });

  factory NestedBoolFilter.fromJson(Map<String, dynamic> json) =>
      _$NestedBoolFilterFromJson(json);

  final bool? equals;

  final NestedBoolFilter? not;

  @override
  Map<String, dynamic> toJson() => _$NestedBoolFilterToJson(this);
}

@_i1.jsonSerializable
class NestedBoolWithAggregatesFilter implements _i1.JsonSerializable {
  const NestedBoolWithAggregatesFilter({
    this.equals,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  factory NestedBoolWithAggregatesFilter.fromJson(Map<String, dynamic> json) =>
      _$NestedBoolWithAggregatesFilterFromJson(json);

  final bool? equals;

  final NestedBoolWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntFilter? $count;

  @JsonKey(name: r'_min')
  final NestedBoolFilter? $min;

  @JsonKey(name: r'_max')
  final NestedBoolFilter? $max;

  @override
  Map<String, dynamic> toJson() => _$NestedBoolWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class NestedEnumTaskAssignmentStatusFilter implements _i1.JsonSerializable {
  const NestedEnumTaskAssignmentStatusFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  factory NestedEnumTaskAssignmentStatusFilter.fromJson(
          Map<String, dynamic> json) =>
      _$NestedEnumTaskAssignmentStatusFilterFromJson(json);

  final TaskAssignmentStatus? equals;

  @JsonKey(name: r'in')
  final Iterable<TaskAssignmentStatus>? $in;

  final Iterable<TaskAssignmentStatus>? notIn;

  final TaskAssignmentStatus? not;

  @override
  Map<String, dynamic> toJson() =>
      _$NestedEnumTaskAssignmentStatusFilterToJson(this);
}

@_i1.jsonSerializable
class NestedEnumTaskPriorityFilter implements _i1.JsonSerializable {
  const NestedEnumTaskPriorityFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
  });

  factory NestedEnumTaskPriorityFilter.fromJson(Map<String, dynamic> json) =>
      _$NestedEnumTaskPriorityFilterFromJson(json);

  final TaskPriority? equals;

  @JsonKey(name: r'in')
  final Iterable<TaskPriority>? $in;

  final Iterable<TaskPriority>? notIn;

  final TaskPriority? not;

  @override
  Map<String, dynamic> toJson() => _$NestedEnumTaskPriorityFilterToJson(this);
}

@_i1.jsonSerializable
class NestedEnumTaskAssignmentStatusWithAggregatesFilter
    implements _i1.JsonSerializable {
  const NestedEnumTaskAssignmentStatusWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  factory NestedEnumTaskAssignmentStatusWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$NestedEnumTaskAssignmentStatusWithAggregatesFilterFromJson(json);

  final TaskAssignmentStatus? equals;

  @JsonKey(name: r'in')
  final Iterable<TaskAssignmentStatus>? $in;

  final Iterable<TaskAssignmentStatus>? notIn;

  final TaskAssignmentStatus? not;

  @JsonKey(name: r'_count')
  final NestedIntFilter? $count;

  @JsonKey(name: r'_min')
  final NestedEnumTaskAssignmentStatusFilter? $min;

  @JsonKey(name: r'_max')
  final NestedEnumTaskAssignmentStatusFilter? $max;

  @override
  Map<String, dynamic> toJson() =>
      _$NestedEnumTaskAssignmentStatusWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class NestedEnumTaskPriorityWithAggregatesFilter
    implements _i1.JsonSerializable {
  const NestedEnumTaskPriorityWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  factory NestedEnumTaskPriorityWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$NestedEnumTaskPriorityWithAggregatesFilterFromJson(json);

  final TaskPriority? equals;

  @JsonKey(name: r'in')
  final Iterable<TaskPriority>? $in;

  final Iterable<TaskPriority>? notIn;

  final TaskPriority? not;

  @JsonKey(name: r'_count')
  final NestedIntFilter? $count;

  @JsonKey(name: r'_min')
  final NestedEnumTaskPriorityFilter? $min;

  @JsonKey(name: r'_max')
  final NestedEnumTaskPriorityFilter? $max;

  @override
  Map<String, dynamic> toJson() =>
      _$NestedEnumTaskPriorityWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class NestedIntNullableWithAggregatesFilter implements _i1.JsonSerializable {
  const NestedIntNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory NestedIntNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$NestedIntNullableWithAggregatesFilterFromJson(json);

  final int? equals;

  @JsonKey(name: r'in')
  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final NestedIntNullableWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntNullableFilter? $count;

  @JsonKey(name: r'_avg')
  final NestedFloatNullableFilter? $avg;

  @JsonKey(name: r'_sum')
  final NestedIntNullableFilter? $sum;

  @JsonKey(name: r'_min')
  final NestedIntNullableFilter? $min;

  @JsonKey(name: r'_max')
  final NestedIntNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() =>
      _$NestedIntNullableWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class NestedFloatNullableFilter implements _i1.JsonSerializable {
  const NestedFloatNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory NestedFloatNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$NestedFloatNullableFilterFromJson(json);

  final double? equals;

  @JsonKey(name: r'in')
  final Iterable<double>? $in;

  final Iterable<double>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final NestedFloatNullableFilter? not;

  @override
  Map<String, dynamic> toJson() => _$NestedFloatNullableFilterToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateWithoutUserInput implements _i1.JsonSerializable {
  const ProfileCreateWithoutUserInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileCreateWithoutUserInput.fromJson(Map<String, dynamic> json) =>
      _$ProfileCreateWithoutUserInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final CategoryCreateNestedManyWithoutProfileInput? categories;

  final TagCreateNestedManyWithoutProfileInput? tags;

  final TaskCreateNestedManyWithoutOwnerInput? tasks;

  final ChannelCreateNestedManyWithoutOwnerInput? channels;

  final TaskAssignmentCreateNestedManyWithoutProfileInput? taskAssignments;

  final ChannelSubscriptionCreateNestedManyWithoutProfileInput?
      channelSubscriptions;

  final ScheduleCreateNestedManyWithoutProfileInput? schedules;

  final RecordCreateNestedManyWithoutProfileInput? records;

  @override
  Map<String, dynamic> toJson() => _$ProfileCreateWithoutUserInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUncheckedCreateWithoutUserInput implements _i1.JsonSerializable {
  const ProfileUncheckedCreateWithoutUserInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileUncheckedCreateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUncheckedCreateWithoutUserInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final CategoryUncheckedCreateNestedManyWithoutProfileInput? categories;

  final TagUncheckedCreateNestedManyWithoutProfileInput? tags;

  final TaskUncheckedCreateNestedManyWithoutOwnerInput? tasks;

  final ChannelUncheckedCreateNestedManyWithoutOwnerInput? channels;

  final TaskAssignmentUncheckedCreateNestedManyWithoutProfileInput?
      taskAssignments;

  final ChannelSubscriptionUncheckedCreateNestedManyWithoutProfileInput?
      channelSubscriptions;

  final ScheduleUncheckedCreateNestedManyWithoutProfileInput? schedules;

  final RecordUncheckedCreateNestedManyWithoutProfileInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUncheckedCreateWithoutUserInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateOrConnectWithoutUserInput implements _i1.JsonSerializable {
  const ProfileCreateOrConnectWithoutUserInput({
    required this.where,
    required this.create,
  });

  factory ProfileCreateOrConnectWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateOrConnectWithoutUserInputFromJson(json);

  final ProfileWhereUniqueInput where;

  final ProfileCreateWithoutUserInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateOrConnectWithoutUserInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateManyUserInputEnvelope implements _i1.JsonSerializable {
  const ProfileCreateManyUserInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  factory ProfileCreateManyUserInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateManyUserInputEnvelopeFromJson(json);

  final Iterable<ProfileCreateManyUserInput> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateManyUserInputEnvelopeToJson(this);
}

@_i1.jsonSerializable
class ProfileUpsertWithWhereUniqueWithoutUserInput
    implements _i1.JsonSerializable {
  const ProfileUpsertWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.update,
    required this.create,
  });

  factory ProfileUpsertWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUpsertWithWhereUniqueWithoutUserInputFromJson(json);

  final ProfileWhereUniqueInput where;

  final ProfileUpdateWithoutUserInput update;

  final ProfileCreateWithoutUserInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUpsertWithWhereUniqueWithoutUserInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpdateWithWhereUniqueWithoutUserInput
    implements _i1.JsonSerializable {
  const ProfileUpdateWithWhereUniqueWithoutUserInput({
    required this.where,
    required this.data,
  });

  factory ProfileUpdateWithWhereUniqueWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUpdateWithWhereUniqueWithoutUserInputFromJson(json);

  final ProfileWhereUniqueInput where;

  final ProfileUpdateWithoutUserInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUpdateWithWhereUniqueWithoutUserInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpdateManyWithWhereWithoutUserInput
    implements _i1.JsonSerializable {
  const ProfileUpdateManyWithWhereWithoutUserInput({
    required this.where,
    required this.data,
  });

  factory ProfileUpdateManyWithWhereWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUpdateManyWithWhereWithoutUserInputFromJson(json);

  final ProfileScalarWhereInput where;

  final ProfileUpdateManyMutationInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUpdateManyWithWhereWithoutUserInputToJson(this);
}

@_i1.jsonSerializable
class ProfileScalarWhereInput implements _i1.JsonSerializable {
  const ProfileScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ProfileScalarWhereInput.fromJson(Map<String, dynamic> json) =>
      _$ProfileScalarWhereInputFromJson(json);

  final Iterable<ProfileScalarWhereInput>? AND;

  final Iterable<ProfileScalarWhereInput>? OR;

  final Iterable<ProfileScalarWhereInput>? NOT;

  final StringFilter? name;

  final StringFilter? color;

  final StringFilter? icon;

  final IntFilter? userId;

  final BigIntFilter? updateAt;

  final BigIntFilter? syncAt;

  final BigIntFilter? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$ProfileScalarWhereInputToJson(this);
}

@_i1.jsonSerializable
class UserCreateWithoutProfilesInput implements _i1.JsonSerializable {
  const UserCreateWithoutProfilesInput({
    required this.name,
    this.email,
    this.phone,
    required this.password,
    this.avatarRef,
    this.unionId,
    this.tencentId,
    this.appleId,
  });

  factory UserCreateWithoutProfilesInput.fromJson(Map<String, dynamic> json) =>
      _$UserCreateWithoutProfilesInputFromJson(json);

  final String name;

  final String? email;

  final String? phone;

  final String password;

  final String? avatarRef;

  final String? unionId;

  final String? tencentId;

  final String? appleId;

  @override
  Map<String, dynamic> toJson() => _$UserCreateWithoutProfilesInputToJson(this);
}

@_i1.jsonSerializable
class UserUncheckedCreateWithoutProfilesInput implements _i1.JsonSerializable {
  const UserUncheckedCreateWithoutProfilesInput({
    this.id,
    required this.name,
    this.email,
    this.phone,
    required this.password,
    this.avatarRef,
    this.unionId,
    this.tencentId,
    this.appleId,
  });

  factory UserUncheckedCreateWithoutProfilesInput.fromJson(
          Map<String, dynamic> json) =>
      _$UserUncheckedCreateWithoutProfilesInputFromJson(json);

  final int? id;

  final String name;

  final String? email;

  final String? phone;

  final String password;

  final String? avatarRef;

  final String? unionId;

  final String? tencentId;

  final String? appleId;

  @override
  Map<String, dynamic> toJson() =>
      _$UserUncheckedCreateWithoutProfilesInputToJson(this);
}

@_i1.jsonSerializable
class UserCreateOrConnectWithoutProfilesInput implements _i1.JsonSerializable {
  const UserCreateOrConnectWithoutProfilesInput({
    required this.where,
    required this.create,
  });

  factory UserCreateOrConnectWithoutProfilesInput.fromJson(
          Map<String, dynamic> json) =>
      _$UserCreateOrConnectWithoutProfilesInputFromJson(json);

  final UserWhereUniqueInput where;

  final UserCreateWithoutProfilesInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$UserCreateOrConnectWithoutProfilesInputToJson(this);
}

@_i1.jsonSerializable
class CategoryCreateWithoutProfileInput implements _i1.JsonSerializable {
  const CategoryCreateWithoutProfileInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    this.assignments,
  });

  factory CategoryCreateWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryCreateWithoutProfileInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final TaskAssignmentCreateNestedManyWithoutCategoryInput? assignments;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryCreateWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class CategoryUncheckedCreateWithoutProfileInput
    implements _i1.JsonSerializable {
  const CategoryUncheckedCreateWithoutProfileInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    this.assignments,
  });

  factory CategoryUncheckedCreateWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryUncheckedCreateWithoutProfileInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final TaskAssignmentUncheckedCreateNestedManyWithoutCategoryInput?
      assignments;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryUncheckedCreateWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class CategoryCreateOrConnectWithoutProfileInput
    implements _i1.JsonSerializable {
  const CategoryCreateOrConnectWithoutProfileInput({
    required this.where,
    required this.create,
  });

  factory CategoryCreateOrConnectWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryCreateOrConnectWithoutProfileInputFromJson(json);

  final CategoryWhereUniqueInput where;

  final CategoryCreateWithoutProfileInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryCreateOrConnectWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class CategoryCreateManyProfileInputEnvelope implements _i1.JsonSerializable {
  const CategoryCreateManyProfileInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  factory CategoryCreateManyProfileInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryCreateManyProfileInputEnvelopeFromJson(json);

  final Iterable<CategoryCreateManyProfileInput> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryCreateManyProfileInputEnvelopeToJson(this);
}

@_i1.jsonSerializable
class TagCreateWithoutProfileInput implements _i1.JsonSerializable {
  const TagCreateWithoutProfileInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    this.assignments,
  });

  factory TagCreateWithoutProfileInput.fromJson(Map<String, dynamic> json) =>
      _$TagCreateWithoutProfileInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final TaskAssignmentTagsCreateNestedManyWithoutTagInput? assignments;

  @override
  Map<String, dynamic> toJson() => _$TagCreateWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class TagUncheckedCreateWithoutProfileInput implements _i1.JsonSerializable {
  const TagUncheckedCreateWithoutProfileInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    this.assignments,
  });

  factory TagUncheckedCreateWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$TagUncheckedCreateWithoutProfileInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final TaskAssignmentTagsUncheckedCreateNestedManyWithoutTagInput? assignments;

  @override
  Map<String, dynamic> toJson() =>
      _$TagUncheckedCreateWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class TagCreateOrConnectWithoutProfileInput implements _i1.JsonSerializable {
  const TagCreateOrConnectWithoutProfileInput({
    required this.where,
    required this.create,
  });

  factory TagCreateOrConnectWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$TagCreateOrConnectWithoutProfileInputFromJson(json);

  final TagWhereUniqueInput where;

  final TagCreateWithoutProfileInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TagCreateOrConnectWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class TagCreateManyProfileInputEnvelope implements _i1.JsonSerializable {
  const TagCreateManyProfileInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  factory TagCreateManyProfileInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$TagCreateManyProfileInputEnvelopeFromJson(json);

  final Iterable<TagCreateManyProfileInput> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() =>
      _$TagCreateManyProfileInputEnvelopeToJson(this);
}

@_i1.jsonSerializable
class TaskCreateWithoutOwnerInput implements _i1.JsonSerializable {
  const TaskCreateWithoutOwnerInput({
    required this.uuid,
    required this.title,
    required this.desc,
    required this.content,
    this.location,
    required this.requireLocation,
    required this.requireTime,
    required this.requireAttachment,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.parent,
    this.children,
    this.channel,
    this.assets,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskCreateWithoutOwnerInput.fromJson(Map<String, dynamic> json) =>
      _$TaskCreateWithoutOwnerInputFromJson(json);

  final String uuid;

  final String title;

  final String desc;

  final String content;

  final String? location;

  final bool requireLocation;

  final bool requireTime;

  final bool requireAttachment;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final TaskCreateNestedOneWithoutChildrenInput? parent;

  final TaskCreateNestedManyWithoutParentInput? children;

  final ChannelCreateNestedOneWithoutTasksInput? channel;

  final TaskAssetCreateNestedManyWithoutTaskInput? assets;

  final TaskAssignmentCreateNestedManyWithoutTaskInput? assignments;

  final SessionCreateNestedManyWithoutTaskInput? sessions;

  final RecordCreateNestedManyWithoutTaskInput? records;

  @override
  Map<String, dynamic> toJson() => _$TaskCreateWithoutOwnerInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedCreateWithoutOwnerInput implements _i1.JsonSerializable {
  const TaskUncheckedCreateWithoutOwnerInput({
    required this.uuid,
    required this.title,
    required this.desc,
    required this.content,
    this.location,
    required this.requireLocation,
    required this.requireTime,
    required this.requireAttachment,
    this.parentUuid,
    this.channelUuid,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.children,
    this.assets,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskUncheckedCreateWithoutOwnerInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUncheckedCreateWithoutOwnerInputFromJson(json);

  final String uuid;

  final String title;

  final String desc;

  final String content;

  final String? location;

  final bool requireLocation;

  final bool requireTime;

  final bool requireAttachment;

  final String? parentUuid;

  final String? channelUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final TaskUncheckedCreateNestedManyWithoutParentInput? children;

  final TaskAssetUncheckedCreateNestedManyWithoutTaskInput? assets;

  final TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput? assignments;

  final SessionUncheckedCreateNestedManyWithoutTaskInput? sessions;

  final RecordUncheckedCreateNestedManyWithoutTaskInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUncheckedCreateWithoutOwnerInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateOrConnectWithoutOwnerInput implements _i1.JsonSerializable {
  const TaskCreateOrConnectWithoutOwnerInput({
    required this.where,
    required this.create,
  });

  factory TaskCreateOrConnectWithoutOwnerInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskCreateOrConnectWithoutOwnerInputFromJson(json);

  final TaskWhereUniqueInput where;

  final TaskCreateWithoutOwnerInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskCreateOrConnectWithoutOwnerInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateManyOwnerInputEnvelope implements _i1.JsonSerializable {
  const TaskCreateManyOwnerInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  factory TaskCreateManyOwnerInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$TaskCreateManyOwnerInputEnvelopeFromJson(json);

  final Iterable<TaskCreateManyOwnerInput> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskCreateManyOwnerInputEnvelopeToJson(this);
}

@_i1.jsonSerializable
class ChannelCreateWithoutOwnerInput implements _i1.JsonSerializable {
  const ChannelCreateWithoutOwnerInput({
    required this.uuid,
    required this.name,
    required this.desc,
    required this.color,
    this.imgRef,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.subscriptions,
    this.tasks,
  });

  factory ChannelCreateWithoutOwnerInput.fromJson(Map<String, dynamic> json) =>
      _$ChannelCreateWithoutOwnerInputFromJson(json);

  final String uuid;

  final String name;

  final String desc;

  final String color;

  final String? imgRef;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final ChannelSubscriptionCreateNestedManyWithoutChannelInput? subscriptions;

  final TaskCreateNestedManyWithoutChannelInput? tasks;

  @override
  Map<String, dynamic> toJson() => _$ChannelCreateWithoutOwnerInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUncheckedCreateWithoutOwnerInput implements _i1.JsonSerializable {
  const ChannelUncheckedCreateWithoutOwnerInput({
    required this.uuid,
    required this.name,
    required this.desc,
    required this.color,
    this.imgRef,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.subscriptions,
    this.tasks,
  });

  factory ChannelUncheckedCreateWithoutOwnerInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelUncheckedCreateWithoutOwnerInputFromJson(json);

  final String uuid;

  final String name;

  final String desc;

  final String color;

  final String? imgRef;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final ChannelSubscriptionUncheckedCreateNestedManyWithoutChannelInput?
      subscriptions;

  final TaskUncheckedCreateNestedManyWithoutChannelInput? tasks;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelUncheckedCreateWithoutOwnerInputToJson(this);
}

@_i1.jsonSerializable
class ChannelCreateOrConnectWithoutOwnerInput implements _i1.JsonSerializable {
  const ChannelCreateOrConnectWithoutOwnerInput({
    required this.where,
    required this.create,
  });

  factory ChannelCreateOrConnectWithoutOwnerInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelCreateOrConnectWithoutOwnerInputFromJson(json);

  final ChannelWhereUniqueInput where;

  final ChannelCreateWithoutOwnerInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelCreateOrConnectWithoutOwnerInputToJson(this);
}

@_i1.jsonSerializable
class ChannelCreateManyOwnerInputEnvelope implements _i1.JsonSerializable {
  const ChannelCreateManyOwnerInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  factory ChannelCreateManyOwnerInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelCreateManyOwnerInputEnvelopeFromJson(json);

  final Iterable<ChannelCreateManyOwnerInput> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelCreateManyOwnerInputEnvelopeToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentCreateWithoutProfileInput implements _i1.JsonSerializable {
  const TaskAssignmentCreateWithoutProfileInput({
    required this.status,
    required this.priority,
    required this.starred,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    required this.task,
    this.category,
    this.tags,
  });

  factory TaskAssignmentCreateWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentCreateWithoutProfileInputFromJson(json);

  final TaskAssignmentStatus status;

  final TaskPriority priority;

  final bool starred;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final TaskCreateNestedOneWithoutAssignmentsInput task;

  final CategoryCreateNestedOneWithoutAssignmentsInput? category;

  final TaskAssignmentTagsCreateNestedManyWithoutAssignmentInput? tags;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentCreateWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUncheckedCreateWithoutProfileInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUncheckedCreateWithoutProfileInput({
    required this.status,
    required this.priority,
    required this.starred,
    required this.taskUuid,
    this.categoryName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    this.tags,
  });

  factory TaskAssignmentUncheckedCreateWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUncheckedCreateWithoutProfileInputFromJson(json);

  final TaskAssignmentStatus status;

  final TaskPriority priority;

  final bool starred;

  final String taskUuid;

  final String? categoryName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final TaskAssignmentTagsUncheckedCreateNestedManyWithoutAssignmentInput? tags;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUncheckedCreateWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentCreateOrConnectWithoutProfileInput
    implements _i1.JsonSerializable {
  const TaskAssignmentCreateOrConnectWithoutProfileInput({
    required this.where,
    required this.create,
  });

  factory TaskAssignmentCreateOrConnectWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentCreateOrConnectWithoutProfileInputFromJson(json);

  final TaskAssignmentWhereUniqueInput where;

  final TaskAssignmentCreateWithoutProfileInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentCreateOrConnectWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentCreateManyProfileInputEnvelope
    implements _i1.JsonSerializable {
  const TaskAssignmentCreateManyProfileInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  factory TaskAssignmentCreateManyProfileInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentCreateManyProfileInputEnvelopeFromJson(json);

  final Iterable<TaskAssignmentCreateManyProfileInput> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentCreateManyProfileInputEnvelopeToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionCreateWithoutProfileInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionCreateWithoutProfileInput({
    required this.shareRecord,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    required this.channel,
  });

  factory ChannelSubscriptionCreateWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionCreateWithoutProfileInputFromJson(json);

  final bool shareRecord;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final ChannelCreateNestedOneWithoutSubscriptionsInput channel;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionCreateWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUncheckedCreateWithoutProfileInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionUncheckedCreateWithoutProfileInput({
    required this.shareRecord,
    required this.channelUuid,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory ChannelSubscriptionUncheckedCreateWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionUncheckedCreateWithoutProfileInputFromJson(json);

  final bool shareRecord;

  final String channelUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionUncheckedCreateWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionCreateOrConnectWithoutProfileInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionCreateOrConnectWithoutProfileInput({
    required this.where,
    required this.create,
  });

  factory ChannelSubscriptionCreateOrConnectWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionCreateOrConnectWithoutProfileInputFromJson(json);

  final ChannelSubscriptionWhereUniqueInput where;

  final ChannelSubscriptionCreateWithoutProfileInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionCreateOrConnectWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionCreateManyProfileInputEnvelope
    implements _i1.JsonSerializable {
  const ChannelSubscriptionCreateManyProfileInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  factory ChannelSubscriptionCreateManyProfileInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionCreateManyProfileInputEnvelopeFromJson(json);

  final Iterable<ChannelSubscriptionCreateManyProfileInput> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionCreateManyProfileInputEnvelopeToJson(this);
}

@_i1.jsonSerializable
class ScheduleCreateWithoutProfileInput implements _i1.JsonSerializable {
  const ScheduleCreateWithoutProfileInput({
    required this.relStart,
    required this.relEnd,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    required this.session,
  });

  factory ScheduleCreateWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleCreateWithoutProfileInputFromJson(json);

  final BigInt relStart;

  final BigInt relEnd;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final SessionCreateNestedOneWithoutSchedulesInput session;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleCreateWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleUncheckedCreateWithoutProfileInput
    implements _i1.JsonSerializable {
  const ScheduleUncheckedCreateWithoutProfileInput({
    required this.relStart,
    required this.relEnd,
    required this.sessionUuid,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory ScheduleUncheckedCreateWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleUncheckedCreateWithoutProfileInputFromJson(json);

  final BigInt relStart;

  final BigInt relEnd;

  final String sessionUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleUncheckedCreateWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleCreateOrConnectWithoutProfileInput
    implements _i1.JsonSerializable {
  const ScheduleCreateOrConnectWithoutProfileInput({
    required this.where,
    required this.create,
  });

  factory ScheduleCreateOrConnectWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleCreateOrConnectWithoutProfileInputFromJson(json);

  final ScheduleWhereUniqueInput where;

  final ScheduleCreateWithoutProfileInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleCreateOrConnectWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleCreateManyProfileInputEnvelope implements _i1.JsonSerializable {
  const ScheduleCreateManyProfileInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  factory ScheduleCreateManyProfileInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleCreateManyProfileInputEnvelopeFromJson(json);

  final Iterable<ScheduleCreateManyProfileInput> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleCreateManyProfileInputEnvelopeToJson(this);
}

@_i1.jsonSerializable
class RecordCreateWithoutProfileInput implements _i1.JsonSerializable {
  const RecordCreateWithoutProfileInput({
    required this.time,
    required this.recordIndex,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    required this.session,
    required this.task,
    this.attachment,
  });

  factory RecordCreateWithoutProfileInput.fromJson(Map<String, dynamic> json) =>
      _$RecordCreateWithoutProfileInputFromJson(json);

  final BigInt time;

  final int recordIndex;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final SessionCreateNestedOneWithoutRecordsInput session;

  final TaskCreateNestedOneWithoutRecordsInput task;

  final RecordAttachmentCreateNestedOneWithoutRecordInput? attachment;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordCreateWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class RecordUncheckedCreateWithoutProfileInput implements _i1.JsonSerializable {
  const RecordUncheckedCreateWithoutProfileInput({
    required this.time,
    required this.recordIndex,
    required this.sessionUuid,
    required this.taskUuid,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    this.attachment,
  });

  factory RecordUncheckedCreateWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUncheckedCreateWithoutProfileInputFromJson(json);

  final BigInt time;

  final int recordIndex;

  final String sessionUuid;

  final String taskUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final RecordAttachmentUncheckedCreateNestedOneWithoutRecordInput? attachment;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUncheckedCreateWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class RecordCreateOrConnectWithoutProfileInput implements _i1.JsonSerializable {
  const RecordCreateOrConnectWithoutProfileInput({
    required this.where,
    required this.create,
  });

  factory RecordCreateOrConnectWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordCreateOrConnectWithoutProfileInputFromJson(json);

  final RecordWhereUniqueInput where;

  final RecordCreateWithoutProfileInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordCreateOrConnectWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class RecordCreateManyProfileInputEnvelope implements _i1.JsonSerializable {
  const RecordCreateManyProfileInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  factory RecordCreateManyProfileInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$RecordCreateManyProfileInputEnvelopeFromJson(json);

  final Iterable<RecordCreateManyProfileInput> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordCreateManyProfileInputEnvelopeToJson(this);
}

@_i1.jsonSerializable
class UserUpsertWithoutProfilesInput implements _i1.JsonSerializable {
  const UserUpsertWithoutProfilesInput({
    required this.update,
    required this.create,
  });

  factory UserUpsertWithoutProfilesInput.fromJson(Map<String, dynamic> json) =>
      _$UserUpsertWithoutProfilesInputFromJson(json);

  final UserUpdateWithoutProfilesInput update;

  final UserCreateWithoutProfilesInput create;

  @override
  Map<String, dynamic> toJson() => _$UserUpsertWithoutProfilesInputToJson(this);
}

@_i1.jsonSerializable
class UserUpdateWithoutProfilesInput implements _i1.JsonSerializable {
  const UserUpdateWithoutProfilesInput({
    this.name,
    this.email,
    this.phone,
    this.password,
    this.avatarRef,
    this.unionId,
    this.tencentId,
    this.appleId,
  });

  factory UserUpdateWithoutProfilesInput.fromJson(Map<String, dynamic> json) =>
      _$UserUpdateWithoutProfilesInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final NullableStringFieldUpdateOperationsInput? email;

  final NullableStringFieldUpdateOperationsInput? phone;

  final StringFieldUpdateOperationsInput? password;

  final NullableStringFieldUpdateOperationsInput? avatarRef;

  final NullableStringFieldUpdateOperationsInput? unionId;

  final NullableStringFieldUpdateOperationsInput? tencentId;

  final NullableStringFieldUpdateOperationsInput? appleId;

  @override
  Map<String, dynamic> toJson() => _$UserUpdateWithoutProfilesInputToJson(this);
}

@_i1.jsonSerializable
class UserUncheckedUpdateWithoutProfilesInput implements _i1.JsonSerializable {
  const UserUncheckedUpdateWithoutProfilesInput({
    this.id,
    this.name,
    this.email,
    this.phone,
    this.password,
    this.avatarRef,
    this.unionId,
    this.tencentId,
    this.appleId,
  });

  factory UserUncheckedUpdateWithoutProfilesInput.fromJson(
          Map<String, dynamic> json) =>
      _$UserUncheckedUpdateWithoutProfilesInputFromJson(json);

  final IntFieldUpdateOperationsInput? id;

  final StringFieldUpdateOperationsInput? name;

  final NullableStringFieldUpdateOperationsInput? email;

  final NullableStringFieldUpdateOperationsInput? phone;

  final StringFieldUpdateOperationsInput? password;

  final NullableStringFieldUpdateOperationsInput? avatarRef;

  final NullableStringFieldUpdateOperationsInput? unionId;

  final NullableStringFieldUpdateOperationsInput? tencentId;

  final NullableStringFieldUpdateOperationsInput? appleId;

  @override
  Map<String, dynamic> toJson() =>
      _$UserUncheckedUpdateWithoutProfilesInputToJson(this);
}

@_i1.jsonSerializable
class CategoryUpsertWithWhereUniqueWithoutProfileInput
    implements _i1.JsonSerializable {
  const CategoryUpsertWithWhereUniqueWithoutProfileInput({
    required this.where,
    required this.update,
    required this.create,
  });

  factory CategoryUpsertWithWhereUniqueWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryUpsertWithWhereUniqueWithoutProfileInputFromJson(json);

  final CategoryWhereUniqueInput where;

  final CategoryUpdateWithoutProfileInput update;

  final CategoryCreateWithoutProfileInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryUpsertWithWhereUniqueWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class CategoryUpdateWithWhereUniqueWithoutProfileInput
    implements _i1.JsonSerializable {
  const CategoryUpdateWithWhereUniqueWithoutProfileInput({
    required this.where,
    required this.data,
  });

  factory CategoryUpdateWithWhereUniqueWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryUpdateWithWhereUniqueWithoutProfileInputFromJson(json);

  final CategoryWhereUniqueInput where;

  final CategoryUpdateWithoutProfileInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryUpdateWithWhereUniqueWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class CategoryUpdateManyWithWhereWithoutProfileInput
    implements _i1.JsonSerializable {
  const CategoryUpdateManyWithWhereWithoutProfileInput({
    required this.where,
    required this.data,
  });

  factory CategoryUpdateManyWithWhereWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryUpdateManyWithWhereWithoutProfileInputFromJson(json);

  final CategoryScalarWhereInput where;

  final CategoryUpdateManyMutationInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryUpdateManyWithWhereWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class CategoryScalarWhereInput implements _i1.JsonSerializable {
  const CategoryScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory CategoryScalarWhereInput.fromJson(Map<String, dynamic> json) =>
      _$CategoryScalarWhereInputFromJson(json);

  final Iterable<CategoryScalarWhereInput>? AND;

  final Iterable<CategoryScalarWhereInput>? OR;

  final Iterable<CategoryScalarWhereInput>? NOT;

  final StringFilter? name;

  final StringFilter? color;

  final StringFilter? icon;

  final IntFilter? userId;

  final StringFilter? profileName;

  final BigIntFilter? updateAt;

  final BigIntFilter? syncAt;

  final BigIntFilter? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$CategoryScalarWhereInputToJson(this);
}

@_i1.jsonSerializable
class TagUpsertWithWhereUniqueWithoutProfileInput
    implements _i1.JsonSerializable {
  const TagUpsertWithWhereUniqueWithoutProfileInput({
    required this.where,
    required this.update,
    required this.create,
  });

  factory TagUpsertWithWhereUniqueWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$TagUpsertWithWhereUniqueWithoutProfileInputFromJson(json);

  final TagWhereUniqueInput where;

  final TagUpdateWithoutProfileInput update;

  final TagCreateWithoutProfileInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TagUpsertWithWhereUniqueWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class TagUpdateWithWhereUniqueWithoutProfileInput
    implements _i1.JsonSerializable {
  const TagUpdateWithWhereUniqueWithoutProfileInput({
    required this.where,
    required this.data,
  });

  factory TagUpdateWithWhereUniqueWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$TagUpdateWithWhereUniqueWithoutProfileInputFromJson(json);

  final TagWhereUniqueInput where;

  final TagUpdateWithoutProfileInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$TagUpdateWithWhereUniqueWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class TagUpdateManyWithWhereWithoutProfileInput
    implements _i1.JsonSerializable {
  const TagUpdateManyWithWhereWithoutProfileInput({
    required this.where,
    required this.data,
  });

  factory TagUpdateManyWithWhereWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$TagUpdateManyWithWhereWithoutProfileInputFromJson(json);

  final TagScalarWhereInput where;

  final TagUpdateManyMutationInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$TagUpdateManyWithWhereWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class TagScalarWhereInput implements _i1.JsonSerializable {
  const TagScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TagScalarWhereInput.fromJson(Map<String, dynamic> json) =>
      _$TagScalarWhereInputFromJson(json);

  final Iterable<TagScalarWhereInput>? AND;

  final Iterable<TagScalarWhereInput>? OR;

  final Iterable<TagScalarWhereInput>? NOT;

  final StringFilter? name;

  final StringFilter? color;

  final StringFilter? icon;

  final IntFilter? userId;

  final StringFilter? profileName;

  final BigIntFilter? updateAt;

  final BigIntFilter? syncAt;

  final BigIntFilter? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TagScalarWhereInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpsertWithWhereUniqueWithoutOwnerInput
    implements _i1.JsonSerializable {
  const TaskUpsertWithWhereUniqueWithoutOwnerInput({
    required this.where,
    required this.update,
    required this.create,
  });

  factory TaskUpsertWithWhereUniqueWithoutOwnerInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUpsertWithWhereUniqueWithoutOwnerInputFromJson(json);

  final TaskWhereUniqueInput where;

  final TaskUpdateWithoutOwnerInput update;

  final TaskCreateWithoutOwnerInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUpsertWithWhereUniqueWithoutOwnerInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpdateWithWhereUniqueWithoutOwnerInput
    implements _i1.JsonSerializable {
  const TaskUpdateWithWhereUniqueWithoutOwnerInput({
    required this.where,
    required this.data,
  });

  factory TaskUpdateWithWhereUniqueWithoutOwnerInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUpdateWithWhereUniqueWithoutOwnerInputFromJson(json);

  final TaskWhereUniqueInput where;

  final TaskUpdateWithoutOwnerInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUpdateWithWhereUniqueWithoutOwnerInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpdateManyWithWhereWithoutOwnerInput implements _i1.JsonSerializable {
  const TaskUpdateManyWithWhereWithoutOwnerInput({
    required this.where,
    required this.data,
  });

  factory TaskUpdateManyWithWhereWithoutOwnerInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUpdateManyWithWhereWithoutOwnerInputFromJson(json);

  final TaskScalarWhereInput where;

  final TaskUpdateManyMutationInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUpdateManyWithWhereWithoutOwnerInputToJson(this);
}

@_i1.jsonSerializable
class TaskScalarWhereInput implements _i1.JsonSerializable {
  const TaskScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.userId,
    this.profile,
    this.parentUuid,
    this.channelUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskScalarWhereInput.fromJson(Map<String, dynamic> json) =>
      _$TaskScalarWhereInputFromJson(json);

  final Iterable<TaskScalarWhereInput>? AND;

  final Iterable<TaskScalarWhereInput>? OR;

  final Iterable<TaskScalarWhereInput>? NOT;

  final StringFilter? uuid;

  final StringFilter? title;

  final StringFilter? desc;

  final StringFilter? content;

  final StringNullableFilter? location;

  final BoolFilter? requireLocation;

  final BoolFilter? requireTime;

  final BoolFilter? requireAttachment;

  final IntFilter? userId;

  final StringFilter? profile;

  final StringNullableFilter? parentUuid;

  final StringNullableFilter? channelUuid;

  final BigIntFilter? updateAt;

  final BigIntFilter? syncAt;

  final BigIntFilter? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TaskScalarWhereInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUpsertWithWhereUniqueWithoutOwnerInput
    implements _i1.JsonSerializable {
  const ChannelUpsertWithWhereUniqueWithoutOwnerInput({
    required this.where,
    required this.update,
    required this.create,
  });

  factory ChannelUpsertWithWhereUniqueWithoutOwnerInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelUpsertWithWhereUniqueWithoutOwnerInputFromJson(json);

  final ChannelWhereUniqueInput where;

  final ChannelUpdateWithoutOwnerInput update;

  final ChannelCreateWithoutOwnerInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelUpsertWithWhereUniqueWithoutOwnerInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUpdateWithWhereUniqueWithoutOwnerInput
    implements _i1.JsonSerializable {
  const ChannelUpdateWithWhereUniqueWithoutOwnerInput({
    required this.where,
    required this.data,
  });

  factory ChannelUpdateWithWhereUniqueWithoutOwnerInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelUpdateWithWhereUniqueWithoutOwnerInputFromJson(json);

  final ChannelWhereUniqueInput where;

  final ChannelUpdateWithoutOwnerInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelUpdateWithWhereUniqueWithoutOwnerInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUpdateManyWithWhereWithoutOwnerInput
    implements _i1.JsonSerializable {
  const ChannelUpdateManyWithWhereWithoutOwnerInput({
    required this.where,
    required this.data,
  });

  factory ChannelUpdateManyWithWhereWithoutOwnerInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelUpdateManyWithWhereWithoutOwnerInputFromJson(json);

  final ChannelScalarWhereInput where;

  final ChannelUpdateManyMutationInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelUpdateManyWithWhereWithoutOwnerInputToJson(this);
}

@_i1.jsonSerializable
class ChannelScalarWhereInput implements _i1.JsonSerializable {
  const ChannelScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.name,
    this.desc,
    this.color,
    this.imgRef,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelScalarWhereInput.fromJson(Map<String, dynamic> json) =>
      _$ChannelScalarWhereInputFromJson(json);

  final Iterable<ChannelScalarWhereInput>? AND;

  final Iterable<ChannelScalarWhereInput>? OR;

  final Iterable<ChannelScalarWhereInput>? NOT;

  final StringFilter? uuid;

  final StringFilter? name;

  final StringFilter? desc;

  final StringFilter? color;

  final StringNullableFilter? imgRef;

  final IntFilter? userId;

  final StringFilter? profileName;

  final BigIntFilter? updateAt;

  final BigIntFilter? syncAt;

  final BigIntFilter? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$ChannelScalarWhereInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUpsertWithWhereUniqueWithoutProfileInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUpsertWithWhereUniqueWithoutProfileInput({
    required this.where,
    required this.update,
    required this.create,
  });

  factory TaskAssignmentUpsertWithWhereUniqueWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUpsertWithWhereUniqueWithoutProfileInputFromJson(json);

  final TaskAssignmentWhereUniqueInput where;

  final TaskAssignmentUpdateWithoutProfileInput update;

  final TaskAssignmentCreateWithoutProfileInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUpsertWithWhereUniqueWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUpdateWithWhereUniqueWithoutProfileInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUpdateWithWhereUniqueWithoutProfileInput({
    required this.where,
    required this.data,
  });

  factory TaskAssignmentUpdateWithWhereUniqueWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUpdateWithWhereUniqueWithoutProfileInputFromJson(json);

  final TaskAssignmentWhereUniqueInput where;

  final TaskAssignmentUpdateWithoutProfileInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUpdateWithWhereUniqueWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUpdateManyWithWhereWithoutProfileInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUpdateManyWithWhereWithoutProfileInput({
    required this.where,
    required this.data,
  });

  factory TaskAssignmentUpdateManyWithWhereWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUpdateManyWithWhereWithoutProfileInputFromJson(json);

  final TaskAssignmentScalarWhereInput where;

  final TaskAssignmentUpdateManyMutationInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUpdateManyWithWhereWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentScalarWhereInput implements _i1.JsonSerializable {
  const TaskAssignmentScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.status,
    this.priority,
    this.starred,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.categoryName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssignmentScalarWhereInput.fromJson(Map<String, dynamic> json) =>
      _$TaskAssignmentScalarWhereInputFromJson(json);

  final Iterable<TaskAssignmentScalarWhereInput>? AND;

  final Iterable<TaskAssignmentScalarWhereInput>? OR;

  final Iterable<TaskAssignmentScalarWhereInput>? NOT;

  final EnumTaskAssignmentStatusFilter? status;

  final EnumTaskPriorityFilter? priority;

  final BoolFilter? starred;

  final StringFilter? taskUuid;

  final IntFilter? userId;

  final StringFilter? profileName;

  final StringNullableFilter? categoryName;

  final BigIntFilter? updateAt;

  final BigIntFilter? syncAt;

  final BigIntFilter? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TaskAssignmentScalarWhereInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUpsertWithWhereUniqueWithoutProfileInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionUpsertWithWhereUniqueWithoutProfileInput({
    required this.where,
    required this.update,
    required this.create,
  });

  factory ChannelSubscriptionUpsertWithWhereUniqueWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionUpsertWithWhereUniqueWithoutProfileInputFromJson(
          json);

  final ChannelSubscriptionWhereUniqueInput where;

  final ChannelSubscriptionUpdateWithoutProfileInput update;

  final ChannelSubscriptionCreateWithoutProfileInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionUpsertWithWhereUniqueWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUpdateWithWhereUniqueWithoutProfileInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionUpdateWithWhereUniqueWithoutProfileInput({
    required this.where,
    required this.data,
  });

  factory ChannelSubscriptionUpdateWithWhereUniqueWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionUpdateWithWhereUniqueWithoutProfileInputFromJson(
          json);

  final ChannelSubscriptionWhereUniqueInput where;

  final ChannelSubscriptionUpdateWithoutProfileInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionUpdateWithWhereUniqueWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUpdateManyWithWhereWithoutProfileInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionUpdateManyWithWhereWithoutProfileInput({
    required this.where,
    required this.data,
  });

  factory ChannelSubscriptionUpdateManyWithWhereWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionUpdateManyWithWhereWithoutProfileInputFromJson(json);

  final ChannelSubscriptionScalarWhereInput where;

  final ChannelSubscriptionUpdateManyMutationInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionUpdateManyWithWhereWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionScalarWhereInput implements _i1.JsonSerializable {
  const ChannelSubscriptionScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.shareRecord,
    this.channelUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelSubscriptionScalarWhereInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionScalarWhereInputFromJson(json);

  final Iterable<ChannelSubscriptionScalarWhereInput>? AND;

  final Iterable<ChannelSubscriptionScalarWhereInput>? OR;

  final Iterable<ChannelSubscriptionScalarWhereInput>? NOT;

  final BoolFilter? shareRecord;

  final StringFilter? channelUuid;

  final IntFilter? userId;

  final StringFilter? profileName;

  final BigIntFilter? updateAt;

  final BigIntFilter? syncAt;

  final BigIntFilter? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionScalarWhereInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleUpsertWithWhereUniqueWithoutProfileInput
    implements _i1.JsonSerializable {
  const ScheduleUpsertWithWhereUniqueWithoutProfileInput({
    required this.where,
    required this.update,
    required this.create,
  });

  factory ScheduleUpsertWithWhereUniqueWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleUpsertWithWhereUniqueWithoutProfileInputFromJson(json);

  final ScheduleWhereUniqueInput where;

  final ScheduleUpdateWithoutProfileInput update;

  final ScheduleCreateWithoutProfileInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleUpsertWithWhereUniqueWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleUpdateWithWhereUniqueWithoutProfileInput
    implements _i1.JsonSerializable {
  const ScheduleUpdateWithWhereUniqueWithoutProfileInput({
    required this.where,
    required this.data,
  });

  factory ScheduleUpdateWithWhereUniqueWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleUpdateWithWhereUniqueWithoutProfileInputFromJson(json);

  final ScheduleWhereUniqueInput where;

  final ScheduleUpdateWithoutProfileInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleUpdateWithWhereUniqueWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleUpdateManyWithWhereWithoutProfileInput
    implements _i1.JsonSerializable {
  const ScheduleUpdateManyWithWhereWithoutProfileInput({
    required this.where,
    required this.data,
  });

  factory ScheduleUpdateManyWithWhereWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleUpdateManyWithWhereWithoutProfileInputFromJson(json);

  final ScheduleScalarWhereInput where;

  final ScheduleUpdateManyMutationInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleUpdateManyWithWhereWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleScalarWhereInput implements _i1.JsonSerializable {
  const ScheduleScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.relStart,
    this.relEnd,
    this.sessionUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ScheduleScalarWhereInput.fromJson(Map<String, dynamic> json) =>
      _$ScheduleScalarWhereInputFromJson(json);

  final Iterable<ScheduleScalarWhereInput>? AND;

  final Iterable<ScheduleScalarWhereInput>? OR;

  final Iterable<ScheduleScalarWhereInput>? NOT;

  final BigIntFilter? relStart;

  final BigIntFilter? relEnd;

  final StringFilter? sessionUuid;

  final IntFilter? userId;

  final StringFilter? profileName;

  final BigIntFilter? updateAt;

  final BigIntFilter? syncAt;

  final BigIntFilter? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$ScheduleScalarWhereInputToJson(this);
}

@_i1.jsonSerializable
class RecordUpsertWithWhereUniqueWithoutProfileInput
    implements _i1.JsonSerializable {
  const RecordUpsertWithWhereUniqueWithoutProfileInput({
    required this.where,
    required this.update,
    required this.create,
  });

  factory RecordUpsertWithWhereUniqueWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUpsertWithWhereUniqueWithoutProfileInputFromJson(json);

  final RecordWhereUniqueInput where;

  final RecordUpdateWithoutProfileInput update;

  final RecordCreateWithoutProfileInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUpsertWithWhereUniqueWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class RecordUpdateWithWhereUniqueWithoutProfileInput
    implements _i1.JsonSerializable {
  const RecordUpdateWithWhereUniqueWithoutProfileInput({
    required this.where,
    required this.data,
  });

  factory RecordUpdateWithWhereUniqueWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUpdateWithWhereUniqueWithoutProfileInputFromJson(json);

  final RecordWhereUniqueInput where;

  final RecordUpdateWithoutProfileInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUpdateWithWhereUniqueWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class RecordUpdateManyWithWhereWithoutProfileInput
    implements _i1.JsonSerializable {
  const RecordUpdateManyWithWhereWithoutProfileInput({
    required this.where,
    required this.data,
  });

  factory RecordUpdateManyWithWhereWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUpdateManyWithWhereWithoutProfileInputFromJson(json);

  final RecordScalarWhereInput where;

  final RecordUpdateManyMutationInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUpdateManyWithWhereWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class RecordScalarWhereInput implements _i1.JsonSerializable {
  const RecordScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.time,
    this.recordIndex,
    this.sessionUuid,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory RecordScalarWhereInput.fromJson(Map<String, dynamic> json) =>
      _$RecordScalarWhereInputFromJson(json);

  final Iterable<RecordScalarWhereInput>? AND;

  final Iterable<RecordScalarWhereInput>? OR;

  final Iterable<RecordScalarWhereInput>? NOT;

  final BigIntFilter? time;

  final IntFilter? recordIndex;

  final StringFilter? sessionUuid;

  final StringFilter? taskUuid;

  final IntFilter? userId;

  final StringFilter? profileName;

  final BigIntFilter? updateAt;

  final BigIntFilter? syncAt;

  final BigIntFilter? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$RecordScalarWhereInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateWithoutTasksInput implements _i1.JsonSerializable {
  const ProfileCreateWithoutTasksInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    required this.user,
    this.categories,
    this.tags,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileCreateWithoutTasksInput.fromJson(Map<String, dynamic> json) =>
      _$ProfileCreateWithoutTasksInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final UserCreateNestedOneWithoutProfilesInput user;

  final CategoryCreateNestedManyWithoutProfileInput? categories;

  final TagCreateNestedManyWithoutProfileInput? tags;

  final ChannelCreateNestedManyWithoutOwnerInput? channels;

  final TaskAssignmentCreateNestedManyWithoutProfileInput? taskAssignments;

  final ChannelSubscriptionCreateNestedManyWithoutProfileInput?
      channelSubscriptions;

  final ScheduleCreateNestedManyWithoutProfileInput? schedules;

  final RecordCreateNestedManyWithoutProfileInput? records;

  @override
  Map<String, dynamic> toJson() => _$ProfileCreateWithoutTasksInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUncheckedCreateWithoutTasksInput implements _i1.JsonSerializable {
  const ProfileUncheckedCreateWithoutTasksInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.userId,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.categories,
    this.tags,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileUncheckedCreateWithoutTasksInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUncheckedCreateWithoutTasksInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final int userId;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final CategoryUncheckedCreateNestedManyWithoutProfileInput? categories;

  final TagUncheckedCreateNestedManyWithoutProfileInput? tags;

  final ChannelUncheckedCreateNestedManyWithoutOwnerInput? channels;

  final TaskAssignmentUncheckedCreateNestedManyWithoutProfileInput?
      taskAssignments;

  final ChannelSubscriptionUncheckedCreateNestedManyWithoutProfileInput?
      channelSubscriptions;

  final ScheduleUncheckedCreateNestedManyWithoutProfileInput? schedules;

  final RecordUncheckedCreateNestedManyWithoutProfileInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUncheckedCreateWithoutTasksInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateOrConnectWithoutTasksInput implements _i1.JsonSerializable {
  const ProfileCreateOrConnectWithoutTasksInput({
    required this.where,
    required this.create,
  });

  factory ProfileCreateOrConnectWithoutTasksInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateOrConnectWithoutTasksInputFromJson(json);

  final ProfileWhereUniqueInput where;

  final ProfileCreateWithoutTasksInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateOrConnectWithoutTasksInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateWithoutChildrenInput implements _i1.JsonSerializable {
  const TaskCreateWithoutChildrenInput({
    required this.uuid,
    required this.title,
    required this.desc,
    required this.content,
    this.location,
    required this.requireLocation,
    required this.requireTime,
    required this.requireAttachment,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    required this.owner,
    this.parent,
    this.channel,
    this.assets,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskCreateWithoutChildrenInput.fromJson(Map<String, dynamic> json) =>
      _$TaskCreateWithoutChildrenInputFromJson(json);

  final String uuid;

  final String title;

  final String desc;

  final String content;

  final String? location;

  final bool requireLocation;

  final bool requireTime;

  final bool requireAttachment;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final ProfileCreateNestedOneWithoutTasksInput owner;

  final TaskCreateNestedOneWithoutChildrenInput? parent;

  final ChannelCreateNestedOneWithoutTasksInput? channel;

  final TaskAssetCreateNestedManyWithoutTaskInput? assets;

  final TaskAssignmentCreateNestedManyWithoutTaskInput? assignments;

  final SessionCreateNestedManyWithoutTaskInput? sessions;

  final RecordCreateNestedManyWithoutTaskInput? records;

  @override
  Map<String, dynamic> toJson() => _$TaskCreateWithoutChildrenInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedCreateWithoutChildrenInput implements _i1.JsonSerializable {
  const TaskUncheckedCreateWithoutChildrenInput({
    required this.uuid,
    required this.title,
    required this.desc,
    required this.content,
    this.location,
    required this.requireLocation,
    required this.requireTime,
    required this.requireAttachment,
    required this.userId,
    required this.profile,
    this.parentUuid,
    this.channelUuid,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.assets,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskUncheckedCreateWithoutChildrenInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUncheckedCreateWithoutChildrenInputFromJson(json);

  final String uuid;

  final String title;

  final String desc;

  final String content;

  final String? location;

  final bool requireLocation;

  final bool requireTime;

  final bool requireAttachment;

  final int userId;

  final String profile;

  final String? parentUuid;

  final String? channelUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final TaskAssetUncheckedCreateNestedManyWithoutTaskInput? assets;

  final TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput? assignments;

  final SessionUncheckedCreateNestedManyWithoutTaskInput? sessions;

  final RecordUncheckedCreateNestedManyWithoutTaskInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUncheckedCreateWithoutChildrenInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateOrConnectWithoutChildrenInput implements _i1.JsonSerializable {
  const TaskCreateOrConnectWithoutChildrenInput({
    required this.where,
    required this.create,
  });

  factory TaskCreateOrConnectWithoutChildrenInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskCreateOrConnectWithoutChildrenInputFromJson(json);

  final TaskWhereUniqueInput where;

  final TaskCreateWithoutChildrenInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskCreateOrConnectWithoutChildrenInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateWithoutParentInput implements _i1.JsonSerializable {
  const TaskCreateWithoutParentInput({
    required this.uuid,
    required this.title,
    required this.desc,
    required this.content,
    this.location,
    required this.requireLocation,
    required this.requireTime,
    required this.requireAttachment,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    required this.owner,
    this.children,
    this.channel,
    this.assets,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskCreateWithoutParentInput.fromJson(Map<String, dynamic> json) =>
      _$TaskCreateWithoutParentInputFromJson(json);

  final String uuid;

  final String title;

  final String desc;

  final String content;

  final String? location;

  final bool requireLocation;

  final bool requireTime;

  final bool requireAttachment;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final ProfileCreateNestedOneWithoutTasksInput owner;

  final TaskCreateNestedManyWithoutParentInput? children;

  final ChannelCreateNestedOneWithoutTasksInput? channel;

  final TaskAssetCreateNestedManyWithoutTaskInput? assets;

  final TaskAssignmentCreateNestedManyWithoutTaskInput? assignments;

  final SessionCreateNestedManyWithoutTaskInput? sessions;

  final RecordCreateNestedManyWithoutTaskInput? records;

  @override
  Map<String, dynamic> toJson() => _$TaskCreateWithoutParentInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedCreateWithoutParentInput implements _i1.JsonSerializable {
  const TaskUncheckedCreateWithoutParentInput({
    required this.uuid,
    required this.title,
    required this.desc,
    required this.content,
    this.location,
    required this.requireLocation,
    required this.requireTime,
    required this.requireAttachment,
    required this.userId,
    required this.profile,
    this.channelUuid,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.children,
    this.assets,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskUncheckedCreateWithoutParentInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUncheckedCreateWithoutParentInputFromJson(json);

  final String uuid;

  final String title;

  final String desc;

  final String content;

  final String? location;

  final bool requireLocation;

  final bool requireTime;

  final bool requireAttachment;

  final int userId;

  final String profile;

  final String? channelUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final TaskUncheckedCreateNestedManyWithoutParentInput? children;

  final TaskAssetUncheckedCreateNestedManyWithoutTaskInput? assets;

  final TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput? assignments;

  final SessionUncheckedCreateNestedManyWithoutTaskInput? sessions;

  final RecordUncheckedCreateNestedManyWithoutTaskInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUncheckedCreateWithoutParentInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateOrConnectWithoutParentInput implements _i1.JsonSerializable {
  const TaskCreateOrConnectWithoutParentInput({
    required this.where,
    required this.create,
  });

  factory TaskCreateOrConnectWithoutParentInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskCreateOrConnectWithoutParentInputFromJson(json);

  final TaskWhereUniqueInput where;

  final TaskCreateWithoutParentInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskCreateOrConnectWithoutParentInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateManyParentInputEnvelope implements _i1.JsonSerializable {
  const TaskCreateManyParentInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  factory TaskCreateManyParentInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$TaskCreateManyParentInputEnvelopeFromJson(json);

  final Iterable<TaskCreateManyParentInput> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskCreateManyParentInputEnvelopeToJson(this);
}

@_i1.jsonSerializable
class ChannelCreateWithoutTasksInput implements _i1.JsonSerializable {
  const ChannelCreateWithoutTasksInput({
    required this.uuid,
    required this.name,
    required this.desc,
    required this.color,
    this.imgRef,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    required this.owner,
    this.subscriptions,
  });

  factory ChannelCreateWithoutTasksInput.fromJson(Map<String, dynamic> json) =>
      _$ChannelCreateWithoutTasksInputFromJson(json);

  final String uuid;

  final String name;

  final String desc;

  final String color;

  final String? imgRef;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final ProfileCreateNestedOneWithoutChannelsInput owner;

  final ChannelSubscriptionCreateNestedManyWithoutChannelInput? subscriptions;

  @override
  Map<String, dynamic> toJson() => _$ChannelCreateWithoutTasksInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUncheckedCreateWithoutTasksInput implements _i1.JsonSerializable {
  const ChannelUncheckedCreateWithoutTasksInput({
    required this.uuid,
    required this.name,
    required this.desc,
    required this.color,
    this.imgRef,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.subscriptions,
  });

  factory ChannelUncheckedCreateWithoutTasksInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelUncheckedCreateWithoutTasksInputFromJson(json);

  final String uuid;

  final String name;

  final String desc;

  final String color;

  final String? imgRef;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final ChannelSubscriptionUncheckedCreateNestedManyWithoutChannelInput?
      subscriptions;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelUncheckedCreateWithoutTasksInputToJson(this);
}

@_i1.jsonSerializable
class ChannelCreateOrConnectWithoutTasksInput implements _i1.JsonSerializable {
  const ChannelCreateOrConnectWithoutTasksInput({
    required this.where,
    required this.create,
  });

  factory ChannelCreateOrConnectWithoutTasksInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelCreateOrConnectWithoutTasksInputFromJson(json);

  final ChannelWhereUniqueInput where;

  final ChannelCreateWithoutTasksInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelCreateOrConnectWithoutTasksInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetCreateWithoutTaskInput implements _i1.JsonSerializable {
  const TaskAssetCreateWithoutTaskInput({
    required this.name,
    required this.hash,
    required this.assetRef,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
  });

  factory TaskAssetCreateWithoutTaskInput.fromJson(Map<String, dynamic> json) =>
      _$TaskAssetCreateWithoutTaskInputFromJson(json);

  final String name;

  final String hash;

  final String assetRef;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetCreateWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetUncheckedCreateWithoutTaskInput implements _i1.JsonSerializable {
  const TaskAssetUncheckedCreateWithoutTaskInput({
    required this.name,
    required this.hash,
    required this.assetRef,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
  });

  factory TaskAssetUncheckedCreateWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssetUncheckedCreateWithoutTaskInputFromJson(json);

  final String name;

  final String hash;

  final String assetRef;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetUncheckedCreateWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetCreateOrConnectWithoutTaskInput implements _i1.JsonSerializable {
  const TaskAssetCreateOrConnectWithoutTaskInput({
    required this.where,
    required this.create,
  });

  factory TaskAssetCreateOrConnectWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssetCreateOrConnectWithoutTaskInputFromJson(json);

  final TaskAssetWhereUniqueInput where;

  final TaskAssetCreateWithoutTaskInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetCreateOrConnectWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetCreateManyTaskInputEnvelope implements _i1.JsonSerializable {
  const TaskAssetCreateManyTaskInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  factory TaskAssetCreateManyTaskInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssetCreateManyTaskInputEnvelopeFromJson(json);

  final Iterable<TaskAssetCreateManyTaskInput> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetCreateManyTaskInputEnvelopeToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentCreateWithoutTaskInput implements _i1.JsonSerializable {
  const TaskAssignmentCreateWithoutTaskInput({
    required this.status,
    required this.priority,
    required this.starred,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    required this.profile,
    this.category,
    this.tags,
  });

  factory TaskAssignmentCreateWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentCreateWithoutTaskInputFromJson(json);

  final TaskAssignmentStatus status;

  final TaskPriority priority;

  final bool starred;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final ProfileCreateNestedOneWithoutTaskAssignmentsInput profile;

  final CategoryCreateNestedOneWithoutAssignmentsInput? category;

  final TaskAssignmentTagsCreateNestedManyWithoutAssignmentInput? tags;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentCreateWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUncheckedCreateWithoutTaskInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUncheckedCreateWithoutTaskInput({
    required this.status,
    required this.priority,
    required this.starred,
    required this.userId,
    required this.profileName,
    this.categoryName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    this.tags,
  });

  factory TaskAssignmentUncheckedCreateWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUncheckedCreateWithoutTaskInputFromJson(json);

  final TaskAssignmentStatus status;

  final TaskPriority priority;

  final bool starred;

  final int userId;

  final String profileName;

  final String? categoryName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final TaskAssignmentTagsUncheckedCreateNestedManyWithoutAssignmentInput? tags;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUncheckedCreateWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentCreateOrConnectWithoutTaskInput
    implements _i1.JsonSerializable {
  const TaskAssignmentCreateOrConnectWithoutTaskInput({
    required this.where,
    required this.create,
  });

  factory TaskAssignmentCreateOrConnectWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentCreateOrConnectWithoutTaskInputFromJson(json);

  final TaskAssignmentWhereUniqueInput where;

  final TaskAssignmentCreateWithoutTaskInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentCreateOrConnectWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentCreateManyTaskInputEnvelope
    implements _i1.JsonSerializable {
  const TaskAssignmentCreateManyTaskInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  factory TaskAssignmentCreateManyTaskInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentCreateManyTaskInputEnvelopeFromJson(json);

  final Iterable<TaskAssignmentCreateManyTaskInput> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentCreateManyTaskInputEnvelopeToJson(this);
}

@_i1.jsonSerializable
class SessionCreateWithoutTaskInput implements _i1.JsonSerializable {
  const SessionCreateWithoutTaskInput({
    required this.uuid,
    required this.start,
    required this.end,
    required this.cycle,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    this.schedules,
    this.records,
  });

  factory SessionCreateWithoutTaskInput.fromJson(Map<String, dynamic> json) =>
      _$SessionCreateWithoutTaskInputFromJson(json);

  final String uuid;

  final BigInt start;

  final BigInt end;

  final BigInt cycle;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final ScheduleCreateNestedManyWithoutSessionInput? schedules;

  final RecordCreateNestedManyWithoutSessionInput? records;

  @override
  Map<String, dynamic> toJson() => _$SessionCreateWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class SessionUncheckedCreateWithoutTaskInput implements _i1.JsonSerializable {
  const SessionUncheckedCreateWithoutTaskInput({
    required this.uuid,
    required this.start,
    required this.end,
    required this.cycle,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    this.schedules,
    this.records,
  });

  factory SessionUncheckedCreateWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionUncheckedCreateWithoutTaskInputFromJson(json);

  final String uuid;

  final BigInt start;

  final BigInt end;

  final BigInt cycle;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final ScheduleUncheckedCreateNestedManyWithoutSessionInput? schedules;

  final RecordUncheckedCreateNestedManyWithoutSessionInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionUncheckedCreateWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class SessionCreateOrConnectWithoutTaskInput implements _i1.JsonSerializable {
  const SessionCreateOrConnectWithoutTaskInput({
    required this.where,
    required this.create,
  });

  factory SessionCreateOrConnectWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionCreateOrConnectWithoutTaskInputFromJson(json);

  final SessionWhereUniqueInput where;

  final SessionCreateWithoutTaskInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionCreateOrConnectWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class SessionCreateManyTaskInputEnvelope implements _i1.JsonSerializable {
  const SessionCreateManyTaskInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  factory SessionCreateManyTaskInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$SessionCreateManyTaskInputEnvelopeFromJson(json);

  final Iterable<SessionCreateManyTaskInput> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionCreateManyTaskInputEnvelopeToJson(this);
}

@_i1.jsonSerializable
class RecordCreateWithoutTaskInput implements _i1.JsonSerializable {
  const RecordCreateWithoutTaskInput({
    required this.time,
    required this.recordIndex,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    required this.session,
    required this.profile,
    this.attachment,
  });

  factory RecordCreateWithoutTaskInput.fromJson(Map<String, dynamic> json) =>
      _$RecordCreateWithoutTaskInputFromJson(json);

  final BigInt time;

  final int recordIndex;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final SessionCreateNestedOneWithoutRecordsInput session;

  final ProfileCreateNestedOneWithoutRecordsInput profile;

  final RecordAttachmentCreateNestedOneWithoutRecordInput? attachment;

  @override
  Map<String, dynamic> toJson() => _$RecordCreateWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class RecordUncheckedCreateWithoutTaskInput implements _i1.JsonSerializable {
  const RecordUncheckedCreateWithoutTaskInput({
    required this.time,
    required this.recordIndex,
    required this.sessionUuid,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    this.attachment,
  });

  factory RecordUncheckedCreateWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUncheckedCreateWithoutTaskInputFromJson(json);

  final BigInt time;

  final int recordIndex;

  final String sessionUuid;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final RecordAttachmentUncheckedCreateNestedOneWithoutRecordInput? attachment;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUncheckedCreateWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class RecordCreateOrConnectWithoutTaskInput implements _i1.JsonSerializable {
  const RecordCreateOrConnectWithoutTaskInput({
    required this.where,
    required this.create,
  });

  factory RecordCreateOrConnectWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordCreateOrConnectWithoutTaskInputFromJson(json);

  final RecordWhereUniqueInput where;

  final RecordCreateWithoutTaskInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordCreateOrConnectWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class RecordCreateManyTaskInputEnvelope implements _i1.JsonSerializable {
  const RecordCreateManyTaskInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  factory RecordCreateManyTaskInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$RecordCreateManyTaskInputEnvelopeFromJson(json);

  final Iterable<RecordCreateManyTaskInput> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordCreateManyTaskInputEnvelopeToJson(this);
}

@_i1.jsonSerializable
class ProfileUpsertWithoutTasksInput implements _i1.JsonSerializable {
  const ProfileUpsertWithoutTasksInput({
    required this.update,
    required this.create,
  });

  factory ProfileUpsertWithoutTasksInput.fromJson(Map<String, dynamic> json) =>
      _$ProfileUpsertWithoutTasksInputFromJson(json);

  final ProfileUpdateWithoutTasksInput update;

  final ProfileCreateWithoutTasksInput create;

  @override
  Map<String, dynamic> toJson() => _$ProfileUpsertWithoutTasksInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpdateWithoutTasksInput implements _i1.JsonSerializable {
  const ProfileUpdateWithoutTasksInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.user,
    this.categories,
    this.tags,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileUpdateWithoutTasksInput.fromJson(Map<String, dynamic> json) =>
      _$ProfileUpdateWithoutTasksInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final UserUpdateOneRequiredWithoutProfilesNestedInput? user;

  final CategoryUpdateManyWithoutProfileNestedInput? categories;

  final TagUpdateManyWithoutProfileNestedInput? tags;

  final ChannelUpdateManyWithoutOwnerNestedInput? channels;

  final TaskAssignmentUpdateManyWithoutProfileNestedInput? taskAssignments;

  final ChannelSubscriptionUpdateManyWithoutProfileNestedInput?
      channelSubscriptions;

  final ScheduleUpdateManyWithoutProfileNestedInput? schedules;

  final RecordUpdateManyWithoutProfileNestedInput? records;

  @override
  Map<String, dynamic> toJson() => _$ProfileUpdateWithoutTasksInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUncheckedUpdateWithoutTasksInput implements _i1.JsonSerializable {
  const ProfileUncheckedUpdateWithoutTasksInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.categories,
    this.tags,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileUncheckedUpdateWithoutTasksInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUncheckedUpdateWithoutTasksInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final IntFieldUpdateOperationsInput? userId;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final CategoryUncheckedUpdateManyWithoutProfileNestedInput? categories;

  final TagUncheckedUpdateManyWithoutProfileNestedInput? tags;

  final ChannelUncheckedUpdateManyWithoutOwnerNestedInput? channels;

  final TaskAssignmentUncheckedUpdateManyWithoutProfileNestedInput?
      taskAssignments;

  final ChannelSubscriptionUncheckedUpdateManyWithoutProfileNestedInput?
      channelSubscriptions;

  final ScheduleUncheckedUpdateManyWithoutProfileNestedInput? schedules;

  final RecordUncheckedUpdateManyWithoutProfileNestedInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUncheckedUpdateWithoutTasksInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpsertWithoutChildrenInput implements _i1.JsonSerializable {
  const TaskUpsertWithoutChildrenInput({
    required this.update,
    required this.create,
  });

  factory TaskUpsertWithoutChildrenInput.fromJson(Map<String, dynamic> json) =>
      _$TaskUpsertWithoutChildrenInputFromJson(json);

  final TaskUpdateWithoutChildrenInput update;

  final TaskCreateWithoutChildrenInput create;

  @override
  Map<String, dynamic> toJson() => _$TaskUpsertWithoutChildrenInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpdateWithoutChildrenInput implements _i1.JsonSerializable {
  const TaskUpdateWithoutChildrenInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.owner,
    this.parent,
    this.channel,
    this.assets,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskUpdateWithoutChildrenInput.fromJson(Map<String, dynamic> json) =>
      _$TaskUpdateWithoutChildrenInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? title;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? content;

  final NullableStringFieldUpdateOperationsInput? location;

  final BoolFieldUpdateOperationsInput? requireLocation;

  final BoolFieldUpdateOperationsInput? requireTime;

  final BoolFieldUpdateOperationsInput? requireAttachment;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ProfileUpdateOneRequiredWithoutTasksNestedInput? owner;

  final TaskUpdateOneWithoutChildrenNestedInput? parent;

  final ChannelUpdateOneWithoutTasksNestedInput? channel;

  final TaskAssetUpdateManyWithoutTaskNestedInput? assets;

  final TaskAssignmentUpdateManyWithoutTaskNestedInput? assignments;

  final SessionUpdateManyWithoutTaskNestedInput? sessions;

  final RecordUpdateManyWithoutTaskNestedInput? records;

  @override
  Map<String, dynamic> toJson() => _$TaskUpdateWithoutChildrenInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedUpdateWithoutChildrenInput implements _i1.JsonSerializable {
  const TaskUncheckedUpdateWithoutChildrenInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.userId,
    this.profile,
    this.parentUuid,
    this.channelUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.assets,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskUncheckedUpdateWithoutChildrenInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUncheckedUpdateWithoutChildrenInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? title;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? content;

  final NullableStringFieldUpdateOperationsInput? location;

  final BoolFieldUpdateOperationsInput? requireLocation;

  final BoolFieldUpdateOperationsInput? requireTime;

  final BoolFieldUpdateOperationsInput? requireAttachment;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profile;

  final NullableStringFieldUpdateOperationsInput? parentUuid;

  final NullableStringFieldUpdateOperationsInput? channelUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskAssetUncheckedUpdateManyWithoutTaskNestedInput? assets;

  final TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput? assignments;

  final SessionUncheckedUpdateManyWithoutTaskNestedInput? sessions;

  final RecordUncheckedUpdateManyWithoutTaskNestedInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUncheckedUpdateWithoutChildrenInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpsertWithWhereUniqueWithoutParentInput
    implements _i1.JsonSerializable {
  const TaskUpsertWithWhereUniqueWithoutParentInput({
    required this.where,
    required this.update,
    required this.create,
  });

  factory TaskUpsertWithWhereUniqueWithoutParentInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUpsertWithWhereUniqueWithoutParentInputFromJson(json);

  final TaskWhereUniqueInput where;

  final TaskUpdateWithoutParentInput update;

  final TaskCreateWithoutParentInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUpsertWithWhereUniqueWithoutParentInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpdateWithWhereUniqueWithoutParentInput
    implements _i1.JsonSerializable {
  const TaskUpdateWithWhereUniqueWithoutParentInput({
    required this.where,
    required this.data,
  });

  factory TaskUpdateWithWhereUniqueWithoutParentInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUpdateWithWhereUniqueWithoutParentInputFromJson(json);

  final TaskWhereUniqueInput where;

  final TaskUpdateWithoutParentInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUpdateWithWhereUniqueWithoutParentInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpdateManyWithWhereWithoutParentInput
    implements _i1.JsonSerializable {
  const TaskUpdateManyWithWhereWithoutParentInput({
    required this.where,
    required this.data,
  });

  factory TaskUpdateManyWithWhereWithoutParentInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUpdateManyWithWhereWithoutParentInputFromJson(json);

  final TaskScalarWhereInput where;

  final TaskUpdateManyMutationInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUpdateManyWithWhereWithoutParentInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUpsertWithoutTasksInput implements _i1.JsonSerializable {
  const ChannelUpsertWithoutTasksInput({
    required this.update,
    required this.create,
  });

  factory ChannelUpsertWithoutTasksInput.fromJson(Map<String, dynamic> json) =>
      _$ChannelUpsertWithoutTasksInputFromJson(json);

  final ChannelUpdateWithoutTasksInput update;

  final ChannelCreateWithoutTasksInput create;

  @override
  Map<String, dynamic> toJson() => _$ChannelUpsertWithoutTasksInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUpdateWithoutTasksInput implements _i1.JsonSerializable {
  const ChannelUpdateWithoutTasksInput({
    this.uuid,
    this.name,
    this.desc,
    this.color,
    this.imgRef,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.owner,
    this.subscriptions,
  });

  factory ChannelUpdateWithoutTasksInput.fromJson(Map<String, dynamic> json) =>
      _$ChannelUpdateWithoutTasksInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? color;

  final NullableStringFieldUpdateOperationsInput? imgRef;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ProfileUpdateOneRequiredWithoutChannelsNestedInput? owner;

  final ChannelSubscriptionUpdateManyWithoutChannelNestedInput? subscriptions;

  @override
  Map<String, dynamic> toJson() => _$ChannelUpdateWithoutTasksInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUncheckedUpdateWithoutTasksInput implements _i1.JsonSerializable {
  const ChannelUncheckedUpdateWithoutTasksInput({
    this.uuid,
    this.name,
    this.desc,
    this.color,
    this.imgRef,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.subscriptions,
  });

  factory ChannelUncheckedUpdateWithoutTasksInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelUncheckedUpdateWithoutTasksInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? color;

  final NullableStringFieldUpdateOperationsInput? imgRef;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ChannelSubscriptionUncheckedUpdateManyWithoutChannelNestedInput?
      subscriptions;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelUncheckedUpdateWithoutTasksInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetUpsertWithWhereUniqueWithoutTaskInput
    implements _i1.JsonSerializable {
  const TaskAssetUpsertWithWhereUniqueWithoutTaskInput({
    required this.where,
    required this.update,
    required this.create,
  });

  factory TaskAssetUpsertWithWhereUniqueWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssetUpsertWithWhereUniqueWithoutTaskInputFromJson(json);

  final TaskAssetWhereUniqueInput where;

  final TaskAssetUpdateWithoutTaskInput update;

  final TaskAssetCreateWithoutTaskInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetUpsertWithWhereUniqueWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetUpdateWithWhereUniqueWithoutTaskInput
    implements _i1.JsonSerializable {
  const TaskAssetUpdateWithWhereUniqueWithoutTaskInput({
    required this.where,
    required this.data,
  });

  factory TaskAssetUpdateWithWhereUniqueWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssetUpdateWithWhereUniqueWithoutTaskInputFromJson(json);

  final TaskAssetWhereUniqueInput where;

  final TaskAssetUpdateWithoutTaskInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetUpdateWithWhereUniqueWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetUpdateManyWithWhereWithoutTaskInput
    implements _i1.JsonSerializable {
  const TaskAssetUpdateManyWithWhereWithoutTaskInput({
    required this.where,
    required this.data,
  });

  factory TaskAssetUpdateManyWithWhereWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssetUpdateManyWithWhereWithoutTaskInputFromJson(json);

  final TaskAssetScalarWhereInput where;

  final TaskAssetUpdateManyMutationInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetUpdateManyWithWhereWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetScalarWhereInput implements _i1.JsonSerializable {
  const TaskAssetScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.name,
    this.hash,
    this.assetRef,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssetScalarWhereInput.fromJson(Map<String, dynamic> json) =>
      _$TaskAssetScalarWhereInputFromJson(json);

  final Iterable<TaskAssetScalarWhereInput>? AND;

  final Iterable<TaskAssetScalarWhereInput>? OR;

  final Iterable<TaskAssetScalarWhereInput>? NOT;

  final StringFilter? name;

  final StringFilter? hash;

  final StringFilter? assetRef;

  final StringFilter? taskUuid;

  final BigIntFilter? updateAt;

  final BigIntFilter? syncAt;

  final BigIntFilter? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TaskAssetScalarWhereInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUpsertWithWhereUniqueWithoutTaskInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUpsertWithWhereUniqueWithoutTaskInput({
    required this.where,
    required this.update,
    required this.create,
  });

  factory TaskAssignmentUpsertWithWhereUniqueWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUpsertWithWhereUniqueWithoutTaskInputFromJson(json);

  final TaskAssignmentWhereUniqueInput where;

  final TaskAssignmentUpdateWithoutTaskInput update;

  final TaskAssignmentCreateWithoutTaskInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUpsertWithWhereUniqueWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUpdateWithWhereUniqueWithoutTaskInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUpdateWithWhereUniqueWithoutTaskInput({
    required this.where,
    required this.data,
  });

  factory TaskAssignmentUpdateWithWhereUniqueWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUpdateWithWhereUniqueWithoutTaskInputFromJson(json);

  final TaskAssignmentWhereUniqueInput where;

  final TaskAssignmentUpdateWithoutTaskInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUpdateWithWhereUniqueWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUpdateManyWithWhereWithoutTaskInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUpdateManyWithWhereWithoutTaskInput({
    required this.where,
    required this.data,
  });

  factory TaskAssignmentUpdateManyWithWhereWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUpdateManyWithWhereWithoutTaskInputFromJson(json);

  final TaskAssignmentScalarWhereInput where;

  final TaskAssignmentUpdateManyMutationInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUpdateManyWithWhereWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class SessionUpsertWithWhereUniqueWithoutTaskInput
    implements _i1.JsonSerializable {
  const SessionUpsertWithWhereUniqueWithoutTaskInput({
    required this.where,
    required this.update,
    required this.create,
  });

  factory SessionUpsertWithWhereUniqueWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionUpsertWithWhereUniqueWithoutTaskInputFromJson(json);

  final SessionWhereUniqueInput where;

  final SessionUpdateWithoutTaskInput update;

  final SessionCreateWithoutTaskInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionUpsertWithWhereUniqueWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class SessionUpdateWithWhereUniqueWithoutTaskInput
    implements _i1.JsonSerializable {
  const SessionUpdateWithWhereUniqueWithoutTaskInput({
    required this.where,
    required this.data,
  });

  factory SessionUpdateWithWhereUniqueWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionUpdateWithWhereUniqueWithoutTaskInputFromJson(json);

  final SessionWhereUniqueInput where;

  final SessionUpdateWithoutTaskInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionUpdateWithWhereUniqueWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class SessionUpdateManyWithWhereWithoutTaskInput
    implements _i1.JsonSerializable {
  const SessionUpdateManyWithWhereWithoutTaskInput({
    required this.where,
    required this.data,
  });

  factory SessionUpdateManyWithWhereWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionUpdateManyWithWhereWithoutTaskInputFromJson(json);

  final SessionScalarWhereInput where;

  final SessionUpdateManyMutationInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionUpdateManyWithWhereWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class SessionScalarWhereInput implements _i1.JsonSerializable {
  const SessionScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.start,
    this.end,
    this.cycle,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory SessionScalarWhereInput.fromJson(Map<String, dynamic> json) =>
      _$SessionScalarWhereInputFromJson(json);

  final Iterable<SessionScalarWhereInput>? AND;

  final Iterable<SessionScalarWhereInput>? OR;

  final Iterable<SessionScalarWhereInput>? NOT;

  final StringFilter? uuid;

  final BigIntFilter? start;

  final BigIntFilter? end;

  final BigIntFilter? cycle;

  final StringFilter? taskUuid;

  final BigIntFilter? updateAt;

  final BigIntFilter? syncAt;

  final BigIntFilter? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$SessionScalarWhereInputToJson(this);
}

@_i1.jsonSerializable
class RecordUpsertWithWhereUniqueWithoutTaskInput
    implements _i1.JsonSerializable {
  const RecordUpsertWithWhereUniqueWithoutTaskInput({
    required this.where,
    required this.update,
    required this.create,
  });

  factory RecordUpsertWithWhereUniqueWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUpsertWithWhereUniqueWithoutTaskInputFromJson(json);

  final RecordWhereUniqueInput where;

  final RecordUpdateWithoutTaskInput update;

  final RecordCreateWithoutTaskInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUpsertWithWhereUniqueWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class RecordUpdateWithWhereUniqueWithoutTaskInput
    implements _i1.JsonSerializable {
  const RecordUpdateWithWhereUniqueWithoutTaskInput({
    required this.where,
    required this.data,
  });

  factory RecordUpdateWithWhereUniqueWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUpdateWithWhereUniqueWithoutTaskInputFromJson(json);

  final RecordWhereUniqueInput where;

  final RecordUpdateWithoutTaskInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUpdateWithWhereUniqueWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class RecordUpdateManyWithWhereWithoutTaskInput
    implements _i1.JsonSerializable {
  const RecordUpdateManyWithWhereWithoutTaskInput({
    required this.where,
    required this.data,
  });

  factory RecordUpdateManyWithWhereWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUpdateManyWithWhereWithoutTaskInputFromJson(json);

  final RecordScalarWhereInput where;

  final RecordUpdateManyMutationInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUpdateManyWithWhereWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateWithoutAssetsInput implements _i1.JsonSerializable {
  const TaskCreateWithoutAssetsInput({
    required this.uuid,
    required this.title,
    required this.desc,
    required this.content,
    this.location,
    required this.requireLocation,
    required this.requireTime,
    required this.requireAttachment,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    required this.owner,
    this.parent,
    this.children,
    this.channel,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskCreateWithoutAssetsInput.fromJson(Map<String, dynamic> json) =>
      _$TaskCreateWithoutAssetsInputFromJson(json);

  final String uuid;

  final String title;

  final String desc;

  final String content;

  final String? location;

  final bool requireLocation;

  final bool requireTime;

  final bool requireAttachment;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final ProfileCreateNestedOneWithoutTasksInput owner;

  final TaskCreateNestedOneWithoutChildrenInput? parent;

  final TaskCreateNestedManyWithoutParentInput? children;

  final ChannelCreateNestedOneWithoutTasksInput? channel;

  final TaskAssignmentCreateNestedManyWithoutTaskInput? assignments;

  final SessionCreateNestedManyWithoutTaskInput? sessions;

  final RecordCreateNestedManyWithoutTaskInput? records;

  @override
  Map<String, dynamic> toJson() => _$TaskCreateWithoutAssetsInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedCreateWithoutAssetsInput implements _i1.JsonSerializable {
  const TaskUncheckedCreateWithoutAssetsInput({
    required this.uuid,
    required this.title,
    required this.desc,
    required this.content,
    this.location,
    required this.requireLocation,
    required this.requireTime,
    required this.requireAttachment,
    required this.userId,
    required this.profile,
    this.parentUuid,
    this.channelUuid,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.children,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskUncheckedCreateWithoutAssetsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUncheckedCreateWithoutAssetsInputFromJson(json);

  final String uuid;

  final String title;

  final String desc;

  final String content;

  final String? location;

  final bool requireLocation;

  final bool requireTime;

  final bool requireAttachment;

  final int userId;

  final String profile;

  final String? parentUuid;

  final String? channelUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final TaskUncheckedCreateNestedManyWithoutParentInput? children;

  final TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput? assignments;

  final SessionUncheckedCreateNestedManyWithoutTaskInput? sessions;

  final RecordUncheckedCreateNestedManyWithoutTaskInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUncheckedCreateWithoutAssetsInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateOrConnectWithoutAssetsInput implements _i1.JsonSerializable {
  const TaskCreateOrConnectWithoutAssetsInput({
    required this.where,
    required this.create,
  });

  factory TaskCreateOrConnectWithoutAssetsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskCreateOrConnectWithoutAssetsInputFromJson(json);

  final TaskWhereUniqueInput where;

  final TaskCreateWithoutAssetsInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskCreateOrConnectWithoutAssetsInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpsertWithoutAssetsInput implements _i1.JsonSerializable {
  const TaskUpsertWithoutAssetsInput({
    required this.update,
    required this.create,
  });

  factory TaskUpsertWithoutAssetsInput.fromJson(Map<String, dynamic> json) =>
      _$TaskUpsertWithoutAssetsInputFromJson(json);

  final TaskUpdateWithoutAssetsInput update;

  final TaskCreateWithoutAssetsInput create;

  @override
  Map<String, dynamic> toJson() => _$TaskUpsertWithoutAssetsInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpdateWithoutAssetsInput implements _i1.JsonSerializable {
  const TaskUpdateWithoutAssetsInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.owner,
    this.parent,
    this.children,
    this.channel,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskUpdateWithoutAssetsInput.fromJson(Map<String, dynamic> json) =>
      _$TaskUpdateWithoutAssetsInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? title;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? content;

  final NullableStringFieldUpdateOperationsInput? location;

  final BoolFieldUpdateOperationsInput? requireLocation;

  final BoolFieldUpdateOperationsInput? requireTime;

  final BoolFieldUpdateOperationsInput? requireAttachment;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ProfileUpdateOneRequiredWithoutTasksNestedInput? owner;

  final TaskUpdateOneWithoutChildrenNestedInput? parent;

  final TaskUpdateManyWithoutParentNestedInput? children;

  final ChannelUpdateOneWithoutTasksNestedInput? channel;

  final TaskAssignmentUpdateManyWithoutTaskNestedInput? assignments;

  final SessionUpdateManyWithoutTaskNestedInput? sessions;

  final RecordUpdateManyWithoutTaskNestedInput? records;

  @override
  Map<String, dynamic> toJson() => _$TaskUpdateWithoutAssetsInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedUpdateWithoutAssetsInput implements _i1.JsonSerializable {
  const TaskUncheckedUpdateWithoutAssetsInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.userId,
    this.profile,
    this.parentUuid,
    this.channelUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.children,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskUncheckedUpdateWithoutAssetsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUncheckedUpdateWithoutAssetsInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? title;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? content;

  final NullableStringFieldUpdateOperationsInput? location;

  final BoolFieldUpdateOperationsInput? requireLocation;

  final BoolFieldUpdateOperationsInput? requireTime;

  final BoolFieldUpdateOperationsInput? requireAttachment;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profile;

  final NullableStringFieldUpdateOperationsInput? parentUuid;

  final NullableStringFieldUpdateOperationsInput? channelUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskUncheckedUpdateManyWithoutParentNestedInput? children;

  final TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput? assignments;

  final SessionUncheckedUpdateManyWithoutTaskNestedInput? sessions;

  final RecordUncheckedUpdateManyWithoutTaskNestedInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUncheckedUpdateWithoutAssetsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateWithoutChannelsInput implements _i1.JsonSerializable {
  const ProfileCreateWithoutChannelsInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    required this.user,
    this.categories,
    this.tags,
    this.tasks,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileCreateWithoutChannelsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateWithoutChannelsInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final UserCreateNestedOneWithoutProfilesInput user;

  final CategoryCreateNestedManyWithoutProfileInput? categories;

  final TagCreateNestedManyWithoutProfileInput? tags;

  final TaskCreateNestedManyWithoutOwnerInput? tasks;

  final TaskAssignmentCreateNestedManyWithoutProfileInput? taskAssignments;

  final ChannelSubscriptionCreateNestedManyWithoutProfileInput?
      channelSubscriptions;

  final ScheduleCreateNestedManyWithoutProfileInput? schedules;

  final RecordCreateNestedManyWithoutProfileInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateWithoutChannelsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUncheckedCreateWithoutChannelsInput
    implements _i1.JsonSerializable {
  const ProfileUncheckedCreateWithoutChannelsInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.userId,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.categories,
    this.tags,
    this.tasks,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileUncheckedCreateWithoutChannelsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUncheckedCreateWithoutChannelsInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final int userId;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final CategoryUncheckedCreateNestedManyWithoutProfileInput? categories;

  final TagUncheckedCreateNestedManyWithoutProfileInput? tags;

  final TaskUncheckedCreateNestedManyWithoutOwnerInput? tasks;

  final TaskAssignmentUncheckedCreateNestedManyWithoutProfileInput?
      taskAssignments;

  final ChannelSubscriptionUncheckedCreateNestedManyWithoutProfileInput?
      channelSubscriptions;

  final ScheduleUncheckedCreateNestedManyWithoutProfileInput? schedules;

  final RecordUncheckedCreateNestedManyWithoutProfileInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUncheckedCreateWithoutChannelsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateOrConnectWithoutChannelsInput
    implements _i1.JsonSerializable {
  const ProfileCreateOrConnectWithoutChannelsInput({
    required this.where,
    required this.create,
  });

  factory ProfileCreateOrConnectWithoutChannelsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateOrConnectWithoutChannelsInputFromJson(json);

  final ProfileWhereUniqueInput where;

  final ProfileCreateWithoutChannelsInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateOrConnectWithoutChannelsInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionCreateWithoutChannelInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionCreateWithoutChannelInput({
    required this.shareRecord,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    required this.profile,
  });

  factory ChannelSubscriptionCreateWithoutChannelInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionCreateWithoutChannelInputFromJson(json);

  final bool shareRecord;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final ProfileCreateNestedOneWithoutChannelSubscriptionsInput profile;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionCreateWithoutChannelInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUncheckedCreateWithoutChannelInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionUncheckedCreateWithoutChannelInput({
    required this.shareRecord,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory ChannelSubscriptionUncheckedCreateWithoutChannelInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionUncheckedCreateWithoutChannelInputFromJson(json);

  final bool shareRecord;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionUncheckedCreateWithoutChannelInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionCreateOrConnectWithoutChannelInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionCreateOrConnectWithoutChannelInput({
    required this.where,
    required this.create,
  });

  factory ChannelSubscriptionCreateOrConnectWithoutChannelInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionCreateOrConnectWithoutChannelInputFromJson(json);

  final ChannelSubscriptionWhereUniqueInput where;

  final ChannelSubscriptionCreateWithoutChannelInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionCreateOrConnectWithoutChannelInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionCreateManyChannelInputEnvelope
    implements _i1.JsonSerializable {
  const ChannelSubscriptionCreateManyChannelInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  factory ChannelSubscriptionCreateManyChannelInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionCreateManyChannelInputEnvelopeFromJson(json);

  final Iterable<ChannelSubscriptionCreateManyChannelInput> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionCreateManyChannelInputEnvelopeToJson(this);
}

@_i1.jsonSerializable
class TaskCreateWithoutChannelInput implements _i1.JsonSerializable {
  const TaskCreateWithoutChannelInput({
    required this.uuid,
    required this.title,
    required this.desc,
    required this.content,
    this.location,
    required this.requireLocation,
    required this.requireTime,
    required this.requireAttachment,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    required this.owner,
    this.parent,
    this.children,
    this.assets,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskCreateWithoutChannelInput.fromJson(Map<String, dynamic> json) =>
      _$TaskCreateWithoutChannelInputFromJson(json);

  final String uuid;

  final String title;

  final String desc;

  final String content;

  final String? location;

  final bool requireLocation;

  final bool requireTime;

  final bool requireAttachment;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final ProfileCreateNestedOneWithoutTasksInput owner;

  final TaskCreateNestedOneWithoutChildrenInput? parent;

  final TaskCreateNestedManyWithoutParentInput? children;

  final TaskAssetCreateNestedManyWithoutTaskInput? assets;

  final TaskAssignmentCreateNestedManyWithoutTaskInput? assignments;

  final SessionCreateNestedManyWithoutTaskInput? sessions;

  final RecordCreateNestedManyWithoutTaskInput? records;

  @override
  Map<String, dynamic> toJson() => _$TaskCreateWithoutChannelInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedCreateWithoutChannelInput implements _i1.JsonSerializable {
  const TaskUncheckedCreateWithoutChannelInput({
    required this.uuid,
    required this.title,
    required this.desc,
    required this.content,
    this.location,
    required this.requireLocation,
    required this.requireTime,
    required this.requireAttachment,
    required this.userId,
    required this.profile,
    this.parentUuid,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.children,
    this.assets,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskUncheckedCreateWithoutChannelInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUncheckedCreateWithoutChannelInputFromJson(json);

  final String uuid;

  final String title;

  final String desc;

  final String content;

  final String? location;

  final bool requireLocation;

  final bool requireTime;

  final bool requireAttachment;

  final int userId;

  final String profile;

  final String? parentUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final TaskUncheckedCreateNestedManyWithoutParentInput? children;

  final TaskAssetUncheckedCreateNestedManyWithoutTaskInput? assets;

  final TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput? assignments;

  final SessionUncheckedCreateNestedManyWithoutTaskInput? sessions;

  final RecordUncheckedCreateNestedManyWithoutTaskInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUncheckedCreateWithoutChannelInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateOrConnectWithoutChannelInput implements _i1.JsonSerializable {
  const TaskCreateOrConnectWithoutChannelInput({
    required this.where,
    required this.create,
  });

  factory TaskCreateOrConnectWithoutChannelInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskCreateOrConnectWithoutChannelInputFromJson(json);

  final TaskWhereUniqueInput where;

  final TaskCreateWithoutChannelInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskCreateOrConnectWithoutChannelInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateManyChannelInputEnvelope implements _i1.JsonSerializable {
  const TaskCreateManyChannelInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  factory TaskCreateManyChannelInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$TaskCreateManyChannelInputEnvelopeFromJson(json);

  final Iterable<TaskCreateManyChannelInput> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskCreateManyChannelInputEnvelopeToJson(this);
}

@_i1.jsonSerializable
class ProfileUpsertWithoutChannelsInput implements _i1.JsonSerializable {
  const ProfileUpsertWithoutChannelsInput({
    required this.update,
    required this.create,
  });

  factory ProfileUpsertWithoutChannelsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUpsertWithoutChannelsInputFromJson(json);

  final ProfileUpdateWithoutChannelsInput update;

  final ProfileCreateWithoutChannelsInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUpsertWithoutChannelsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpdateWithoutChannelsInput implements _i1.JsonSerializable {
  const ProfileUpdateWithoutChannelsInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.user,
    this.categories,
    this.tags,
    this.tasks,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileUpdateWithoutChannelsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUpdateWithoutChannelsInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final UserUpdateOneRequiredWithoutProfilesNestedInput? user;

  final CategoryUpdateManyWithoutProfileNestedInput? categories;

  final TagUpdateManyWithoutProfileNestedInput? tags;

  final TaskUpdateManyWithoutOwnerNestedInput? tasks;

  final TaskAssignmentUpdateManyWithoutProfileNestedInput? taskAssignments;

  final ChannelSubscriptionUpdateManyWithoutProfileNestedInput?
      channelSubscriptions;

  final ScheduleUpdateManyWithoutProfileNestedInput? schedules;

  final RecordUpdateManyWithoutProfileNestedInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUpdateWithoutChannelsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUncheckedUpdateWithoutChannelsInput
    implements _i1.JsonSerializable {
  const ProfileUncheckedUpdateWithoutChannelsInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.categories,
    this.tags,
    this.tasks,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileUncheckedUpdateWithoutChannelsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUncheckedUpdateWithoutChannelsInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final IntFieldUpdateOperationsInput? userId;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final CategoryUncheckedUpdateManyWithoutProfileNestedInput? categories;

  final TagUncheckedUpdateManyWithoutProfileNestedInput? tags;

  final TaskUncheckedUpdateManyWithoutOwnerNestedInput? tasks;

  final TaskAssignmentUncheckedUpdateManyWithoutProfileNestedInput?
      taskAssignments;

  final ChannelSubscriptionUncheckedUpdateManyWithoutProfileNestedInput?
      channelSubscriptions;

  final ScheduleUncheckedUpdateManyWithoutProfileNestedInput? schedules;

  final RecordUncheckedUpdateManyWithoutProfileNestedInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUncheckedUpdateWithoutChannelsInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUpsertWithWhereUniqueWithoutChannelInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionUpsertWithWhereUniqueWithoutChannelInput({
    required this.where,
    required this.update,
    required this.create,
  });

  factory ChannelSubscriptionUpsertWithWhereUniqueWithoutChannelInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionUpsertWithWhereUniqueWithoutChannelInputFromJson(
          json);

  final ChannelSubscriptionWhereUniqueInput where;

  final ChannelSubscriptionUpdateWithoutChannelInput update;

  final ChannelSubscriptionCreateWithoutChannelInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionUpsertWithWhereUniqueWithoutChannelInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUpdateWithWhereUniqueWithoutChannelInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionUpdateWithWhereUniqueWithoutChannelInput({
    required this.where,
    required this.data,
  });

  factory ChannelSubscriptionUpdateWithWhereUniqueWithoutChannelInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionUpdateWithWhereUniqueWithoutChannelInputFromJson(
          json);

  final ChannelSubscriptionWhereUniqueInput where;

  final ChannelSubscriptionUpdateWithoutChannelInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionUpdateWithWhereUniqueWithoutChannelInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUpdateManyWithWhereWithoutChannelInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionUpdateManyWithWhereWithoutChannelInput({
    required this.where,
    required this.data,
  });

  factory ChannelSubscriptionUpdateManyWithWhereWithoutChannelInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionUpdateManyWithWhereWithoutChannelInputFromJson(json);

  final ChannelSubscriptionScalarWhereInput where;

  final ChannelSubscriptionUpdateManyMutationInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionUpdateManyWithWhereWithoutChannelInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpsertWithWhereUniqueWithoutChannelInput
    implements _i1.JsonSerializable {
  const TaskUpsertWithWhereUniqueWithoutChannelInput({
    required this.where,
    required this.update,
    required this.create,
  });

  factory TaskUpsertWithWhereUniqueWithoutChannelInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUpsertWithWhereUniqueWithoutChannelInputFromJson(json);

  final TaskWhereUniqueInput where;

  final TaskUpdateWithoutChannelInput update;

  final TaskCreateWithoutChannelInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUpsertWithWhereUniqueWithoutChannelInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpdateWithWhereUniqueWithoutChannelInput
    implements _i1.JsonSerializable {
  const TaskUpdateWithWhereUniqueWithoutChannelInput({
    required this.where,
    required this.data,
  });

  factory TaskUpdateWithWhereUniqueWithoutChannelInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUpdateWithWhereUniqueWithoutChannelInputFromJson(json);

  final TaskWhereUniqueInput where;

  final TaskUpdateWithoutChannelInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUpdateWithWhereUniqueWithoutChannelInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpdateManyWithWhereWithoutChannelInput
    implements _i1.JsonSerializable {
  const TaskUpdateManyWithWhereWithoutChannelInput({
    required this.where,
    required this.data,
  });

  factory TaskUpdateManyWithWhereWithoutChannelInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUpdateManyWithWhereWithoutChannelInputFromJson(json);

  final TaskScalarWhereInput where;

  final TaskUpdateManyMutationInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUpdateManyWithWhereWithoutChannelInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateWithoutSessionsInput implements _i1.JsonSerializable {
  const TaskCreateWithoutSessionsInput({
    required this.uuid,
    required this.title,
    required this.desc,
    required this.content,
    this.location,
    required this.requireLocation,
    required this.requireTime,
    required this.requireAttachment,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    required this.owner,
    this.parent,
    this.children,
    this.channel,
    this.assets,
    this.assignments,
    this.records,
  });

  factory TaskCreateWithoutSessionsInput.fromJson(Map<String, dynamic> json) =>
      _$TaskCreateWithoutSessionsInputFromJson(json);

  final String uuid;

  final String title;

  final String desc;

  final String content;

  final String? location;

  final bool requireLocation;

  final bool requireTime;

  final bool requireAttachment;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final ProfileCreateNestedOneWithoutTasksInput owner;

  final TaskCreateNestedOneWithoutChildrenInput? parent;

  final TaskCreateNestedManyWithoutParentInput? children;

  final ChannelCreateNestedOneWithoutTasksInput? channel;

  final TaskAssetCreateNestedManyWithoutTaskInput? assets;

  final TaskAssignmentCreateNestedManyWithoutTaskInput? assignments;

  final RecordCreateNestedManyWithoutTaskInput? records;

  @override
  Map<String, dynamic> toJson() => _$TaskCreateWithoutSessionsInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedCreateWithoutSessionsInput implements _i1.JsonSerializable {
  const TaskUncheckedCreateWithoutSessionsInput({
    required this.uuid,
    required this.title,
    required this.desc,
    required this.content,
    this.location,
    required this.requireLocation,
    required this.requireTime,
    required this.requireAttachment,
    required this.userId,
    required this.profile,
    this.parentUuid,
    this.channelUuid,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.children,
    this.assets,
    this.assignments,
    this.records,
  });

  factory TaskUncheckedCreateWithoutSessionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUncheckedCreateWithoutSessionsInputFromJson(json);

  final String uuid;

  final String title;

  final String desc;

  final String content;

  final String? location;

  final bool requireLocation;

  final bool requireTime;

  final bool requireAttachment;

  final int userId;

  final String profile;

  final String? parentUuid;

  final String? channelUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final TaskUncheckedCreateNestedManyWithoutParentInput? children;

  final TaskAssetUncheckedCreateNestedManyWithoutTaskInput? assets;

  final TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput? assignments;

  final RecordUncheckedCreateNestedManyWithoutTaskInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUncheckedCreateWithoutSessionsInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateOrConnectWithoutSessionsInput implements _i1.JsonSerializable {
  const TaskCreateOrConnectWithoutSessionsInput({
    required this.where,
    required this.create,
  });

  factory TaskCreateOrConnectWithoutSessionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskCreateOrConnectWithoutSessionsInputFromJson(json);

  final TaskWhereUniqueInput where;

  final TaskCreateWithoutSessionsInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskCreateOrConnectWithoutSessionsInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleCreateWithoutSessionInput implements _i1.JsonSerializable {
  const ScheduleCreateWithoutSessionInput({
    required this.relStart,
    required this.relEnd,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    required this.profile,
  });

  factory ScheduleCreateWithoutSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleCreateWithoutSessionInputFromJson(json);

  final BigInt relStart;

  final BigInt relEnd;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final ProfileCreateNestedOneWithoutSchedulesInput profile;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleCreateWithoutSessionInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleUncheckedCreateWithoutSessionInput
    implements _i1.JsonSerializable {
  const ScheduleUncheckedCreateWithoutSessionInput({
    required this.relStart,
    required this.relEnd,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory ScheduleUncheckedCreateWithoutSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleUncheckedCreateWithoutSessionInputFromJson(json);

  final BigInt relStart;

  final BigInt relEnd;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleUncheckedCreateWithoutSessionInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleCreateOrConnectWithoutSessionInput
    implements _i1.JsonSerializable {
  const ScheduleCreateOrConnectWithoutSessionInput({
    required this.where,
    required this.create,
  });

  factory ScheduleCreateOrConnectWithoutSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleCreateOrConnectWithoutSessionInputFromJson(json);

  final ScheduleWhereUniqueInput where;

  final ScheduleCreateWithoutSessionInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleCreateOrConnectWithoutSessionInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleCreateManySessionInputEnvelope implements _i1.JsonSerializable {
  const ScheduleCreateManySessionInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  factory ScheduleCreateManySessionInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleCreateManySessionInputEnvelopeFromJson(json);

  final Iterable<ScheduleCreateManySessionInput> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleCreateManySessionInputEnvelopeToJson(this);
}

@_i1.jsonSerializable
class RecordCreateWithoutSessionInput implements _i1.JsonSerializable {
  const RecordCreateWithoutSessionInput({
    required this.time,
    required this.recordIndex,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    required this.task,
    required this.profile,
    this.attachment,
  });

  factory RecordCreateWithoutSessionInput.fromJson(Map<String, dynamic> json) =>
      _$RecordCreateWithoutSessionInputFromJson(json);

  final BigInt time;

  final int recordIndex;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final TaskCreateNestedOneWithoutRecordsInput task;

  final ProfileCreateNestedOneWithoutRecordsInput profile;

  final RecordAttachmentCreateNestedOneWithoutRecordInput? attachment;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordCreateWithoutSessionInputToJson(this);
}

@_i1.jsonSerializable
class RecordUncheckedCreateWithoutSessionInput implements _i1.JsonSerializable {
  const RecordUncheckedCreateWithoutSessionInput({
    required this.time,
    required this.recordIndex,
    required this.taskUuid,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    this.attachment,
  });

  factory RecordUncheckedCreateWithoutSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUncheckedCreateWithoutSessionInputFromJson(json);

  final BigInt time;

  final int recordIndex;

  final String taskUuid;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final RecordAttachmentUncheckedCreateNestedOneWithoutRecordInput? attachment;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUncheckedCreateWithoutSessionInputToJson(this);
}

@_i1.jsonSerializable
class RecordCreateOrConnectWithoutSessionInput implements _i1.JsonSerializable {
  const RecordCreateOrConnectWithoutSessionInput({
    required this.where,
    required this.create,
  });

  factory RecordCreateOrConnectWithoutSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordCreateOrConnectWithoutSessionInputFromJson(json);

  final RecordWhereUniqueInput where;

  final RecordCreateWithoutSessionInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordCreateOrConnectWithoutSessionInputToJson(this);
}

@_i1.jsonSerializable
class RecordCreateManySessionInputEnvelope implements _i1.JsonSerializable {
  const RecordCreateManySessionInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  factory RecordCreateManySessionInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$RecordCreateManySessionInputEnvelopeFromJson(json);

  final Iterable<RecordCreateManySessionInput> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordCreateManySessionInputEnvelopeToJson(this);
}

@_i1.jsonSerializable
class TaskUpsertWithoutSessionsInput implements _i1.JsonSerializable {
  const TaskUpsertWithoutSessionsInput({
    required this.update,
    required this.create,
  });

  factory TaskUpsertWithoutSessionsInput.fromJson(Map<String, dynamic> json) =>
      _$TaskUpsertWithoutSessionsInputFromJson(json);

  final TaskUpdateWithoutSessionsInput update;

  final TaskCreateWithoutSessionsInput create;

  @override
  Map<String, dynamic> toJson() => _$TaskUpsertWithoutSessionsInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpdateWithoutSessionsInput implements _i1.JsonSerializable {
  const TaskUpdateWithoutSessionsInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.owner,
    this.parent,
    this.children,
    this.channel,
    this.assets,
    this.assignments,
    this.records,
  });

  factory TaskUpdateWithoutSessionsInput.fromJson(Map<String, dynamic> json) =>
      _$TaskUpdateWithoutSessionsInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? title;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? content;

  final NullableStringFieldUpdateOperationsInput? location;

  final BoolFieldUpdateOperationsInput? requireLocation;

  final BoolFieldUpdateOperationsInput? requireTime;

  final BoolFieldUpdateOperationsInput? requireAttachment;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ProfileUpdateOneRequiredWithoutTasksNestedInput? owner;

  final TaskUpdateOneWithoutChildrenNestedInput? parent;

  final TaskUpdateManyWithoutParentNestedInput? children;

  final ChannelUpdateOneWithoutTasksNestedInput? channel;

  final TaskAssetUpdateManyWithoutTaskNestedInput? assets;

  final TaskAssignmentUpdateManyWithoutTaskNestedInput? assignments;

  final RecordUpdateManyWithoutTaskNestedInput? records;

  @override
  Map<String, dynamic> toJson() => _$TaskUpdateWithoutSessionsInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedUpdateWithoutSessionsInput implements _i1.JsonSerializable {
  const TaskUncheckedUpdateWithoutSessionsInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.userId,
    this.profile,
    this.parentUuid,
    this.channelUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.children,
    this.assets,
    this.assignments,
    this.records,
  });

  factory TaskUncheckedUpdateWithoutSessionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUncheckedUpdateWithoutSessionsInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? title;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? content;

  final NullableStringFieldUpdateOperationsInput? location;

  final BoolFieldUpdateOperationsInput? requireLocation;

  final BoolFieldUpdateOperationsInput? requireTime;

  final BoolFieldUpdateOperationsInput? requireAttachment;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profile;

  final NullableStringFieldUpdateOperationsInput? parentUuid;

  final NullableStringFieldUpdateOperationsInput? channelUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskUncheckedUpdateManyWithoutParentNestedInput? children;

  final TaskAssetUncheckedUpdateManyWithoutTaskNestedInput? assets;

  final TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput? assignments;

  final RecordUncheckedUpdateManyWithoutTaskNestedInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUncheckedUpdateWithoutSessionsInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleUpsertWithWhereUniqueWithoutSessionInput
    implements _i1.JsonSerializable {
  const ScheduleUpsertWithWhereUniqueWithoutSessionInput({
    required this.where,
    required this.update,
    required this.create,
  });

  factory ScheduleUpsertWithWhereUniqueWithoutSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleUpsertWithWhereUniqueWithoutSessionInputFromJson(json);

  final ScheduleWhereUniqueInput where;

  final ScheduleUpdateWithoutSessionInput update;

  final ScheduleCreateWithoutSessionInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleUpsertWithWhereUniqueWithoutSessionInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleUpdateWithWhereUniqueWithoutSessionInput
    implements _i1.JsonSerializable {
  const ScheduleUpdateWithWhereUniqueWithoutSessionInput({
    required this.where,
    required this.data,
  });

  factory ScheduleUpdateWithWhereUniqueWithoutSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleUpdateWithWhereUniqueWithoutSessionInputFromJson(json);

  final ScheduleWhereUniqueInput where;

  final ScheduleUpdateWithoutSessionInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleUpdateWithWhereUniqueWithoutSessionInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleUpdateManyWithWhereWithoutSessionInput
    implements _i1.JsonSerializable {
  const ScheduleUpdateManyWithWhereWithoutSessionInput({
    required this.where,
    required this.data,
  });

  factory ScheduleUpdateManyWithWhereWithoutSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleUpdateManyWithWhereWithoutSessionInputFromJson(json);

  final ScheduleScalarWhereInput where;

  final ScheduleUpdateManyMutationInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleUpdateManyWithWhereWithoutSessionInputToJson(this);
}

@_i1.jsonSerializable
class RecordUpsertWithWhereUniqueWithoutSessionInput
    implements _i1.JsonSerializable {
  const RecordUpsertWithWhereUniqueWithoutSessionInput({
    required this.where,
    required this.update,
    required this.create,
  });

  factory RecordUpsertWithWhereUniqueWithoutSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUpsertWithWhereUniqueWithoutSessionInputFromJson(json);

  final RecordWhereUniqueInput where;

  final RecordUpdateWithoutSessionInput update;

  final RecordCreateWithoutSessionInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUpsertWithWhereUniqueWithoutSessionInputToJson(this);
}

@_i1.jsonSerializable
class RecordUpdateWithWhereUniqueWithoutSessionInput
    implements _i1.JsonSerializable {
  const RecordUpdateWithWhereUniqueWithoutSessionInput({
    required this.where,
    required this.data,
  });

  factory RecordUpdateWithWhereUniqueWithoutSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUpdateWithWhereUniqueWithoutSessionInputFromJson(json);

  final RecordWhereUniqueInput where;

  final RecordUpdateWithoutSessionInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUpdateWithWhereUniqueWithoutSessionInputToJson(this);
}

@_i1.jsonSerializable
class RecordUpdateManyWithWhereWithoutSessionInput
    implements _i1.JsonSerializable {
  const RecordUpdateManyWithWhereWithoutSessionInput({
    required this.where,
    required this.data,
  });

  factory RecordUpdateManyWithWhereWithoutSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUpdateManyWithWhereWithoutSessionInputFromJson(json);

  final RecordScalarWhereInput where;

  final RecordUpdateManyMutationInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUpdateManyWithWhereWithoutSessionInputToJson(this);
}

@_i1.jsonSerializable
class SessionCreateWithoutRecordsInput implements _i1.JsonSerializable {
  const SessionCreateWithoutRecordsInput({
    required this.uuid,
    required this.start,
    required this.end,
    required this.cycle,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    required this.task,
    this.schedules,
  });

  factory SessionCreateWithoutRecordsInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionCreateWithoutRecordsInputFromJson(json);

  final String uuid;

  final BigInt start;

  final BigInt end;

  final BigInt cycle;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final TaskCreateNestedOneWithoutSessionsInput task;

  final ScheduleCreateNestedManyWithoutSessionInput? schedules;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionCreateWithoutRecordsInputToJson(this);
}

@_i1.jsonSerializable
class SessionUncheckedCreateWithoutRecordsInput
    implements _i1.JsonSerializable {
  const SessionUncheckedCreateWithoutRecordsInput({
    required this.uuid,
    required this.start,
    required this.end,
    required this.cycle,
    required this.taskUuid,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    this.schedules,
  });

  factory SessionUncheckedCreateWithoutRecordsInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionUncheckedCreateWithoutRecordsInputFromJson(json);

  final String uuid;

  final BigInt start;

  final BigInt end;

  final BigInt cycle;

  final String taskUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final ScheduleUncheckedCreateNestedManyWithoutSessionInput? schedules;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionUncheckedCreateWithoutRecordsInputToJson(this);
}

@_i1.jsonSerializable
class SessionCreateOrConnectWithoutRecordsInput
    implements _i1.JsonSerializable {
  const SessionCreateOrConnectWithoutRecordsInput({
    required this.where,
    required this.create,
  });

  factory SessionCreateOrConnectWithoutRecordsInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionCreateOrConnectWithoutRecordsInputFromJson(json);

  final SessionWhereUniqueInput where;

  final SessionCreateWithoutRecordsInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionCreateOrConnectWithoutRecordsInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateWithoutRecordsInput implements _i1.JsonSerializable {
  const TaskCreateWithoutRecordsInput({
    required this.uuid,
    required this.title,
    required this.desc,
    required this.content,
    this.location,
    required this.requireLocation,
    required this.requireTime,
    required this.requireAttachment,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    required this.owner,
    this.parent,
    this.children,
    this.channel,
    this.assets,
    this.assignments,
    this.sessions,
  });

  factory TaskCreateWithoutRecordsInput.fromJson(Map<String, dynamic> json) =>
      _$TaskCreateWithoutRecordsInputFromJson(json);

  final String uuid;

  final String title;

  final String desc;

  final String content;

  final String? location;

  final bool requireLocation;

  final bool requireTime;

  final bool requireAttachment;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final ProfileCreateNestedOneWithoutTasksInput owner;

  final TaskCreateNestedOneWithoutChildrenInput? parent;

  final TaskCreateNestedManyWithoutParentInput? children;

  final ChannelCreateNestedOneWithoutTasksInput? channel;

  final TaskAssetCreateNestedManyWithoutTaskInput? assets;

  final TaskAssignmentCreateNestedManyWithoutTaskInput? assignments;

  final SessionCreateNestedManyWithoutTaskInput? sessions;

  @override
  Map<String, dynamic> toJson() => _$TaskCreateWithoutRecordsInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedCreateWithoutRecordsInput implements _i1.JsonSerializable {
  const TaskUncheckedCreateWithoutRecordsInput({
    required this.uuid,
    required this.title,
    required this.desc,
    required this.content,
    this.location,
    required this.requireLocation,
    required this.requireTime,
    required this.requireAttachment,
    required this.userId,
    required this.profile,
    this.parentUuid,
    this.channelUuid,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.children,
    this.assets,
    this.assignments,
    this.sessions,
  });

  factory TaskUncheckedCreateWithoutRecordsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUncheckedCreateWithoutRecordsInputFromJson(json);

  final String uuid;

  final String title;

  final String desc;

  final String content;

  final String? location;

  final bool requireLocation;

  final bool requireTime;

  final bool requireAttachment;

  final int userId;

  final String profile;

  final String? parentUuid;

  final String? channelUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final TaskUncheckedCreateNestedManyWithoutParentInput? children;

  final TaskAssetUncheckedCreateNestedManyWithoutTaskInput? assets;

  final TaskAssignmentUncheckedCreateNestedManyWithoutTaskInput? assignments;

  final SessionUncheckedCreateNestedManyWithoutTaskInput? sessions;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUncheckedCreateWithoutRecordsInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateOrConnectWithoutRecordsInput implements _i1.JsonSerializable {
  const TaskCreateOrConnectWithoutRecordsInput({
    required this.where,
    required this.create,
  });

  factory TaskCreateOrConnectWithoutRecordsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskCreateOrConnectWithoutRecordsInputFromJson(json);

  final TaskWhereUniqueInput where;

  final TaskCreateWithoutRecordsInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskCreateOrConnectWithoutRecordsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateWithoutRecordsInput implements _i1.JsonSerializable {
  const ProfileCreateWithoutRecordsInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    required this.user,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
  });

  factory ProfileCreateWithoutRecordsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateWithoutRecordsInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final UserCreateNestedOneWithoutProfilesInput user;

  final CategoryCreateNestedManyWithoutProfileInput? categories;

  final TagCreateNestedManyWithoutProfileInput? tags;

  final TaskCreateNestedManyWithoutOwnerInput? tasks;

  final ChannelCreateNestedManyWithoutOwnerInput? channels;

  final TaskAssignmentCreateNestedManyWithoutProfileInput? taskAssignments;

  final ChannelSubscriptionCreateNestedManyWithoutProfileInput?
      channelSubscriptions;

  final ScheduleCreateNestedManyWithoutProfileInput? schedules;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateWithoutRecordsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUncheckedCreateWithoutRecordsInput
    implements _i1.JsonSerializable {
  const ProfileUncheckedCreateWithoutRecordsInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.userId,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
  });

  factory ProfileUncheckedCreateWithoutRecordsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUncheckedCreateWithoutRecordsInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final int userId;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final CategoryUncheckedCreateNestedManyWithoutProfileInput? categories;

  final TagUncheckedCreateNestedManyWithoutProfileInput? tags;

  final TaskUncheckedCreateNestedManyWithoutOwnerInput? tasks;

  final ChannelUncheckedCreateNestedManyWithoutOwnerInput? channels;

  final TaskAssignmentUncheckedCreateNestedManyWithoutProfileInput?
      taskAssignments;

  final ChannelSubscriptionUncheckedCreateNestedManyWithoutProfileInput?
      channelSubscriptions;

  final ScheduleUncheckedCreateNestedManyWithoutProfileInput? schedules;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUncheckedCreateWithoutRecordsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateOrConnectWithoutRecordsInput
    implements _i1.JsonSerializable {
  const ProfileCreateOrConnectWithoutRecordsInput({
    required this.where,
    required this.create,
  });

  factory ProfileCreateOrConnectWithoutRecordsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateOrConnectWithoutRecordsInputFromJson(json);

  final ProfileWhereUniqueInput where;

  final ProfileCreateWithoutRecordsInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateOrConnectWithoutRecordsInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentCreateWithoutRecordInput implements _i1.JsonSerializable {
  const RecordAttachmentCreateWithoutRecordInput({
    required this.hash,
    required this.name,
    required this.assetRef,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory RecordAttachmentCreateWithoutRecordInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentCreateWithoutRecordInputFromJson(json);

  final String hash;

  final String name;

  final String assetRef;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentCreateWithoutRecordInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentUncheckedCreateWithoutRecordInput
    implements _i1.JsonSerializable {
  const RecordAttachmentUncheckedCreateWithoutRecordInput({
    required this.hash,
    required this.name,
    required this.assetRef,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory RecordAttachmentUncheckedCreateWithoutRecordInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentUncheckedCreateWithoutRecordInputFromJson(json);

  final String hash;

  final String name;

  final String assetRef;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentUncheckedCreateWithoutRecordInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentCreateOrConnectWithoutRecordInput
    implements _i1.JsonSerializable {
  const RecordAttachmentCreateOrConnectWithoutRecordInput({
    required this.where,
    required this.create,
  });

  factory RecordAttachmentCreateOrConnectWithoutRecordInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentCreateOrConnectWithoutRecordInputFromJson(json);

  final RecordAttachmentWhereUniqueInput where;

  final RecordAttachmentCreateWithoutRecordInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentCreateOrConnectWithoutRecordInputToJson(this);
}

@_i1.jsonSerializable
class SessionUpsertWithoutRecordsInput implements _i1.JsonSerializable {
  const SessionUpsertWithoutRecordsInput({
    required this.update,
    required this.create,
  });

  factory SessionUpsertWithoutRecordsInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionUpsertWithoutRecordsInputFromJson(json);

  final SessionUpdateWithoutRecordsInput update;

  final SessionCreateWithoutRecordsInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionUpsertWithoutRecordsInputToJson(this);
}

@_i1.jsonSerializable
class SessionUpdateWithoutRecordsInput implements _i1.JsonSerializable {
  const SessionUpdateWithoutRecordsInput({
    this.uuid,
    this.start,
    this.end,
    this.cycle,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.task,
    this.schedules,
  });

  factory SessionUpdateWithoutRecordsInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionUpdateWithoutRecordsInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final BigIntFieldUpdateOperationsInput? start;

  final BigIntFieldUpdateOperationsInput? end;

  final BigIntFieldUpdateOperationsInput? cycle;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskUpdateOneRequiredWithoutSessionsNestedInput? task;

  final ScheduleUpdateManyWithoutSessionNestedInput? schedules;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionUpdateWithoutRecordsInputToJson(this);
}

@_i1.jsonSerializable
class SessionUncheckedUpdateWithoutRecordsInput
    implements _i1.JsonSerializable {
  const SessionUncheckedUpdateWithoutRecordsInput({
    this.uuid,
    this.start,
    this.end,
    this.cycle,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.schedules,
  });

  factory SessionUncheckedUpdateWithoutRecordsInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionUncheckedUpdateWithoutRecordsInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final BigIntFieldUpdateOperationsInput? start;

  final BigIntFieldUpdateOperationsInput? end;

  final BigIntFieldUpdateOperationsInput? cycle;

  final StringFieldUpdateOperationsInput? taskUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ScheduleUncheckedUpdateManyWithoutSessionNestedInput? schedules;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionUncheckedUpdateWithoutRecordsInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpsertWithoutRecordsInput implements _i1.JsonSerializable {
  const TaskUpsertWithoutRecordsInput({
    required this.update,
    required this.create,
  });

  factory TaskUpsertWithoutRecordsInput.fromJson(Map<String, dynamic> json) =>
      _$TaskUpsertWithoutRecordsInputFromJson(json);

  final TaskUpdateWithoutRecordsInput update;

  final TaskCreateWithoutRecordsInput create;

  @override
  Map<String, dynamic> toJson() => _$TaskUpsertWithoutRecordsInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpdateWithoutRecordsInput implements _i1.JsonSerializable {
  const TaskUpdateWithoutRecordsInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.owner,
    this.parent,
    this.children,
    this.channel,
    this.assets,
    this.assignments,
    this.sessions,
  });

  factory TaskUpdateWithoutRecordsInput.fromJson(Map<String, dynamic> json) =>
      _$TaskUpdateWithoutRecordsInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? title;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? content;

  final NullableStringFieldUpdateOperationsInput? location;

  final BoolFieldUpdateOperationsInput? requireLocation;

  final BoolFieldUpdateOperationsInput? requireTime;

  final BoolFieldUpdateOperationsInput? requireAttachment;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ProfileUpdateOneRequiredWithoutTasksNestedInput? owner;

  final TaskUpdateOneWithoutChildrenNestedInput? parent;

  final TaskUpdateManyWithoutParentNestedInput? children;

  final ChannelUpdateOneWithoutTasksNestedInput? channel;

  final TaskAssetUpdateManyWithoutTaskNestedInput? assets;

  final TaskAssignmentUpdateManyWithoutTaskNestedInput? assignments;

  final SessionUpdateManyWithoutTaskNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() => _$TaskUpdateWithoutRecordsInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedUpdateWithoutRecordsInput implements _i1.JsonSerializable {
  const TaskUncheckedUpdateWithoutRecordsInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.userId,
    this.profile,
    this.parentUuid,
    this.channelUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.children,
    this.assets,
    this.assignments,
    this.sessions,
  });

  factory TaskUncheckedUpdateWithoutRecordsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUncheckedUpdateWithoutRecordsInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? title;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? content;

  final NullableStringFieldUpdateOperationsInput? location;

  final BoolFieldUpdateOperationsInput? requireLocation;

  final BoolFieldUpdateOperationsInput? requireTime;

  final BoolFieldUpdateOperationsInput? requireAttachment;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profile;

  final NullableStringFieldUpdateOperationsInput? parentUuid;

  final NullableStringFieldUpdateOperationsInput? channelUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskUncheckedUpdateManyWithoutParentNestedInput? children;

  final TaskAssetUncheckedUpdateManyWithoutTaskNestedInput? assets;

  final TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput? assignments;

  final SessionUncheckedUpdateManyWithoutTaskNestedInput? sessions;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUncheckedUpdateWithoutRecordsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpsertWithoutRecordsInput implements _i1.JsonSerializable {
  const ProfileUpsertWithoutRecordsInput({
    required this.update,
    required this.create,
  });

  factory ProfileUpsertWithoutRecordsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUpsertWithoutRecordsInputFromJson(json);

  final ProfileUpdateWithoutRecordsInput update;

  final ProfileCreateWithoutRecordsInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUpsertWithoutRecordsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpdateWithoutRecordsInput implements _i1.JsonSerializable {
  const ProfileUpdateWithoutRecordsInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.user,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
  });

  factory ProfileUpdateWithoutRecordsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUpdateWithoutRecordsInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final UserUpdateOneRequiredWithoutProfilesNestedInput? user;

  final CategoryUpdateManyWithoutProfileNestedInput? categories;

  final TagUpdateManyWithoutProfileNestedInput? tags;

  final TaskUpdateManyWithoutOwnerNestedInput? tasks;

  final ChannelUpdateManyWithoutOwnerNestedInput? channels;

  final TaskAssignmentUpdateManyWithoutProfileNestedInput? taskAssignments;

  final ChannelSubscriptionUpdateManyWithoutProfileNestedInput?
      channelSubscriptions;

  final ScheduleUpdateManyWithoutProfileNestedInput? schedules;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUpdateWithoutRecordsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUncheckedUpdateWithoutRecordsInput
    implements _i1.JsonSerializable {
  const ProfileUncheckedUpdateWithoutRecordsInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
  });

  factory ProfileUncheckedUpdateWithoutRecordsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUncheckedUpdateWithoutRecordsInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final IntFieldUpdateOperationsInput? userId;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final CategoryUncheckedUpdateManyWithoutProfileNestedInput? categories;

  final TagUncheckedUpdateManyWithoutProfileNestedInput? tags;

  final TaskUncheckedUpdateManyWithoutOwnerNestedInput? tasks;

  final ChannelUncheckedUpdateManyWithoutOwnerNestedInput? channels;

  final TaskAssignmentUncheckedUpdateManyWithoutProfileNestedInput?
      taskAssignments;

  final ChannelSubscriptionUncheckedUpdateManyWithoutProfileNestedInput?
      channelSubscriptions;

  final ScheduleUncheckedUpdateManyWithoutProfileNestedInput? schedules;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUncheckedUpdateWithoutRecordsInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentUpsertWithoutRecordInput implements _i1.JsonSerializable {
  const RecordAttachmentUpsertWithoutRecordInput({
    required this.update,
    required this.create,
  });

  factory RecordAttachmentUpsertWithoutRecordInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentUpsertWithoutRecordInputFromJson(json);

  final RecordAttachmentUpdateWithoutRecordInput update;

  final RecordAttachmentCreateWithoutRecordInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentUpsertWithoutRecordInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentUpdateWithoutRecordInput implements _i1.JsonSerializable {
  const RecordAttachmentUpdateWithoutRecordInput({
    this.hash,
    this.name,
    this.assetRef,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory RecordAttachmentUpdateWithoutRecordInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentUpdateWithoutRecordInputFromJson(json);

  final StringFieldUpdateOperationsInput? hash;

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? assetRef;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentUpdateWithoutRecordInputToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentUncheckedUpdateWithoutRecordInput
    implements _i1.JsonSerializable {
  const RecordAttachmentUncheckedUpdateWithoutRecordInput({
    this.hash,
    this.name,
    this.assetRef,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory RecordAttachmentUncheckedUpdateWithoutRecordInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentUncheckedUpdateWithoutRecordInputFromJson(json);

  final StringFieldUpdateOperationsInput? hash;

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? assetRef;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentUncheckedUpdateWithoutRecordInputToJson(this);
}

@_i1.jsonSerializable
class RecordCreateWithoutAttachmentInput implements _i1.JsonSerializable {
  const RecordCreateWithoutAttachmentInput({
    required this.time,
    required this.recordIndex,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    required this.session,
    required this.task,
    required this.profile,
  });

  factory RecordCreateWithoutAttachmentInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordCreateWithoutAttachmentInputFromJson(json);

  final BigInt time;

  final int recordIndex;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final SessionCreateNestedOneWithoutRecordsInput session;

  final TaskCreateNestedOneWithoutRecordsInput task;

  final ProfileCreateNestedOneWithoutRecordsInput profile;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordCreateWithoutAttachmentInputToJson(this);
}

@_i1.jsonSerializable
class RecordUncheckedCreateWithoutAttachmentInput
    implements _i1.JsonSerializable {
  const RecordUncheckedCreateWithoutAttachmentInput({
    required this.time,
    required this.recordIndex,
    required this.sessionUuid,
    required this.taskUuid,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory RecordUncheckedCreateWithoutAttachmentInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUncheckedCreateWithoutAttachmentInputFromJson(json);

  final BigInt time;

  final int recordIndex;

  final String sessionUuid;

  final String taskUuid;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUncheckedCreateWithoutAttachmentInputToJson(this);
}

@_i1.jsonSerializable
class RecordCreateOrConnectWithoutAttachmentInput
    implements _i1.JsonSerializable {
  const RecordCreateOrConnectWithoutAttachmentInput({
    required this.where,
    required this.create,
  });

  factory RecordCreateOrConnectWithoutAttachmentInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordCreateOrConnectWithoutAttachmentInputFromJson(json);

  final RecordWhereUniqueInput where;

  final RecordCreateWithoutAttachmentInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordCreateOrConnectWithoutAttachmentInputToJson(this);
}

@_i1.jsonSerializable
class RecordUpsertWithoutAttachmentInput implements _i1.JsonSerializable {
  const RecordUpsertWithoutAttachmentInput({
    required this.update,
    required this.create,
  });

  factory RecordUpsertWithoutAttachmentInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUpsertWithoutAttachmentInputFromJson(json);

  final RecordUpdateWithoutAttachmentInput update;

  final RecordCreateWithoutAttachmentInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUpsertWithoutAttachmentInputToJson(this);
}

@_i1.jsonSerializable
class RecordUpdateWithoutAttachmentInput implements _i1.JsonSerializable {
  const RecordUpdateWithoutAttachmentInput({
    this.time,
    this.recordIndex,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.session,
    this.task,
    this.profile,
  });

  factory RecordUpdateWithoutAttachmentInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUpdateWithoutAttachmentInputFromJson(json);

  final BigIntFieldUpdateOperationsInput? time;

  final IntFieldUpdateOperationsInput? recordIndex;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final SessionUpdateOneRequiredWithoutRecordsNestedInput? session;

  final TaskUpdateOneRequiredWithoutRecordsNestedInput? task;

  final ProfileUpdateOneRequiredWithoutRecordsNestedInput? profile;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUpdateWithoutAttachmentInputToJson(this);
}

@_i1.jsonSerializable
class RecordUncheckedUpdateWithoutAttachmentInput
    implements _i1.JsonSerializable {
  const RecordUncheckedUpdateWithoutAttachmentInput({
    this.time,
    this.recordIndex,
    this.sessionUuid,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory RecordUncheckedUpdateWithoutAttachmentInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUncheckedUpdateWithoutAttachmentInputFromJson(json);

  final BigIntFieldUpdateOperationsInput? time;

  final IntFieldUpdateOperationsInput? recordIndex;

  final StringFieldUpdateOperationsInput? sessionUuid;

  final StringFieldUpdateOperationsInput? taskUuid;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUncheckedUpdateWithoutAttachmentInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateWithoutCategoriesInput implements _i1.JsonSerializable {
  const ProfileCreateWithoutCategoriesInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    required this.user,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileCreateWithoutCategoriesInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateWithoutCategoriesInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final UserCreateNestedOneWithoutProfilesInput user;

  final TagCreateNestedManyWithoutProfileInput? tags;

  final TaskCreateNestedManyWithoutOwnerInput? tasks;

  final ChannelCreateNestedManyWithoutOwnerInput? channels;

  final TaskAssignmentCreateNestedManyWithoutProfileInput? taskAssignments;

  final ChannelSubscriptionCreateNestedManyWithoutProfileInput?
      channelSubscriptions;

  final ScheduleCreateNestedManyWithoutProfileInput? schedules;

  final RecordCreateNestedManyWithoutProfileInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateWithoutCategoriesInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUncheckedCreateWithoutCategoriesInput
    implements _i1.JsonSerializable {
  const ProfileUncheckedCreateWithoutCategoriesInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.userId,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileUncheckedCreateWithoutCategoriesInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUncheckedCreateWithoutCategoriesInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final int userId;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final TagUncheckedCreateNestedManyWithoutProfileInput? tags;

  final TaskUncheckedCreateNestedManyWithoutOwnerInput? tasks;

  final ChannelUncheckedCreateNestedManyWithoutOwnerInput? channels;

  final TaskAssignmentUncheckedCreateNestedManyWithoutProfileInput?
      taskAssignments;

  final ChannelSubscriptionUncheckedCreateNestedManyWithoutProfileInput?
      channelSubscriptions;

  final ScheduleUncheckedCreateNestedManyWithoutProfileInput? schedules;

  final RecordUncheckedCreateNestedManyWithoutProfileInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUncheckedCreateWithoutCategoriesInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateOrConnectWithoutCategoriesInput
    implements _i1.JsonSerializable {
  const ProfileCreateOrConnectWithoutCategoriesInput({
    required this.where,
    required this.create,
  });

  factory ProfileCreateOrConnectWithoutCategoriesInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateOrConnectWithoutCategoriesInputFromJson(json);

  final ProfileWhereUniqueInput where;

  final ProfileCreateWithoutCategoriesInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateOrConnectWithoutCategoriesInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentCreateWithoutCategoryInput implements _i1.JsonSerializable {
  const TaskAssignmentCreateWithoutCategoryInput({
    required this.status,
    required this.priority,
    required this.starred,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    required this.task,
    required this.profile,
    this.tags,
  });

  factory TaskAssignmentCreateWithoutCategoryInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentCreateWithoutCategoryInputFromJson(json);

  final TaskAssignmentStatus status;

  final TaskPriority priority;

  final bool starred;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final TaskCreateNestedOneWithoutAssignmentsInput task;

  final ProfileCreateNestedOneWithoutTaskAssignmentsInput profile;

  final TaskAssignmentTagsCreateNestedManyWithoutAssignmentInput? tags;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentCreateWithoutCategoryInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUncheckedCreateWithoutCategoryInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUncheckedCreateWithoutCategoryInput({
    required this.status,
    required this.priority,
    required this.starred,
    required this.taskUuid,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    this.tags,
  });

  factory TaskAssignmentUncheckedCreateWithoutCategoryInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUncheckedCreateWithoutCategoryInputFromJson(json);

  final TaskAssignmentStatus status;

  final TaskPriority priority;

  final bool starred;

  final String taskUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final TaskAssignmentTagsUncheckedCreateNestedManyWithoutAssignmentInput? tags;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUncheckedCreateWithoutCategoryInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentCreateOrConnectWithoutCategoryInput
    implements _i1.JsonSerializable {
  const TaskAssignmentCreateOrConnectWithoutCategoryInput({
    required this.where,
    required this.create,
  });

  factory TaskAssignmentCreateOrConnectWithoutCategoryInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentCreateOrConnectWithoutCategoryInputFromJson(json);

  final TaskAssignmentWhereUniqueInput where;

  final TaskAssignmentCreateWithoutCategoryInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentCreateOrConnectWithoutCategoryInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentCreateManyCategoryInputEnvelope
    implements _i1.JsonSerializable {
  const TaskAssignmentCreateManyCategoryInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  factory TaskAssignmentCreateManyCategoryInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentCreateManyCategoryInputEnvelopeFromJson(json);

  final Iterable<TaskAssignmentCreateManyCategoryInput> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentCreateManyCategoryInputEnvelopeToJson(this);
}

@_i1.jsonSerializable
class ProfileUpsertWithoutCategoriesInput implements _i1.JsonSerializable {
  const ProfileUpsertWithoutCategoriesInput({
    required this.update,
    required this.create,
  });

  factory ProfileUpsertWithoutCategoriesInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUpsertWithoutCategoriesInputFromJson(json);

  final ProfileUpdateWithoutCategoriesInput update;

  final ProfileCreateWithoutCategoriesInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUpsertWithoutCategoriesInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpdateWithoutCategoriesInput implements _i1.JsonSerializable {
  const ProfileUpdateWithoutCategoriesInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.user,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileUpdateWithoutCategoriesInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUpdateWithoutCategoriesInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final UserUpdateOneRequiredWithoutProfilesNestedInput? user;

  final TagUpdateManyWithoutProfileNestedInput? tags;

  final TaskUpdateManyWithoutOwnerNestedInput? tasks;

  final ChannelUpdateManyWithoutOwnerNestedInput? channels;

  final TaskAssignmentUpdateManyWithoutProfileNestedInput? taskAssignments;

  final ChannelSubscriptionUpdateManyWithoutProfileNestedInput?
      channelSubscriptions;

  final ScheduleUpdateManyWithoutProfileNestedInput? schedules;

  final RecordUpdateManyWithoutProfileNestedInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUpdateWithoutCategoriesInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUncheckedUpdateWithoutCategoriesInput
    implements _i1.JsonSerializable {
  const ProfileUncheckedUpdateWithoutCategoriesInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileUncheckedUpdateWithoutCategoriesInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUncheckedUpdateWithoutCategoriesInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final IntFieldUpdateOperationsInput? userId;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TagUncheckedUpdateManyWithoutProfileNestedInput? tags;

  final TaskUncheckedUpdateManyWithoutOwnerNestedInput? tasks;

  final ChannelUncheckedUpdateManyWithoutOwnerNestedInput? channels;

  final TaskAssignmentUncheckedUpdateManyWithoutProfileNestedInput?
      taskAssignments;

  final ChannelSubscriptionUncheckedUpdateManyWithoutProfileNestedInput?
      channelSubscriptions;

  final ScheduleUncheckedUpdateManyWithoutProfileNestedInput? schedules;

  final RecordUncheckedUpdateManyWithoutProfileNestedInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUncheckedUpdateWithoutCategoriesInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUpsertWithWhereUniqueWithoutCategoryInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUpsertWithWhereUniqueWithoutCategoryInput({
    required this.where,
    required this.update,
    required this.create,
  });

  factory TaskAssignmentUpsertWithWhereUniqueWithoutCategoryInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUpsertWithWhereUniqueWithoutCategoryInputFromJson(json);

  final TaskAssignmentWhereUniqueInput where;

  final TaskAssignmentUpdateWithoutCategoryInput update;

  final TaskAssignmentCreateWithoutCategoryInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUpsertWithWhereUniqueWithoutCategoryInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUpdateWithWhereUniqueWithoutCategoryInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUpdateWithWhereUniqueWithoutCategoryInput({
    required this.where,
    required this.data,
  });

  factory TaskAssignmentUpdateWithWhereUniqueWithoutCategoryInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUpdateWithWhereUniqueWithoutCategoryInputFromJson(json);

  final TaskAssignmentWhereUniqueInput where;

  final TaskAssignmentUpdateWithoutCategoryInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUpdateWithWhereUniqueWithoutCategoryInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUpdateManyWithWhereWithoutCategoryInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUpdateManyWithWhereWithoutCategoryInput({
    required this.where,
    required this.data,
  });

  factory TaskAssignmentUpdateManyWithWhereWithoutCategoryInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUpdateManyWithWhereWithoutCategoryInputFromJson(json);

  final TaskAssignmentScalarWhereInput where;

  final TaskAssignmentUpdateManyMutationInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUpdateManyWithWhereWithoutCategoryInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateWithoutTagsInput implements _i1.JsonSerializable {
  const ProfileCreateWithoutTagsInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    required this.user,
    this.categories,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileCreateWithoutTagsInput.fromJson(Map<String, dynamic> json) =>
      _$ProfileCreateWithoutTagsInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final UserCreateNestedOneWithoutProfilesInput user;

  final CategoryCreateNestedManyWithoutProfileInput? categories;

  final TaskCreateNestedManyWithoutOwnerInput? tasks;

  final ChannelCreateNestedManyWithoutOwnerInput? channels;

  final TaskAssignmentCreateNestedManyWithoutProfileInput? taskAssignments;

  final ChannelSubscriptionCreateNestedManyWithoutProfileInput?
      channelSubscriptions;

  final ScheduleCreateNestedManyWithoutProfileInput? schedules;

  final RecordCreateNestedManyWithoutProfileInput? records;

  @override
  Map<String, dynamic> toJson() => _$ProfileCreateWithoutTagsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUncheckedCreateWithoutTagsInput implements _i1.JsonSerializable {
  const ProfileUncheckedCreateWithoutTagsInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.userId,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.categories,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileUncheckedCreateWithoutTagsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUncheckedCreateWithoutTagsInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final int userId;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final CategoryUncheckedCreateNestedManyWithoutProfileInput? categories;

  final TaskUncheckedCreateNestedManyWithoutOwnerInput? tasks;

  final ChannelUncheckedCreateNestedManyWithoutOwnerInput? channels;

  final TaskAssignmentUncheckedCreateNestedManyWithoutProfileInput?
      taskAssignments;

  final ChannelSubscriptionUncheckedCreateNestedManyWithoutProfileInput?
      channelSubscriptions;

  final ScheduleUncheckedCreateNestedManyWithoutProfileInput? schedules;

  final RecordUncheckedCreateNestedManyWithoutProfileInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUncheckedCreateWithoutTagsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateOrConnectWithoutTagsInput implements _i1.JsonSerializable {
  const ProfileCreateOrConnectWithoutTagsInput({
    required this.where,
    required this.create,
  });

  factory ProfileCreateOrConnectWithoutTagsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateOrConnectWithoutTagsInputFromJson(json);

  final ProfileWhereUniqueInput where;

  final ProfileCreateWithoutTagsInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateOrConnectWithoutTagsInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsCreateWithoutTagInput implements _i1.JsonSerializable {
  const TaskAssignmentTagsCreateWithoutTagInput({required this.assignment});

  factory TaskAssignmentTagsCreateWithoutTagInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsCreateWithoutTagInputFromJson(json);

  final TaskAssignmentCreateNestedOneWithoutTagsInput assignment;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsCreateWithoutTagInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUncheckedCreateWithoutTagInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsUncheckedCreateWithoutTagInput(
      {required this.taskUuid});

  factory TaskAssignmentTagsUncheckedCreateWithoutTagInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUncheckedCreateWithoutTagInputFromJson(json);

  final String taskUuid;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsUncheckedCreateWithoutTagInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsCreateOrConnectWithoutTagInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsCreateOrConnectWithoutTagInput({
    required this.where,
    required this.create,
  });

  factory TaskAssignmentTagsCreateOrConnectWithoutTagInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsCreateOrConnectWithoutTagInputFromJson(json);

  final TaskAssignmentTagsWhereUniqueInput where;

  final TaskAssignmentTagsCreateWithoutTagInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsCreateOrConnectWithoutTagInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsCreateManyTagInputEnvelope
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsCreateManyTagInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  factory TaskAssignmentTagsCreateManyTagInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsCreateManyTagInputEnvelopeFromJson(json);

  final Iterable<TaskAssignmentTagsCreateManyTagInput> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsCreateManyTagInputEnvelopeToJson(this);
}

@_i1.jsonSerializable
class ProfileUpsertWithoutTagsInput implements _i1.JsonSerializable {
  const ProfileUpsertWithoutTagsInput({
    required this.update,
    required this.create,
  });

  factory ProfileUpsertWithoutTagsInput.fromJson(Map<String, dynamic> json) =>
      _$ProfileUpsertWithoutTagsInputFromJson(json);

  final ProfileUpdateWithoutTagsInput update;

  final ProfileCreateWithoutTagsInput create;

  @override
  Map<String, dynamic> toJson() => _$ProfileUpsertWithoutTagsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpdateWithoutTagsInput implements _i1.JsonSerializable {
  const ProfileUpdateWithoutTagsInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.user,
    this.categories,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileUpdateWithoutTagsInput.fromJson(Map<String, dynamic> json) =>
      _$ProfileUpdateWithoutTagsInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final UserUpdateOneRequiredWithoutProfilesNestedInput? user;

  final CategoryUpdateManyWithoutProfileNestedInput? categories;

  final TaskUpdateManyWithoutOwnerNestedInput? tasks;

  final ChannelUpdateManyWithoutOwnerNestedInput? channels;

  final TaskAssignmentUpdateManyWithoutProfileNestedInput? taskAssignments;

  final ChannelSubscriptionUpdateManyWithoutProfileNestedInput?
      channelSubscriptions;

  final ScheduleUpdateManyWithoutProfileNestedInput? schedules;

  final RecordUpdateManyWithoutProfileNestedInput? records;

  @override
  Map<String, dynamic> toJson() => _$ProfileUpdateWithoutTagsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUncheckedUpdateWithoutTagsInput implements _i1.JsonSerializable {
  const ProfileUncheckedUpdateWithoutTagsInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.categories,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileUncheckedUpdateWithoutTagsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUncheckedUpdateWithoutTagsInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final IntFieldUpdateOperationsInput? userId;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final CategoryUncheckedUpdateManyWithoutProfileNestedInput? categories;

  final TaskUncheckedUpdateManyWithoutOwnerNestedInput? tasks;

  final ChannelUncheckedUpdateManyWithoutOwnerNestedInput? channels;

  final TaskAssignmentUncheckedUpdateManyWithoutProfileNestedInput?
      taskAssignments;

  final ChannelSubscriptionUncheckedUpdateManyWithoutProfileNestedInput?
      channelSubscriptions;

  final ScheduleUncheckedUpdateManyWithoutProfileNestedInput? schedules;

  final RecordUncheckedUpdateManyWithoutProfileNestedInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUncheckedUpdateWithoutTagsInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUpsertWithWhereUniqueWithoutTagInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsUpsertWithWhereUniqueWithoutTagInput({
    required this.where,
    required this.update,
    required this.create,
  });

  factory TaskAssignmentTagsUpsertWithWhereUniqueWithoutTagInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUpsertWithWhereUniqueWithoutTagInputFromJson(json);

  final TaskAssignmentTagsWhereUniqueInput where;

  final TaskAssignmentTagsUpdateWithoutTagInput update;

  final TaskAssignmentTagsCreateWithoutTagInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsUpsertWithWhereUniqueWithoutTagInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUpdateWithWhereUniqueWithoutTagInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsUpdateWithWhereUniqueWithoutTagInput({
    required this.where,
    required this.data,
  });

  factory TaskAssignmentTagsUpdateWithWhereUniqueWithoutTagInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUpdateWithWhereUniqueWithoutTagInputFromJson(json);

  final TaskAssignmentTagsWhereUniqueInput where;

  final TaskAssignmentTagsUpdateWithoutTagInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsUpdateWithWhereUniqueWithoutTagInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUpdateManyWithWhereWithoutTagInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsUpdateManyWithWhereWithoutTagInput({
    required this.where,
    required this.data,
  });

  factory TaskAssignmentTagsUpdateManyWithWhereWithoutTagInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUpdateManyWithWhereWithoutTagInputFromJson(json);

  final TaskAssignmentTagsScalarWhereInput where;

  final TaskAssignmentTagsUpdateManyMutationInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsUpdateManyWithWhereWithoutTagInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsScalarWhereInput implements _i1.JsonSerializable {
  const TaskAssignmentTagsScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.tagName,
  });

  factory TaskAssignmentTagsScalarWhereInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsScalarWhereInputFromJson(json);

  final Iterable<TaskAssignmentTagsScalarWhereInput>? AND;

  final Iterable<TaskAssignmentTagsScalarWhereInput>? OR;

  final Iterable<TaskAssignmentTagsScalarWhereInput>? NOT;

  final StringFilter? taskUuid;

  final IntFilter? userId;

  final StringFilter? profileName;

  final StringFilter? tagName;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsScalarWhereInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateWithoutAssignmentsInput implements _i1.JsonSerializable {
  const TaskCreateWithoutAssignmentsInput({
    required this.uuid,
    required this.title,
    required this.desc,
    required this.content,
    this.location,
    required this.requireLocation,
    required this.requireTime,
    required this.requireAttachment,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    required this.owner,
    this.parent,
    this.children,
    this.channel,
    this.assets,
    this.sessions,
    this.records,
  });

  factory TaskCreateWithoutAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskCreateWithoutAssignmentsInputFromJson(json);

  final String uuid;

  final String title;

  final String desc;

  final String content;

  final String? location;

  final bool requireLocation;

  final bool requireTime;

  final bool requireAttachment;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final ProfileCreateNestedOneWithoutTasksInput owner;

  final TaskCreateNestedOneWithoutChildrenInput? parent;

  final TaskCreateNestedManyWithoutParentInput? children;

  final ChannelCreateNestedOneWithoutTasksInput? channel;

  final TaskAssetCreateNestedManyWithoutTaskInput? assets;

  final SessionCreateNestedManyWithoutTaskInput? sessions;

  final RecordCreateNestedManyWithoutTaskInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskCreateWithoutAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedCreateWithoutAssignmentsInput
    implements _i1.JsonSerializable {
  const TaskUncheckedCreateWithoutAssignmentsInput({
    required this.uuid,
    required this.title,
    required this.desc,
    required this.content,
    this.location,
    required this.requireLocation,
    required this.requireTime,
    required this.requireAttachment,
    required this.userId,
    required this.profile,
    this.parentUuid,
    this.channelUuid,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.children,
    this.assets,
    this.sessions,
    this.records,
  });

  factory TaskUncheckedCreateWithoutAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUncheckedCreateWithoutAssignmentsInputFromJson(json);

  final String uuid;

  final String title;

  final String desc;

  final String content;

  final String? location;

  final bool requireLocation;

  final bool requireTime;

  final bool requireAttachment;

  final int userId;

  final String profile;

  final String? parentUuid;

  final String? channelUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final TaskUncheckedCreateNestedManyWithoutParentInput? children;

  final TaskAssetUncheckedCreateNestedManyWithoutTaskInput? assets;

  final SessionUncheckedCreateNestedManyWithoutTaskInput? sessions;

  final RecordUncheckedCreateNestedManyWithoutTaskInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUncheckedCreateWithoutAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateOrConnectWithoutAssignmentsInput
    implements _i1.JsonSerializable {
  const TaskCreateOrConnectWithoutAssignmentsInput({
    required this.where,
    required this.create,
  });

  factory TaskCreateOrConnectWithoutAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskCreateOrConnectWithoutAssignmentsInputFromJson(json);

  final TaskWhereUniqueInput where;

  final TaskCreateWithoutAssignmentsInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskCreateOrConnectWithoutAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateWithoutTaskAssignmentsInput implements _i1.JsonSerializable {
  const ProfileCreateWithoutTaskAssignmentsInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    required this.user,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileCreateWithoutTaskAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateWithoutTaskAssignmentsInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final UserCreateNestedOneWithoutProfilesInput user;

  final CategoryCreateNestedManyWithoutProfileInput? categories;

  final TagCreateNestedManyWithoutProfileInput? tags;

  final TaskCreateNestedManyWithoutOwnerInput? tasks;

  final ChannelCreateNestedManyWithoutOwnerInput? channels;

  final ChannelSubscriptionCreateNestedManyWithoutProfileInput?
      channelSubscriptions;

  final ScheduleCreateNestedManyWithoutProfileInput? schedules;

  final RecordCreateNestedManyWithoutProfileInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateWithoutTaskAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUncheckedCreateWithoutTaskAssignmentsInput
    implements _i1.JsonSerializable {
  const ProfileUncheckedCreateWithoutTaskAssignmentsInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.userId,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileUncheckedCreateWithoutTaskAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUncheckedCreateWithoutTaskAssignmentsInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final int userId;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final CategoryUncheckedCreateNestedManyWithoutProfileInput? categories;

  final TagUncheckedCreateNestedManyWithoutProfileInput? tags;

  final TaskUncheckedCreateNestedManyWithoutOwnerInput? tasks;

  final ChannelUncheckedCreateNestedManyWithoutOwnerInput? channels;

  final ChannelSubscriptionUncheckedCreateNestedManyWithoutProfileInput?
      channelSubscriptions;

  final ScheduleUncheckedCreateNestedManyWithoutProfileInput? schedules;

  final RecordUncheckedCreateNestedManyWithoutProfileInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUncheckedCreateWithoutTaskAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateOrConnectWithoutTaskAssignmentsInput
    implements _i1.JsonSerializable {
  const ProfileCreateOrConnectWithoutTaskAssignmentsInput({
    required this.where,
    required this.create,
  });

  factory ProfileCreateOrConnectWithoutTaskAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateOrConnectWithoutTaskAssignmentsInputFromJson(json);

  final ProfileWhereUniqueInput where;

  final ProfileCreateWithoutTaskAssignmentsInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateOrConnectWithoutTaskAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class CategoryCreateWithoutAssignmentsInput implements _i1.JsonSerializable {
  const CategoryCreateWithoutAssignmentsInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    required this.profile,
  });

  factory CategoryCreateWithoutAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryCreateWithoutAssignmentsInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final ProfileCreateNestedOneWithoutCategoriesInput profile;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryCreateWithoutAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class CategoryUncheckedCreateWithoutAssignmentsInput
    implements _i1.JsonSerializable {
  const CategoryUncheckedCreateWithoutAssignmentsInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory CategoryUncheckedCreateWithoutAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryUncheckedCreateWithoutAssignmentsInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryUncheckedCreateWithoutAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class CategoryCreateOrConnectWithoutAssignmentsInput
    implements _i1.JsonSerializable {
  const CategoryCreateOrConnectWithoutAssignmentsInput({
    required this.where,
    required this.create,
  });

  factory CategoryCreateOrConnectWithoutAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryCreateOrConnectWithoutAssignmentsInputFromJson(json);

  final CategoryWhereUniqueInput where;

  final CategoryCreateWithoutAssignmentsInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryCreateOrConnectWithoutAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsCreateWithoutAssignmentInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsCreateWithoutAssignmentInput({required this.tag});

  factory TaskAssignmentTagsCreateWithoutAssignmentInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsCreateWithoutAssignmentInputFromJson(json);

  final TagCreateNestedOneWithoutAssignmentsInput tag;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsCreateWithoutAssignmentInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUncheckedCreateWithoutAssignmentInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsUncheckedCreateWithoutAssignmentInput(
      {required this.tagName});

  factory TaskAssignmentTagsUncheckedCreateWithoutAssignmentInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUncheckedCreateWithoutAssignmentInputFromJson(json);

  final String tagName;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsUncheckedCreateWithoutAssignmentInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsCreateOrConnectWithoutAssignmentInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsCreateOrConnectWithoutAssignmentInput({
    required this.where,
    required this.create,
  });

  factory TaskAssignmentTagsCreateOrConnectWithoutAssignmentInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsCreateOrConnectWithoutAssignmentInputFromJson(json);

  final TaskAssignmentTagsWhereUniqueInput where;

  final TaskAssignmentTagsCreateWithoutAssignmentInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsCreateOrConnectWithoutAssignmentInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsCreateManyAssignmentInputEnvelope
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsCreateManyAssignmentInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  factory TaskAssignmentTagsCreateManyAssignmentInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsCreateManyAssignmentInputEnvelopeFromJson(json);

  final Iterable<TaskAssignmentTagsCreateManyAssignmentInput> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsCreateManyAssignmentInputEnvelopeToJson(this);
}

@_i1.jsonSerializable
class TaskUpsertWithoutAssignmentsInput implements _i1.JsonSerializable {
  const TaskUpsertWithoutAssignmentsInput({
    required this.update,
    required this.create,
  });

  factory TaskUpsertWithoutAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUpsertWithoutAssignmentsInputFromJson(json);

  final TaskUpdateWithoutAssignmentsInput update;

  final TaskCreateWithoutAssignmentsInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUpsertWithoutAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpdateWithoutAssignmentsInput implements _i1.JsonSerializable {
  const TaskUpdateWithoutAssignmentsInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.owner,
    this.parent,
    this.children,
    this.channel,
    this.assets,
    this.sessions,
    this.records,
  });

  factory TaskUpdateWithoutAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUpdateWithoutAssignmentsInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? title;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? content;

  final NullableStringFieldUpdateOperationsInput? location;

  final BoolFieldUpdateOperationsInput? requireLocation;

  final BoolFieldUpdateOperationsInput? requireTime;

  final BoolFieldUpdateOperationsInput? requireAttachment;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ProfileUpdateOneRequiredWithoutTasksNestedInput? owner;

  final TaskUpdateOneWithoutChildrenNestedInput? parent;

  final TaskUpdateManyWithoutParentNestedInput? children;

  final ChannelUpdateOneWithoutTasksNestedInput? channel;

  final TaskAssetUpdateManyWithoutTaskNestedInput? assets;

  final SessionUpdateManyWithoutTaskNestedInput? sessions;

  final RecordUpdateManyWithoutTaskNestedInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUpdateWithoutAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedUpdateWithoutAssignmentsInput
    implements _i1.JsonSerializable {
  const TaskUncheckedUpdateWithoutAssignmentsInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.userId,
    this.profile,
    this.parentUuid,
    this.channelUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.children,
    this.assets,
    this.sessions,
    this.records,
  });

  factory TaskUncheckedUpdateWithoutAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUncheckedUpdateWithoutAssignmentsInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? title;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? content;

  final NullableStringFieldUpdateOperationsInput? location;

  final BoolFieldUpdateOperationsInput? requireLocation;

  final BoolFieldUpdateOperationsInput? requireTime;

  final BoolFieldUpdateOperationsInput? requireAttachment;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profile;

  final NullableStringFieldUpdateOperationsInput? parentUuid;

  final NullableStringFieldUpdateOperationsInput? channelUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskUncheckedUpdateManyWithoutParentNestedInput? children;

  final TaskAssetUncheckedUpdateManyWithoutTaskNestedInput? assets;

  final SessionUncheckedUpdateManyWithoutTaskNestedInput? sessions;

  final RecordUncheckedUpdateManyWithoutTaskNestedInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUncheckedUpdateWithoutAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpsertWithoutTaskAssignmentsInput implements _i1.JsonSerializable {
  const ProfileUpsertWithoutTaskAssignmentsInput({
    required this.update,
    required this.create,
  });

  factory ProfileUpsertWithoutTaskAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUpsertWithoutTaskAssignmentsInputFromJson(json);

  final ProfileUpdateWithoutTaskAssignmentsInput update;

  final ProfileCreateWithoutTaskAssignmentsInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUpsertWithoutTaskAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpdateWithoutTaskAssignmentsInput implements _i1.JsonSerializable {
  const ProfileUpdateWithoutTaskAssignmentsInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.user,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileUpdateWithoutTaskAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUpdateWithoutTaskAssignmentsInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final UserUpdateOneRequiredWithoutProfilesNestedInput? user;

  final CategoryUpdateManyWithoutProfileNestedInput? categories;

  final TagUpdateManyWithoutProfileNestedInput? tags;

  final TaskUpdateManyWithoutOwnerNestedInput? tasks;

  final ChannelUpdateManyWithoutOwnerNestedInput? channels;

  final ChannelSubscriptionUpdateManyWithoutProfileNestedInput?
      channelSubscriptions;

  final ScheduleUpdateManyWithoutProfileNestedInput? schedules;

  final RecordUpdateManyWithoutProfileNestedInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUpdateWithoutTaskAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUncheckedUpdateWithoutTaskAssignmentsInput
    implements _i1.JsonSerializable {
  const ProfileUncheckedUpdateWithoutTaskAssignmentsInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileUncheckedUpdateWithoutTaskAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUncheckedUpdateWithoutTaskAssignmentsInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final IntFieldUpdateOperationsInput? userId;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final CategoryUncheckedUpdateManyWithoutProfileNestedInput? categories;

  final TagUncheckedUpdateManyWithoutProfileNestedInput? tags;

  final TaskUncheckedUpdateManyWithoutOwnerNestedInput? tasks;

  final ChannelUncheckedUpdateManyWithoutOwnerNestedInput? channels;

  final ChannelSubscriptionUncheckedUpdateManyWithoutProfileNestedInput?
      channelSubscriptions;

  final ScheduleUncheckedUpdateManyWithoutProfileNestedInput? schedules;

  final RecordUncheckedUpdateManyWithoutProfileNestedInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUncheckedUpdateWithoutTaskAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class CategoryUpsertWithoutAssignmentsInput implements _i1.JsonSerializable {
  const CategoryUpsertWithoutAssignmentsInput({
    required this.update,
    required this.create,
  });

  factory CategoryUpsertWithoutAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryUpsertWithoutAssignmentsInputFromJson(json);

  final CategoryUpdateWithoutAssignmentsInput update;

  final CategoryCreateWithoutAssignmentsInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryUpsertWithoutAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class CategoryUpdateWithoutAssignmentsInput implements _i1.JsonSerializable {
  const CategoryUpdateWithoutAssignmentsInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.profile,
  });

  factory CategoryUpdateWithoutAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryUpdateWithoutAssignmentsInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ProfileUpdateOneRequiredWithoutCategoriesNestedInput? profile;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryUpdateWithoutAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class CategoryUncheckedUpdateWithoutAssignmentsInput
    implements _i1.JsonSerializable {
  const CategoryUncheckedUpdateWithoutAssignmentsInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory CategoryUncheckedUpdateWithoutAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryUncheckedUpdateWithoutAssignmentsInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryUncheckedUpdateWithoutAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUpsertWithWhereUniqueWithoutAssignmentInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsUpsertWithWhereUniqueWithoutAssignmentInput({
    required this.where,
    required this.update,
    required this.create,
  });

  factory TaskAssignmentTagsUpsertWithWhereUniqueWithoutAssignmentInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUpsertWithWhereUniqueWithoutAssignmentInputFromJson(
          json);

  final TaskAssignmentTagsWhereUniqueInput where;

  final TaskAssignmentTagsUpdateWithoutAssignmentInput update;

  final TaskAssignmentTagsCreateWithoutAssignmentInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsUpsertWithWhereUniqueWithoutAssignmentInputToJson(
          this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUpdateWithWhereUniqueWithoutAssignmentInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsUpdateWithWhereUniqueWithoutAssignmentInput({
    required this.where,
    required this.data,
  });

  factory TaskAssignmentTagsUpdateWithWhereUniqueWithoutAssignmentInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUpdateWithWhereUniqueWithoutAssignmentInputFromJson(
          json);

  final TaskAssignmentTagsWhereUniqueInput where;

  final TaskAssignmentTagsUpdateWithoutAssignmentInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsUpdateWithWhereUniqueWithoutAssignmentInputToJson(
          this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUpdateManyWithWhereWithoutAssignmentInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsUpdateManyWithWhereWithoutAssignmentInput({
    required this.where,
    required this.data,
  });

  factory TaskAssignmentTagsUpdateManyWithWhereWithoutAssignmentInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUpdateManyWithWhereWithoutAssignmentInputFromJson(
          json);

  final TaskAssignmentTagsScalarWhereInput where;

  final TaskAssignmentTagsUpdateManyMutationInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsUpdateManyWithWhereWithoutAssignmentInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentCreateWithoutTagsInput implements _i1.JsonSerializable {
  const TaskAssignmentCreateWithoutTagsInput({
    required this.status,
    required this.priority,
    required this.starred,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    required this.task,
    required this.profile,
    this.category,
  });

  factory TaskAssignmentCreateWithoutTagsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentCreateWithoutTagsInputFromJson(json);

  final TaskAssignmentStatus status;

  final TaskPriority priority;

  final bool starred;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final TaskCreateNestedOneWithoutAssignmentsInput task;

  final ProfileCreateNestedOneWithoutTaskAssignmentsInput profile;

  final CategoryCreateNestedOneWithoutAssignmentsInput? category;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentCreateWithoutTagsInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUncheckedCreateWithoutTagsInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUncheckedCreateWithoutTagsInput({
    required this.status,
    required this.priority,
    required this.starred,
    required this.taskUuid,
    required this.userId,
    required this.profileName,
    this.categoryName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory TaskAssignmentUncheckedCreateWithoutTagsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUncheckedCreateWithoutTagsInputFromJson(json);

  final TaskAssignmentStatus status;

  final TaskPriority priority;

  final bool starred;

  final String taskUuid;

  final int userId;

  final String profileName;

  final String? categoryName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUncheckedCreateWithoutTagsInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentCreateOrConnectWithoutTagsInput
    implements _i1.JsonSerializable {
  const TaskAssignmentCreateOrConnectWithoutTagsInput({
    required this.where,
    required this.create,
  });

  factory TaskAssignmentCreateOrConnectWithoutTagsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentCreateOrConnectWithoutTagsInputFromJson(json);

  final TaskAssignmentWhereUniqueInput where;

  final TaskAssignmentCreateWithoutTagsInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentCreateOrConnectWithoutTagsInputToJson(this);
}

@_i1.jsonSerializable
class TagCreateWithoutAssignmentsInput implements _i1.JsonSerializable {
  const TagCreateWithoutAssignmentsInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    required this.profile,
  });

  factory TagCreateWithoutAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TagCreateWithoutAssignmentsInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final ProfileCreateNestedOneWithoutTagsInput profile;

  @override
  Map<String, dynamic> toJson() =>
      _$TagCreateWithoutAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class TagUncheckedCreateWithoutAssignmentsInput
    implements _i1.JsonSerializable {
  const TagUncheckedCreateWithoutAssignmentsInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory TagUncheckedCreateWithoutAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TagUncheckedCreateWithoutAssignmentsInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TagUncheckedCreateWithoutAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class TagCreateOrConnectWithoutAssignmentsInput
    implements _i1.JsonSerializable {
  const TagCreateOrConnectWithoutAssignmentsInput({
    required this.where,
    required this.create,
  });

  factory TagCreateOrConnectWithoutAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TagCreateOrConnectWithoutAssignmentsInputFromJson(json);

  final TagWhereUniqueInput where;

  final TagCreateWithoutAssignmentsInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TagCreateOrConnectWithoutAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUpsertWithoutTagsInput implements _i1.JsonSerializable {
  const TaskAssignmentUpsertWithoutTagsInput({
    required this.update,
    required this.create,
  });

  factory TaskAssignmentUpsertWithoutTagsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUpsertWithoutTagsInputFromJson(json);

  final TaskAssignmentUpdateWithoutTagsInput update;

  final TaskAssignmentCreateWithoutTagsInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUpsertWithoutTagsInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUpdateWithoutTagsInput implements _i1.JsonSerializable {
  const TaskAssignmentUpdateWithoutTagsInput({
    this.status,
    this.priority,
    this.starred,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.task,
    this.profile,
    this.category,
  });

  factory TaskAssignmentUpdateWithoutTagsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUpdateWithoutTagsInputFromJson(json);

  final TaskAssignmentStatus? status;

  final TaskPriority? priority;

  final BoolFieldUpdateOperationsInput? starred;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskUpdateOneRequiredWithoutAssignmentsNestedInput? task;

  final ProfileUpdateOneRequiredWithoutTaskAssignmentsNestedInput? profile;

  final CategoryUpdateOneWithoutAssignmentsNestedInput? category;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUpdateWithoutTagsInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUncheckedUpdateWithoutTagsInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUncheckedUpdateWithoutTagsInput({
    this.status,
    this.priority,
    this.starred,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.categoryName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssignmentUncheckedUpdateWithoutTagsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUncheckedUpdateWithoutTagsInputFromJson(json);

  final TaskAssignmentStatus? status;

  final TaskPriority? priority;

  final BoolFieldUpdateOperationsInput? starred;

  final StringFieldUpdateOperationsInput? taskUuid;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final NullableStringFieldUpdateOperationsInput? categoryName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUncheckedUpdateWithoutTagsInputToJson(this);
}

@_i1.jsonSerializable
class TagUpsertWithoutAssignmentsInput implements _i1.JsonSerializable {
  const TagUpsertWithoutAssignmentsInput({
    required this.update,
    required this.create,
  });

  factory TagUpsertWithoutAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TagUpsertWithoutAssignmentsInputFromJson(json);

  final TagUpdateWithoutAssignmentsInput update;

  final TagCreateWithoutAssignmentsInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$TagUpsertWithoutAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class TagUpdateWithoutAssignmentsInput implements _i1.JsonSerializable {
  const TagUpdateWithoutAssignmentsInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.profile,
  });

  factory TagUpdateWithoutAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TagUpdateWithoutAssignmentsInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ProfileUpdateOneRequiredWithoutTagsNestedInput? profile;

  @override
  Map<String, dynamic> toJson() =>
      _$TagUpdateWithoutAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class TagUncheckedUpdateWithoutAssignmentsInput
    implements _i1.JsonSerializable {
  const TagUncheckedUpdateWithoutAssignmentsInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TagUncheckedUpdateWithoutAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TagUncheckedUpdateWithoutAssignmentsInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TagUncheckedUpdateWithoutAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class ChannelCreateWithoutSubscriptionsInput implements _i1.JsonSerializable {
  const ChannelCreateWithoutSubscriptionsInput({
    required this.uuid,
    required this.name,
    required this.desc,
    required this.color,
    this.imgRef,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    required this.owner,
    this.tasks,
  });

  factory ChannelCreateWithoutSubscriptionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelCreateWithoutSubscriptionsInputFromJson(json);

  final String uuid;

  final String name;

  final String desc;

  final String color;

  final String? imgRef;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final ProfileCreateNestedOneWithoutChannelsInput owner;

  final TaskCreateNestedManyWithoutChannelInput? tasks;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelCreateWithoutSubscriptionsInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUncheckedCreateWithoutSubscriptionsInput
    implements _i1.JsonSerializable {
  const ChannelUncheckedCreateWithoutSubscriptionsInput({
    required this.uuid,
    required this.name,
    required this.desc,
    required this.color,
    this.imgRef,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.tasks,
  });

  factory ChannelUncheckedCreateWithoutSubscriptionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelUncheckedCreateWithoutSubscriptionsInputFromJson(json);

  final String uuid;

  final String name;

  final String desc;

  final String color;

  final String? imgRef;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final TaskUncheckedCreateNestedManyWithoutChannelInput? tasks;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelUncheckedCreateWithoutSubscriptionsInputToJson(this);
}

@_i1.jsonSerializable
class ChannelCreateOrConnectWithoutSubscriptionsInput
    implements _i1.JsonSerializable {
  const ChannelCreateOrConnectWithoutSubscriptionsInput({
    required this.where,
    required this.create,
  });

  factory ChannelCreateOrConnectWithoutSubscriptionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelCreateOrConnectWithoutSubscriptionsInputFromJson(json);

  final ChannelWhereUniqueInput where;

  final ChannelCreateWithoutSubscriptionsInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelCreateOrConnectWithoutSubscriptionsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateWithoutChannelSubscriptionsInput
    implements _i1.JsonSerializable {
  const ProfileCreateWithoutChannelSubscriptionsInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    required this.user,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.schedules,
    this.records,
  });

  factory ProfileCreateWithoutChannelSubscriptionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateWithoutChannelSubscriptionsInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final UserCreateNestedOneWithoutProfilesInput user;

  final CategoryCreateNestedManyWithoutProfileInput? categories;

  final TagCreateNestedManyWithoutProfileInput? tags;

  final TaskCreateNestedManyWithoutOwnerInput? tasks;

  final ChannelCreateNestedManyWithoutOwnerInput? channels;

  final TaskAssignmentCreateNestedManyWithoutProfileInput? taskAssignments;

  final ScheduleCreateNestedManyWithoutProfileInput? schedules;

  final RecordCreateNestedManyWithoutProfileInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateWithoutChannelSubscriptionsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUncheckedCreateWithoutChannelSubscriptionsInput
    implements _i1.JsonSerializable {
  const ProfileUncheckedCreateWithoutChannelSubscriptionsInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.userId,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.schedules,
    this.records,
  });

  factory ProfileUncheckedCreateWithoutChannelSubscriptionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUncheckedCreateWithoutChannelSubscriptionsInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final int userId;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final CategoryUncheckedCreateNestedManyWithoutProfileInput? categories;

  final TagUncheckedCreateNestedManyWithoutProfileInput? tags;

  final TaskUncheckedCreateNestedManyWithoutOwnerInput? tasks;

  final ChannelUncheckedCreateNestedManyWithoutOwnerInput? channels;

  final TaskAssignmentUncheckedCreateNestedManyWithoutProfileInput?
      taskAssignments;

  final ScheduleUncheckedCreateNestedManyWithoutProfileInput? schedules;

  final RecordUncheckedCreateNestedManyWithoutProfileInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUncheckedCreateWithoutChannelSubscriptionsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateOrConnectWithoutChannelSubscriptionsInput
    implements _i1.JsonSerializable {
  const ProfileCreateOrConnectWithoutChannelSubscriptionsInput({
    required this.where,
    required this.create,
  });

  factory ProfileCreateOrConnectWithoutChannelSubscriptionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateOrConnectWithoutChannelSubscriptionsInputFromJson(json);

  final ProfileWhereUniqueInput where;

  final ProfileCreateWithoutChannelSubscriptionsInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateOrConnectWithoutChannelSubscriptionsInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUpsertWithoutSubscriptionsInput implements _i1.JsonSerializable {
  const ChannelUpsertWithoutSubscriptionsInput({
    required this.update,
    required this.create,
  });

  factory ChannelUpsertWithoutSubscriptionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelUpsertWithoutSubscriptionsInputFromJson(json);

  final ChannelUpdateWithoutSubscriptionsInput update;

  final ChannelCreateWithoutSubscriptionsInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelUpsertWithoutSubscriptionsInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUpdateWithoutSubscriptionsInput implements _i1.JsonSerializable {
  const ChannelUpdateWithoutSubscriptionsInput({
    this.uuid,
    this.name,
    this.desc,
    this.color,
    this.imgRef,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.owner,
    this.tasks,
  });

  factory ChannelUpdateWithoutSubscriptionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelUpdateWithoutSubscriptionsInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? color;

  final NullableStringFieldUpdateOperationsInput? imgRef;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ProfileUpdateOneRequiredWithoutChannelsNestedInput? owner;

  final TaskUpdateManyWithoutChannelNestedInput? tasks;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelUpdateWithoutSubscriptionsInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUncheckedUpdateWithoutSubscriptionsInput
    implements _i1.JsonSerializable {
  const ChannelUncheckedUpdateWithoutSubscriptionsInput({
    this.uuid,
    this.name,
    this.desc,
    this.color,
    this.imgRef,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.tasks,
  });

  factory ChannelUncheckedUpdateWithoutSubscriptionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelUncheckedUpdateWithoutSubscriptionsInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? color;

  final NullableStringFieldUpdateOperationsInput? imgRef;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskUncheckedUpdateManyWithoutChannelNestedInput? tasks;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelUncheckedUpdateWithoutSubscriptionsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpsertWithoutChannelSubscriptionsInput
    implements _i1.JsonSerializable {
  const ProfileUpsertWithoutChannelSubscriptionsInput({
    required this.update,
    required this.create,
  });

  factory ProfileUpsertWithoutChannelSubscriptionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUpsertWithoutChannelSubscriptionsInputFromJson(json);

  final ProfileUpdateWithoutChannelSubscriptionsInput update;

  final ProfileCreateWithoutChannelSubscriptionsInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUpsertWithoutChannelSubscriptionsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpdateWithoutChannelSubscriptionsInput
    implements _i1.JsonSerializable {
  const ProfileUpdateWithoutChannelSubscriptionsInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.user,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.schedules,
    this.records,
  });

  factory ProfileUpdateWithoutChannelSubscriptionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUpdateWithoutChannelSubscriptionsInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final UserUpdateOneRequiredWithoutProfilesNestedInput? user;

  final CategoryUpdateManyWithoutProfileNestedInput? categories;

  final TagUpdateManyWithoutProfileNestedInput? tags;

  final TaskUpdateManyWithoutOwnerNestedInput? tasks;

  final ChannelUpdateManyWithoutOwnerNestedInput? channels;

  final TaskAssignmentUpdateManyWithoutProfileNestedInput? taskAssignments;

  final ScheduleUpdateManyWithoutProfileNestedInput? schedules;

  final RecordUpdateManyWithoutProfileNestedInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUpdateWithoutChannelSubscriptionsInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUncheckedUpdateWithoutChannelSubscriptionsInput
    implements _i1.JsonSerializable {
  const ProfileUncheckedUpdateWithoutChannelSubscriptionsInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.schedules,
    this.records,
  });

  factory ProfileUncheckedUpdateWithoutChannelSubscriptionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUncheckedUpdateWithoutChannelSubscriptionsInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final IntFieldUpdateOperationsInput? userId;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final CategoryUncheckedUpdateManyWithoutProfileNestedInput? categories;

  final TagUncheckedUpdateManyWithoutProfileNestedInput? tags;

  final TaskUncheckedUpdateManyWithoutOwnerNestedInput? tasks;

  final ChannelUncheckedUpdateManyWithoutOwnerNestedInput? channels;

  final TaskAssignmentUncheckedUpdateManyWithoutProfileNestedInput?
      taskAssignments;

  final ScheduleUncheckedUpdateManyWithoutProfileNestedInput? schedules;

  final RecordUncheckedUpdateManyWithoutProfileNestedInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUncheckedUpdateWithoutChannelSubscriptionsInputToJson(this);
}

@_i1.jsonSerializable
class SessionCreateWithoutSchedulesInput implements _i1.JsonSerializable {
  const SessionCreateWithoutSchedulesInput({
    required this.uuid,
    required this.start,
    required this.end,
    required this.cycle,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    required this.task,
    this.records,
  });

  factory SessionCreateWithoutSchedulesInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionCreateWithoutSchedulesInputFromJson(json);

  final String uuid;

  final BigInt start;

  final BigInt end;

  final BigInt cycle;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final TaskCreateNestedOneWithoutSessionsInput task;

  final RecordCreateNestedManyWithoutSessionInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionCreateWithoutSchedulesInputToJson(this);
}

@_i1.jsonSerializable
class SessionUncheckedCreateWithoutSchedulesInput
    implements _i1.JsonSerializable {
  const SessionUncheckedCreateWithoutSchedulesInput({
    required this.uuid,
    required this.start,
    required this.end,
    required this.cycle,
    required this.taskUuid,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
    this.records,
  });

  factory SessionUncheckedCreateWithoutSchedulesInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionUncheckedCreateWithoutSchedulesInputFromJson(json);

  final String uuid;

  final BigInt start;

  final BigInt end;

  final BigInt cycle;

  final String taskUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  final RecordUncheckedCreateNestedManyWithoutSessionInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionUncheckedCreateWithoutSchedulesInputToJson(this);
}

@_i1.jsonSerializable
class SessionCreateOrConnectWithoutSchedulesInput
    implements _i1.JsonSerializable {
  const SessionCreateOrConnectWithoutSchedulesInput({
    required this.where,
    required this.create,
  });

  factory SessionCreateOrConnectWithoutSchedulesInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionCreateOrConnectWithoutSchedulesInputFromJson(json);

  final SessionWhereUniqueInput where;

  final SessionCreateWithoutSchedulesInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionCreateOrConnectWithoutSchedulesInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateWithoutSchedulesInput implements _i1.JsonSerializable {
  const ProfileCreateWithoutSchedulesInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    required this.user,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.records,
  });

  factory ProfileCreateWithoutSchedulesInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateWithoutSchedulesInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final UserCreateNestedOneWithoutProfilesInput user;

  final CategoryCreateNestedManyWithoutProfileInput? categories;

  final TagCreateNestedManyWithoutProfileInput? tags;

  final TaskCreateNestedManyWithoutOwnerInput? tasks;

  final ChannelCreateNestedManyWithoutOwnerInput? channels;

  final TaskAssignmentCreateNestedManyWithoutProfileInput? taskAssignments;

  final ChannelSubscriptionCreateNestedManyWithoutProfileInput?
      channelSubscriptions;

  final RecordCreateNestedManyWithoutProfileInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateWithoutSchedulesInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUncheckedCreateWithoutSchedulesInput
    implements _i1.JsonSerializable {
  const ProfileUncheckedCreateWithoutSchedulesInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.userId,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.records,
  });

  factory ProfileUncheckedCreateWithoutSchedulesInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUncheckedCreateWithoutSchedulesInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final int userId;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  final CategoryUncheckedCreateNestedManyWithoutProfileInput? categories;

  final TagUncheckedCreateNestedManyWithoutProfileInput? tags;

  final TaskUncheckedCreateNestedManyWithoutOwnerInput? tasks;

  final ChannelUncheckedCreateNestedManyWithoutOwnerInput? channels;

  final TaskAssignmentUncheckedCreateNestedManyWithoutProfileInput?
      taskAssignments;

  final ChannelSubscriptionUncheckedCreateNestedManyWithoutProfileInput?
      channelSubscriptions;

  final RecordUncheckedCreateNestedManyWithoutProfileInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUncheckedCreateWithoutSchedulesInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateOrConnectWithoutSchedulesInput
    implements _i1.JsonSerializable {
  const ProfileCreateOrConnectWithoutSchedulesInput({
    required this.where,
    required this.create,
  });

  factory ProfileCreateOrConnectWithoutSchedulesInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileCreateOrConnectWithoutSchedulesInputFromJson(json);

  final ProfileWhereUniqueInput where;

  final ProfileCreateWithoutSchedulesInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileCreateOrConnectWithoutSchedulesInputToJson(this);
}

@_i1.jsonSerializable
class SessionUpsertWithoutSchedulesInput implements _i1.JsonSerializable {
  const SessionUpsertWithoutSchedulesInput({
    required this.update,
    required this.create,
  });

  factory SessionUpsertWithoutSchedulesInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionUpsertWithoutSchedulesInputFromJson(json);

  final SessionUpdateWithoutSchedulesInput update;

  final SessionCreateWithoutSchedulesInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionUpsertWithoutSchedulesInputToJson(this);
}

@_i1.jsonSerializable
class SessionUpdateWithoutSchedulesInput implements _i1.JsonSerializable {
  const SessionUpdateWithoutSchedulesInput({
    this.uuid,
    this.start,
    this.end,
    this.cycle,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.task,
    this.records,
  });

  factory SessionUpdateWithoutSchedulesInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionUpdateWithoutSchedulesInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final BigIntFieldUpdateOperationsInput? start;

  final BigIntFieldUpdateOperationsInput? end;

  final BigIntFieldUpdateOperationsInput? cycle;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskUpdateOneRequiredWithoutSessionsNestedInput? task;

  final RecordUpdateManyWithoutSessionNestedInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionUpdateWithoutSchedulesInputToJson(this);
}

@_i1.jsonSerializable
class SessionUncheckedUpdateWithoutSchedulesInput
    implements _i1.JsonSerializable {
  const SessionUncheckedUpdateWithoutSchedulesInput({
    this.uuid,
    this.start,
    this.end,
    this.cycle,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.records,
  });

  factory SessionUncheckedUpdateWithoutSchedulesInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionUncheckedUpdateWithoutSchedulesInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final BigIntFieldUpdateOperationsInput? start;

  final BigIntFieldUpdateOperationsInput? end;

  final BigIntFieldUpdateOperationsInput? cycle;

  final StringFieldUpdateOperationsInput? taskUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final RecordUncheckedUpdateManyWithoutSessionNestedInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionUncheckedUpdateWithoutSchedulesInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpsertWithoutSchedulesInput implements _i1.JsonSerializable {
  const ProfileUpsertWithoutSchedulesInput({
    required this.update,
    required this.create,
  });

  factory ProfileUpsertWithoutSchedulesInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUpsertWithoutSchedulesInputFromJson(json);

  final ProfileUpdateWithoutSchedulesInput update;

  final ProfileCreateWithoutSchedulesInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUpsertWithoutSchedulesInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpdateWithoutSchedulesInput implements _i1.JsonSerializable {
  const ProfileUpdateWithoutSchedulesInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.user,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.records,
  });

  factory ProfileUpdateWithoutSchedulesInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUpdateWithoutSchedulesInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final UserUpdateOneRequiredWithoutProfilesNestedInput? user;

  final CategoryUpdateManyWithoutProfileNestedInput? categories;

  final TagUpdateManyWithoutProfileNestedInput? tags;

  final TaskUpdateManyWithoutOwnerNestedInput? tasks;

  final ChannelUpdateManyWithoutOwnerNestedInput? channels;

  final TaskAssignmentUpdateManyWithoutProfileNestedInput? taskAssignments;

  final ChannelSubscriptionUpdateManyWithoutProfileNestedInput?
      channelSubscriptions;

  final RecordUpdateManyWithoutProfileNestedInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUpdateWithoutSchedulesInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUncheckedUpdateWithoutSchedulesInput
    implements _i1.JsonSerializable {
  const ProfileUncheckedUpdateWithoutSchedulesInput({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.records,
  });

  factory ProfileUncheckedUpdateWithoutSchedulesInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUncheckedUpdateWithoutSchedulesInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final IntFieldUpdateOperationsInput? userId;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final CategoryUncheckedUpdateManyWithoutProfileNestedInput? categories;

  final TagUncheckedUpdateManyWithoutProfileNestedInput? tags;

  final TaskUncheckedUpdateManyWithoutOwnerNestedInput? tasks;

  final ChannelUncheckedUpdateManyWithoutOwnerNestedInput? channels;

  final TaskAssignmentUncheckedUpdateManyWithoutProfileNestedInput?
      taskAssignments;

  final ChannelSubscriptionUncheckedUpdateManyWithoutProfileNestedInput?
      channelSubscriptions;

  final RecordUncheckedUpdateManyWithoutProfileNestedInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUncheckedUpdateWithoutSchedulesInputToJson(this);
}

@_i1.jsonSerializable
class ProfileCreateManyUserInput implements _i1.JsonSerializable {
  const ProfileCreateManyUserInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
  });

  factory ProfileCreateManyUserInput.fromJson(Map<String, dynamic> json) =>
      _$ProfileCreateManyUserInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$ProfileCreateManyUserInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUpdateWithoutUserInput implements _i1.JsonSerializable {
  const ProfileUpdateWithoutUserInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileUpdateWithoutUserInput.fromJson(Map<String, dynamic> json) =>
      _$ProfileUpdateWithoutUserInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final CategoryUpdateManyWithoutProfileNestedInput? categories;

  final TagUpdateManyWithoutProfileNestedInput? tags;

  final TaskUpdateManyWithoutOwnerNestedInput? tasks;

  final ChannelUpdateManyWithoutOwnerNestedInput? channels;

  final TaskAssignmentUpdateManyWithoutProfileNestedInput? taskAssignments;

  final ChannelSubscriptionUpdateManyWithoutProfileNestedInput?
      channelSubscriptions;

  final ScheduleUpdateManyWithoutProfileNestedInput? schedules;

  final RecordUpdateManyWithoutProfileNestedInput? records;

  @override
  Map<String, dynamic> toJson() => _$ProfileUpdateWithoutUserInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUncheckedUpdateWithoutUserInput implements _i1.JsonSerializable {
  const ProfileUncheckedUpdateWithoutUserInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.categories,
    this.tags,
    this.tasks,
    this.channels,
    this.taskAssignments,
    this.channelSubscriptions,
    this.schedules,
    this.records,
  });

  factory ProfileUncheckedUpdateWithoutUserInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUncheckedUpdateWithoutUserInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final CategoryUncheckedUpdateManyWithoutProfileNestedInput? categories;

  final TagUncheckedUpdateManyWithoutProfileNestedInput? tags;

  final TaskUncheckedUpdateManyWithoutOwnerNestedInput? tasks;

  final ChannelUncheckedUpdateManyWithoutOwnerNestedInput? channels;

  final TaskAssignmentUncheckedUpdateManyWithoutProfileNestedInput?
      taskAssignments;

  final ChannelSubscriptionUncheckedUpdateManyWithoutProfileNestedInput?
      channelSubscriptions;

  final ScheduleUncheckedUpdateManyWithoutProfileNestedInput? schedules;

  final RecordUncheckedUpdateManyWithoutProfileNestedInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUncheckedUpdateWithoutUserInputToJson(this);
}

@_i1.jsonSerializable
class ProfileUncheckedUpdateManyWithoutProfilesInput
    implements _i1.JsonSerializable {
  const ProfileUncheckedUpdateManyWithoutProfilesInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ProfileUncheckedUpdateManyWithoutProfilesInput.fromJson(
          Map<String, dynamic> json) =>
      _$ProfileUncheckedUpdateManyWithoutProfilesInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ProfileUncheckedUpdateManyWithoutProfilesInputToJson(this);
}

@_i1.jsonSerializable
class CategoryCreateManyProfileInput implements _i1.JsonSerializable {
  const CategoryCreateManyProfileInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory CategoryCreateManyProfileInput.fromJson(Map<String, dynamic> json) =>
      _$CategoryCreateManyProfileInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$CategoryCreateManyProfileInputToJson(this);
}

@_i1.jsonSerializable
class TagCreateManyProfileInput implements _i1.JsonSerializable {
  const TagCreateManyProfileInput({
    required this.name,
    required this.color,
    required this.icon,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory TagCreateManyProfileInput.fromJson(Map<String, dynamic> json) =>
      _$TagCreateManyProfileInputFromJson(json);

  final String name;

  final String color;

  final String icon;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TagCreateManyProfileInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateManyOwnerInput implements _i1.JsonSerializable {
  const TaskCreateManyOwnerInput({
    required this.uuid,
    required this.title,
    required this.desc,
    required this.content,
    this.location,
    required this.requireLocation,
    required this.requireTime,
    required this.requireAttachment,
    this.parentUuid,
    this.channelUuid,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
  });

  factory TaskCreateManyOwnerInput.fromJson(Map<String, dynamic> json) =>
      _$TaskCreateManyOwnerInputFromJson(json);

  final String uuid;

  final String title;

  final String desc;

  final String content;

  final String? location;

  final bool requireLocation;

  final bool requireTime;

  final bool requireAttachment;

  final String? parentUuid;

  final String? channelUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TaskCreateManyOwnerInputToJson(this);
}

@_i1.jsonSerializable
class ChannelCreateManyOwnerInput implements _i1.JsonSerializable {
  const ChannelCreateManyOwnerInput({
    required this.uuid,
    required this.name,
    required this.desc,
    required this.color,
    this.imgRef,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
  });

  factory ChannelCreateManyOwnerInput.fromJson(Map<String, dynamic> json) =>
      _$ChannelCreateManyOwnerInputFromJson(json);

  final String uuid;

  final String name;

  final String desc;

  final String color;

  final String? imgRef;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$ChannelCreateManyOwnerInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentCreateManyProfileInput implements _i1.JsonSerializable {
  const TaskAssignmentCreateManyProfileInput({
    required this.status,
    required this.priority,
    required this.starred,
    required this.taskUuid,
    this.categoryName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory TaskAssignmentCreateManyProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentCreateManyProfileInputFromJson(json);

  final TaskAssignmentStatus status;

  final TaskPriority priority;

  final bool starred;

  final String taskUuid;

  final String? categoryName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentCreateManyProfileInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionCreateManyProfileInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionCreateManyProfileInput({
    required this.shareRecord,
    required this.channelUuid,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory ChannelSubscriptionCreateManyProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionCreateManyProfileInputFromJson(json);

  final bool shareRecord;

  final String channelUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionCreateManyProfileInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleCreateManyProfileInput implements _i1.JsonSerializable {
  const ScheduleCreateManyProfileInput({
    required this.relStart,
    required this.relEnd,
    required this.sessionUuid,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory ScheduleCreateManyProfileInput.fromJson(Map<String, dynamic> json) =>
      _$ScheduleCreateManyProfileInputFromJson(json);

  final BigInt relStart;

  final BigInt relEnd;

  final String sessionUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$ScheduleCreateManyProfileInputToJson(this);
}

@_i1.jsonSerializable
class RecordCreateManyProfileInput implements _i1.JsonSerializable {
  const RecordCreateManyProfileInput({
    required this.time,
    required this.recordIndex,
    required this.sessionUuid,
    required this.taskUuid,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory RecordCreateManyProfileInput.fromJson(Map<String, dynamic> json) =>
      _$RecordCreateManyProfileInputFromJson(json);

  final BigInt time;

  final int recordIndex;

  final String sessionUuid;

  final String taskUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$RecordCreateManyProfileInputToJson(this);
}

@_i1.jsonSerializable
class CategoryUpdateWithoutProfileInput implements _i1.JsonSerializable {
  const CategoryUpdateWithoutProfileInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.assignments,
  });

  factory CategoryUpdateWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryUpdateWithoutProfileInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskAssignmentUpdateManyWithoutCategoryNestedInput? assignments;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryUpdateWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class CategoryUncheckedUpdateWithoutProfileInput
    implements _i1.JsonSerializable {
  const CategoryUncheckedUpdateWithoutProfileInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.assignments,
  });

  factory CategoryUncheckedUpdateWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryUncheckedUpdateWithoutProfileInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskAssignmentUncheckedUpdateManyWithoutCategoryNestedInput?
      assignments;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryUncheckedUpdateWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class CategoryUncheckedUpdateManyWithoutCategoriesInput
    implements _i1.JsonSerializable {
  const CategoryUncheckedUpdateManyWithoutCategoriesInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory CategoryUncheckedUpdateManyWithoutCategoriesInput.fromJson(
          Map<String, dynamic> json) =>
      _$CategoryUncheckedUpdateManyWithoutCategoriesInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$CategoryUncheckedUpdateManyWithoutCategoriesInputToJson(this);
}

@_i1.jsonSerializable
class TagUpdateWithoutProfileInput implements _i1.JsonSerializable {
  const TagUpdateWithoutProfileInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.assignments,
  });

  factory TagUpdateWithoutProfileInput.fromJson(Map<String, dynamic> json) =>
      _$TagUpdateWithoutProfileInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskAssignmentTagsUpdateManyWithoutTagNestedInput? assignments;

  @override
  Map<String, dynamic> toJson() => _$TagUpdateWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class TagUncheckedUpdateWithoutProfileInput implements _i1.JsonSerializable {
  const TagUncheckedUpdateWithoutProfileInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.assignments,
  });

  factory TagUncheckedUpdateWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$TagUncheckedUpdateWithoutProfileInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskAssignmentTagsUncheckedUpdateManyWithoutTagNestedInput? assignments;

  @override
  Map<String, dynamic> toJson() =>
      _$TagUncheckedUpdateWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class TagUncheckedUpdateManyWithoutTagsInput implements _i1.JsonSerializable {
  const TagUncheckedUpdateManyWithoutTagsInput({
    this.name,
    this.color,
    this.icon,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TagUncheckedUpdateManyWithoutTagsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TagUncheckedUpdateManyWithoutTagsInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? color;

  final StringFieldUpdateOperationsInput? icon;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TagUncheckedUpdateManyWithoutTagsInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpdateWithoutOwnerInput implements _i1.JsonSerializable {
  const TaskUpdateWithoutOwnerInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.parent,
    this.children,
    this.channel,
    this.assets,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskUpdateWithoutOwnerInput.fromJson(Map<String, dynamic> json) =>
      _$TaskUpdateWithoutOwnerInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? title;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? content;

  final NullableStringFieldUpdateOperationsInput? location;

  final BoolFieldUpdateOperationsInput? requireLocation;

  final BoolFieldUpdateOperationsInput? requireTime;

  final BoolFieldUpdateOperationsInput? requireAttachment;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskUpdateOneWithoutChildrenNestedInput? parent;

  final TaskUpdateManyWithoutParentNestedInput? children;

  final ChannelUpdateOneWithoutTasksNestedInput? channel;

  final TaskAssetUpdateManyWithoutTaskNestedInput? assets;

  final TaskAssignmentUpdateManyWithoutTaskNestedInput? assignments;

  final SessionUpdateManyWithoutTaskNestedInput? sessions;

  final RecordUpdateManyWithoutTaskNestedInput? records;

  @override
  Map<String, dynamic> toJson() => _$TaskUpdateWithoutOwnerInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedUpdateWithoutOwnerInput implements _i1.JsonSerializable {
  const TaskUncheckedUpdateWithoutOwnerInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.parentUuid,
    this.channelUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.children,
    this.assets,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskUncheckedUpdateWithoutOwnerInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUncheckedUpdateWithoutOwnerInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? title;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? content;

  final NullableStringFieldUpdateOperationsInput? location;

  final BoolFieldUpdateOperationsInput? requireLocation;

  final BoolFieldUpdateOperationsInput? requireTime;

  final BoolFieldUpdateOperationsInput? requireAttachment;

  final NullableStringFieldUpdateOperationsInput? parentUuid;

  final NullableStringFieldUpdateOperationsInput? channelUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskUncheckedUpdateManyWithoutParentNestedInput? children;

  final TaskAssetUncheckedUpdateManyWithoutTaskNestedInput? assets;

  final TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput? assignments;

  final SessionUncheckedUpdateManyWithoutTaskNestedInput? sessions;

  final RecordUncheckedUpdateManyWithoutTaskNestedInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUncheckedUpdateWithoutOwnerInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedUpdateManyWithoutTasksInput implements _i1.JsonSerializable {
  const TaskUncheckedUpdateManyWithoutTasksInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.parentUuid,
    this.channelUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskUncheckedUpdateManyWithoutTasksInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUncheckedUpdateManyWithoutTasksInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? title;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? content;

  final NullableStringFieldUpdateOperationsInput? location;

  final BoolFieldUpdateOperationsInput? requireLocation;

  final BoolFieldUpdateOperationsInput? requireTime;

  final BoolFieldUpdateOperationsInput? requireAttachment;

  final NullableStringFieldUpdateOperationsInput? parentUuid;

  final NullableStringFieldUpdateOperationsInput? channelUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUncheckedUpdateManyWithoutTasksInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUpdateWithoutOwnerInput implements _i1.JsonSerializable {
  const ChannelUpdateWithoutOwnerInput({
    this.uuid,
    this.name,
    this.desc,
    this.color,
    this.imgRef,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.subscriptions,
    this.tasks,
  });

  factory ChannelUpdateWithoutOwnerInput.fromJson(Map<String, dynamic> json) =>
      _$ChannelUpdateWithoutOwnerInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? color;

  final NullableStringFieldUpdateOperationsInput? imgRef;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ChannelSubscriptionUpdateManyWithoutChannelNestedInput? subscriptions;

  final TaskUpdateManyWithoutChannelNestedInput? tasks;

  @override
  Map<String, dynamic> toJson() => _$ChannelUpdateWithoutOwnerInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUncheckedUpdateWithoutOwnerInput implements _i1.JsonSerializable {
  const ChannelUncheckedUpdateWithoutOwnerInput({
    this.uuid,
    this.name,
    this.desc,
    this.color,
    this.imgRef,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.subscriptions,
    this.tasks,
  });

  factory ChannelUncheckedUpdateWithoutOwnerInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelUncheckedUpdateWithoutOwnerInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? color;

  final NullableStringFieldUpdateOperationsInput? imgRef;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ChannelSubscriptionUncheckedUpdateManyWithoutChannelNestedInput?
      subscriptions;

  final TaskUncheckedUpdateManyWithoutChannelNestedInput? tasks;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelUncheckedUpdateWithoutOwnerInputToJson(this);
}

@_i1.jsonSerializable
class ChannelUncheckedUpdateManyWithoutChannelsInput
    implements _i1.JsonSerializable {
  const ChannelUncheckedUpdateManyWithoutChannelsInput({
    this.uuid,
    this.name,
    this.desc,
    this.color,
    this.imgRef,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelUncheckedUpdateManyWithoutChannelsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelUncheckedUpdateManyWithoutChannelsInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? color;

  final NullableStringFieldUpdateOperationsInput? imgRef;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelUncheckedUpdateManyWithoutChannelsInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUpdateWithoutProfileInput implements _i1.JsonSerializable {
  const TaskAssignmentUpdateWithoutProfileInput({
    this.status,
    this.priority,
    this.starred,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.task,
    this.category,
    this.tags,
  });

  factory TaskAssignmentUpdateWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUpdateWithoutProfileInputFromJson(json);

  final TaskAssignmentStatus? status;

  final TaskPriority? priority;

  final BoolFieldUpdateOperationsInput? starred;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskUpdateOneRequiredWithoutAssignmentsNestedInput? task;

  final CategoryUpdateOneWithoutAssignmentsNestedInput? category;

  final TaskAssignmentTagsUpdateManyWithoutAssignmentNestedInput? tags;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUpdateWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUncheckedUpdateWithoutProfileInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUncheckedUpdateWithoutProfileInput({
    this.status,
    this.priority,
    this.starred,
    this.taskUuid,
    this.categoryName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.tags,
  });

  factory TaskAssignmentUncheckedUpdateWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUncheckedUpdateWithoutProfileInputFromJson(json);

  final TaskAssignmentStatus? status;

  final TaskPriority? priority;

  final BoolFieldUpdateOperationsInput? starred;

  final StringFieldUpdateOperationsInput? taskUuid;

  final NullableStringFieldUpdateOperationsInput? categoryName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskAssignmentTagsUncheckedUpdateManyWithoutAssignmentNestedInput? tags;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUncheckedUpdateWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUncheckedUpdateManyWithoutTaskAssignmentsInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUncheckedUpdateManyWithoutTaskAssignmentsInput({
    this.status,
    this.priority,
    this.starred,
    this.taskUuid,
    this.categoryName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssignmentUncheckedUpdateManyWithoutTaskAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUncheckedUpdateManyWithoutTaskAssignmentsInputFromJson(
          json);

  final TaskAssignmentStatus? status;

  final TaskPriority? priority;

  final BoolFieldUpdateOperationsInput? starred;

  final StringFieldUpdateOperationsInput? taskUuid;

  final NullableStringFieldUpdateOperationsInput? categoryName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUncheckedUpdateManyWithoutTaskAssignmentsInputToJson(
          this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUpdateWithoutProfileInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionUpdateWithoutProfileInput({
    this.shareRecord,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.channel,
  });

  factory ChannelSubscriptionUpdateWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionUpdateWithoutProfileInputFromJson(json);

  final BoolFieldUpdateOperationsInput? shareRecord;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ChannelUpdateOneRequiredWithoutSubscriptionsNestedInput? channel;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionUpdateWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUncheckedUpdateWithoutProfileInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionUncheckedUpdateWithoutProfileInput({
    this.shareRecord,
    this.channelUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelSubscriptionUncheckedUpdateWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionUncheckedUpdateWithoutProfileInputFromJson(json);

  final BoolFieldUpdateOperationsInput? shareRecord;

  final StringFieldUpdateOperationsInput? channelUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionUncheckedUpdateWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUncheckedUpdateManyWithoutChannelSubscriptionsInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionUncheckedUpdateManyWithoutChannelSubscriptionsInput({
    this.shareRecord,
    this.channelUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelSubscriptionUncheckedUpdateManyWithoutChannelSubscriptionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionUncheckedUpdateManyWithoutChannelSubscriptionsInputFromJson(
          json);

  final BoolFieldUpdateOperationsInput? shareRecord;

  final StringFieldUpdateOperationsInput? channelUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionUncheckedUpdateManyWithoutChannelSubscriptionsInputToJson(
          this);
}

@_i1.jsonSerializable
class ScheduleUpdateWithoutProfileInput implements _i1.JsonSerializable {
  const ScheduleUpdateWithoutProfileInput({
    this.relStart,
    this.relEnd,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.session,
  });

  factory ScheduleUpdateWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleUpdateWithoutProfileInputFromJson(json);

  final BigIntFieldUpdateOperationsInput? relStart;

  final BigIntFieldUpdateOperationsInput? relEnd;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final SessionUpdateOneRequiredWithoutSchedulesNestedInput? session;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleUpdateWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleUncheckedUpdateWithoutProfileInput
    implements _i1.JsonSerializable {
  const ScheduleUncheckedUpdateWithoutProfileInput({
    this.relStart,
    this.relEnd,
    this.sessionUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ScheduleUncheckedUpdateWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleUncheckedUpdateWithoutProfileInputFromJson(json);

  final BigIntFieldUpdateOperationsInput? relStart;

  final BigIntFieldUpdateOperationsInput? relEnd;

  final StringFieldUpdateOperationsInput? sessionUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleUncheckedUpdateWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleUncheckedUpdateManyWithoutSchedulesInput
    implements _i1.JsonSerializable {
  const ScheduleUncheckedUpdateManyWithoutSchedulesInput({
    this.relStart,
    this.relEnd,
    this.sessionUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ScheduleUncheckedUpdateManyWithoutSchedulesInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleUncheckedUpdateManyWithoutSchedulesInputFromJson(json);

  final BigIntFieldUpdateOperationsInput? relStart;

  final BigIntFieldUpdateOperationsInput? relEnd;

  final StringFieldUpdateOperationsInput? sessionUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleUncheckedUpdateManyWithoutSchedulesInputToJson(this);
}

@_i1.jsonSerializable
class RecordUpdateWithoutProfileInput implements _i1.JsonSerializable {
  const RecordUpdateWithoutProfileInput({
    this.time,
    this.recordIndex,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.session,
    this.task,
    this.attachment,
  });

  factory RecordUpdateWithoutProfileInput.fromJson(Map<String, dynamic> json) =>
      _$RecordUpdateWithoutProfileInputFromJson(json);

  final BigIntFieldUpdateOperationsInput? time;

  final IntFieldUpdateOperationsInput? recordIndex;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final SessionUpdateOneRequiredWithoutRecordsNestedInput? session;

  final TaskUpdateOneRequiredWithoutRecordsNestedInput? task;

  final RecordAttachmentUpdateOneWithoutRecordNestedInput? attachment;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUpdateWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class RecordUncheckedUpdateWithoutProfileInput implements _i1.JsonSerializable {
  const RecordUncheckedUpdateWithoutProfileInput({
    this.time,
    this.recordIndex,
    this.sessionUuid,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.attachment,
  });

  factory RecordUncheckedUpdateWithoutProfileInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUncheckedUpdateWithoutProfileInputFromJson(json);

  final BigIntFieldUpdateOperationsInput? time;

  final IntFieldUpdateOperationsInput? recordIndex;

  final StringFieldUpdateOperationsInput? sessionUuid;

  final StringFieldUpdateOperationsInput? taskUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final RecordAttachmentUncheckedUpdateOneWithoutRecordNestedInput? attachment;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUncheckedUpdateWithoutProfileInputToJson(this);
}

@_i1.jsonSerializable
class RecordUncheckedUpdateManyWithoutRecordsInput
    implements _i1.JsonSerializable {
  const RecordUncheckedUpdateManyWithoutRecordsInput({
    this.time,
    this.recordIndex,
    this.sessionUuid,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory RecordUncheckedUpdateManyWithoutRecordsInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUncheckedUpdateManyWithoutRecordsInputFromJson(json);

  final BigIntFieldUpdateOperationsInput? time;

  final IntFieldUpdateOperationsInput? recordIndex;

  final StringFieldUpdateOperationsInput? sessionUuid;

  final StringFieldUpdateOperationsInput? taskUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUncheckedUpdateManyWithoutRecordsInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateManyParentInput implements _i1.JsonSerializable {
  const TaskCreateManyParentInput({
    required this.uuid,
    required this.title,
    required this.desc,
    required this.content,
    this.location,
    required this.requireLocation,
    required this.requireTime,
    required this.requireAttachment,
    required this.userId,
    required this.profile,
    this.channelUuid,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
  });

  factory TaskCreateManyParentInput.fromJson(Map<String, dynamic> json) =>
      _$TaskCreateManyParentInputFromJson(json);

  final String uuid;

  final String title;

  final String desc;

  final String content;

  final String? location;

  final bool requireLocation;

  final bool requireTime;

  final bool requireAttachment;

  final int userId;

  final String profile;

  final String? channelUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TaskCreateManyParentInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetCreateManyTaskInput implements _i1.JsonSerializable {
  const TaskAssetCreateManyTaskInput({
    required this.name,
    required this.hash,
    required this.assetRef,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
  });

  factory TaskAssetCreateManyTaskInput.fromJson(Map<String, dynamic> json) =>
      _$TaskAssetCreateManyTaskInputFromJson(json);

  final String name;

  final String hash;

  final String assetRef;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TaskAssetCreateManyTaskInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentCreateManyTaskInput implements _i1.JsonSerializable {
  const TaskAssignmentCreateManyTaskInput({
    required this.status,
    required this.priority,
    required this.starred,
    required this.userId,
    required this.profileName,
    this.categoryName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory TaskAssignmentCreateManyTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentCreateManyTaskInputFromJson(json);

  final TaskAssignmentStatus status;

  final TaskPriority priority;

  final bool starred;

  final int userId;

  final String profileName;

  final String? categoryName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentCreateManyTaskInputToJson(this);
}

@_i1.jsonSerializable
class SessionCreateManyTaskInput implements _i1.JsonSerializable {
  const SessionCreateManyTaskInput({
    required this.uuid,
    required this.start,
    required this.end,
    required this.cycle,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory SessionCreateManyTaskInput.fromJson(Map<String, dynamic> json) =>
      _$SessionCreateManyTaskInputFromJson(json);

  final String uuid;

  final BigInt start;

  final BigInt end;

  final BigInt cycle;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$SessionCreateManyTaskInputToJson(this);
}

@_i1.jsonSerializable
class RecordCreateManyTaskInput implements _i1.JsonSerializable {
  const RecordCreateManyTaskInput({
    required this.time,
    required this.recordIndex,
    required this.sessionUuid,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory RecordCreateManyTaskInput.fromJson(Map<String, dynamic> json) =>
      _$RecordCreateManyTaskInputFromJson(json);

  final BigInt time;

  final int recordIndex;

  final String sessionUuid;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$RecordCreateManyTaskInputToJson(this);
}

@_i1.jsonSerializable
class TaskUpdateWithoutParentInput implements _i1.JsonSerializable {
  const TaskUpdateWithoutParentInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.owner,
    this.children,
    this.channel,
    this.assets,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskUpdateWithoutParentInput.fromJson(Map<String, dynamic> json) =>
      _$TaskUpdateWithoutParentInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? title;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? content;

  final NullableStringFieldUpdateOperationsInput? location;

  final BoolFieldUpdateOperationsInput? requireLocation;

  final BoolFieldUpdateOperationsInput? requireTime;

  final BoolFieldUpdateOperationsInput? requireAttachment;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ProfileUpdateOneRequiredWithoutTasksNestedInput? owner;

  final TaskUpdateManyWithoutParentNestedInput? children;

  final ChannelUpdateOneWithoutTasksNestedInput? channel;

  final TaskAssetUpdateManyWithoutTaskNestedInput? assets;

  final TaskAssignmentUpdateManyWithoutTaskNestedInput? assignments;

  final SessionUpdateManyWithoutTaskNestedInput? sessions;

  final RecordUpdateManyWithoutTaskNestedInput? records;

  @override
  Map<String, dynamic> toJson() => _$TaskUpdateWithoutParentInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedUpdateWithoutParentInput implements _i1.JsonSerializable {
  const TaskUncheckedUpdateWithoutParentInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.userId,
    this.profile,
    this.channelUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.children,
    this.assets,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskUncheckedUpdateWithoutParentInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUncheckedUpdateWithoutParentInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? title;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? content;

  final NullableStringFieldUpdateOperationsInput? location;

  final BoolFieldUpdateOperationsInput? requireLocation;

  final BoolFieldUpdateOperationsInput? requireTime;

  final BoolFieldUpdateOperationsInput? requireAttachment;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profile;

  final NullableStringFieldUpdateOperationsInput? channelUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskUncheckedUpdateManyWithoutParentNestedInput? children;

  final TaskAssetUncheckedUpdateManyWithoutTaskNestedInput? assets;

  final TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput? assignments;

  final SessionUncheckedUpdateManyWithoutTaskNestedInput? sessions;

  final RecordUncheckedUpdateManyWithoutTaskNestedInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUncheckedUpdateWithoutParentInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedUpdateManyWithoutChildrenInput
    implements _i1.JsonSerializable {
  const TaskUncheckedUpdateManyWithoutChildrenInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.userId,
    this.profile,
    this.channelUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskUncheckedUpdateManyWithoutChildrenInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUncheckedUpdateManyWithoutChildrenInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? title;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? content;

  final NullableStringFieldUpdateOperationsInput? location;

  final BoolFieldUpdateOperationsInput? requireLocation;

  final BoolFieldUpdateOperationsInput? requireTime;

  final BoolFieldUpdateOperationsInput? requireAttachment;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profile;

  final NullableStringFieldUpdateOperationsInput? channelUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUncheckedUpdateManyWithoutChildrenInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetUpdateWithoutTaskInput implements _i1.JsonSerializable {
  const TaskAssetUpdateWithoutTaskInput({
    this.name,
    this.hash,
    this.assetRef,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssetUpdateWithoutTaskInput.fromJson(Map<String, dynamic> json) =>
      _$TaskAssetUpdateWithoutTaskInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? hash;

  final StringFieldUpdateOperationsInput? assetRef;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetUpdateWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetUncheckedUpdateWithoutTaskInput implements _i1.JsonSerializable {
  const TaskAssetUncheckedUpdateWithoutTaskInput({
    this.name,
    this.hash,
    this.assetRef,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssetUncheckedUpdateWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssetUncheckedUpdateWithoutTaskInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? hash;

  final StringFieldUpdateOperationsInput? assetRef;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetUncheckedUpdateWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssetUncheckedUpdateManyWithoutAssetsInput
    implements _i1.JsonSerializable {
  const TaskAssetUncheckedUpdateManyWithoutAssetsInput({
    this.name,
    this.hash,
    this.assetRef,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssetUncheckedUpdateManyWithoutAssetsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssetUncheckedUpdateManyWithoutAssetsInputFromJson(json);

  final StringFieldUpdateOperationsInput? name;

  final StringFieldUpdateOperationsInput? hash;

  final StringFieldUpdateOperationsInput? assetRef;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssetUncheckedUpdateManyWithoutAssetsInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUpdateWithoutTaskInput implements _i1.JsonSerializable {
  const TaskAssignmentUpdateWithoutTaskInput({
    this.status,
    this.priority,
    this.starred,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.profile,
    this.category,
    this.tags,
  });

  factory TaskAssignmentUpdateWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUpdateWithoutTaskInputFromJson(json);

  final TaskAssignmentStatus? status;

  final TaskPriority? priority;

  final BoolFieldUpdateOperationsInput? starred;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ProfileUpdateOneRequiredWithoutTaskAssignmentsNestedInput? profile;

  final CategoryUpdateOneWithoutAssignmentsNestedInput? category;

  final TaskAssignmentTagsUpdateManyWithoutAssignmentNestedInput? tags;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUpdateWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUncheckedUpdateWithoutTaskInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUncheckedUpdateWithoutTaskInput({
    this.status,
    this.priority,
    this.starred,
    this.userId,
    this.profileName,
    this.categoryName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.tags,
  });

  factory TaskAssignmentUncheckedUpdateWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUncheckedUpdateWithoutTaskInputFromJson(json);

  final TaskAssignmentStatus? status;

  final TaskPriority? priority;

  final BoolFieldUpdateOperationsInput? starred;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final NullableStringFieldUpdateOperationsInput? categoryName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskAssignmentTagsUncheckedUpdateManyWithoutAssignmentNestedInput? tags;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUncheckedUpdateWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUncheckedUpdateManyWithoutAssignmentsInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUncheckedUpdateManyWithoutAssignmentsInput({
    this.status,
    this.priority,
    this.starred,
    this.userId,
    this.profileName,
    this.categoryName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssignmentUncheckedUpdateManyWithoutAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUncheckedUpdateManyWithoutAssignmentsInputFromJson(json);

  final TaskAssignmentStatus? status;

  final TaskPriority? priority;

  final BoolFieldUpdateOperationsInput? starred;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final NullableStringFieldUpdateOperationsInput? categoryName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUncheckedUpdateManyWithoutAssignmentsInputToJson(this);
}

@_i1.jsonSerializable
class SessionUpdateWithoutTaskInput implements _i1.JsonSerializable {
  const SessionUpdateWithoutTaskInput({
    this.uuid,
    this.start,
    this.end,
    this.cycle,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.schedules,
    this.records,
  });

  factory SessionUpdateWithoutTaskInput.fromJson(Map<String, dynamic> json) =>
      _$SessionUpdateWithoutTaskInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final BigIntFieldUpdateOperationsInput? start;

  final BigIntFieldUpdateOperationsInput? end;

  final BigIntFieldUpdateOperationsInput? cycle;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ScheduleUpdateManyWithoutSessionNestedInput? schedules;

  final RecordUpdateManyWithoutSessionNestedInput? records;

  @override
  Map<String, dynamic> toJson() => _$SessionUpdateWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class SessionUncheckedUpdateWithoutTaskInput implements _i1.JsonSerializable {
  const SessionUncheckedUpdateWithoutTaskInput({
    this.uuid,
    this.start,
    this.end,
    this.cycle,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.schedules,
    this.records,
  });

  factory SessionUncheckedUpdateWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionUncheckedUpdateWithoutTaskInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final BigIntFieldUpdateOperationsInput? start;

  final BigIntFieldUpdateOperationsInput? end;

  final BigIntFieldUpdateOperationsInput? cycle;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ScheduleUncheckedUpdateManyWithoutSessionNestedInput? schedules;

  final RecordUncheckedUpdateManyWithoutSessionNestedInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionUncheckedUpdateWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class SessionUncheckedUpdateManyWithoutSessionsInput
    implements _i1.JsonSerializable {
  const SessionUncheckedUpdateManyWithoutSessionsInput({
    this.uuid,
    this.start,
    this.end,
    this.cycle,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory SessionUncheckedUpdateManyWithoutSessionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$SessionUncheckedUpdateManyWithoutSessionsInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final BigIntFieldUpdateOperationsInput? start;

  final BigIntFieldUpdateOperationsInput? end;

  final BigIntFieldUpdateOperationsInput? cycle;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$SessionUncheckedUpdateManyWithoutSessionsInputToJson(this);
}

@_i1.jsonSerializable
class RecordUpdateWithoutTaskInput implements _i1.JsonSerializable {
  const RecordUpdateWithoutTaskInput({
    this.time,
    this.recordIndex,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.session,
    this.profile,
    this.attachment,
  });

  factory RecordUpdateWithoutTaskInput.fromJson(Map<String, dynamic> json) =>
      _$RecordUpdateWithoutTaskInputFromJson(json);

  final BigIntFieldUpdateOperationsInput? time;

  final IntFieldUpdateOperationsInput? recordIndex;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final SessionUpdateOneRequiredWithoutRecordsNestedInput? session;

  final ProfileUpdateOneRequiredWithoutRecordsNestedInput? profile;

  final RecordAttachmentUpdateOneWithoutRecordNestedInput? attachment;

  @override
  Map<String, dynamic> toJson() => _$RecordUpdateWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class RecordUncheckedUpdateWithoutTaskInput implements _i1.JsonSerializable {
  const RecordUncheckedUpdateWithoutTaskInput({
    this.time,
    this.recordIndex,
    this.sessionUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.attachment,
  });

  factory RecordUncheckedUpdateWithoutTaskInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUncheckedUpdateWithoutTaskInputFromJson(json);

  final BigIntFieldUpdateOperationsInput? time;

  final IntFieldUpdateOperationsInput? recordIndex;

  final StringFieldUpdateOperationsInput? sessionUuid;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final RecordAttachmentUncheckedUpdateOneWithoutRecordNestedInput? attachment;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUncheckedUpdateWithoutTaskInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionCreateManyChannelInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionCreateManyChannelInput({
    required this.shareRecord,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory ChannelSubscriptionCreateManyChannelInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionCreateManyChannelInputFromJson(json);

  final bool shareRecord;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionCreateManyChannelInputToJson(this);
}

@_i1.jsonSerializable
class TaskCreateManyChannelInput implements _i1.JsonSerializable {
  const TaskCreateManyChannelInput({
    required this.uuid,
    required this.title,
    required this.desc,
    required this.content,
    this.location,
    required this.requireLocation,
    required this.requireTime,
    required this.requireAttachment,
    required this.userId,
    required this.profile,
    this.parentUuid,
    required this.updateAt,
    required this.syncAt,
    this.deleteAt,
  });

  factory TaskCreateManyChannelInput.fromJson(Map<String, dynamic> json) =>
      _$TaskCreateManyChannelInputFromJson(json);

  final String uuid;

  final String title;

  final String desc;

  final String content;

  final String? location;

  final bool requireLocation;

  final bool requireTime;

  final bool requireAttachment;

  final int userId;

  final String profile;

  final String? parentUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TaskCreateManyChannelInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUpdateWithoutChannelInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionUpdateWithoutChannelInput({
    this.shareRecord,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.profile,
  });

  factory ChannelSubscriptionUpdateWithoutChannelInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionUpdateWithoutChannelInputFromJson(json);

  final BoolFieldUpdateOperationsInput? shareRecord;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ProfileUpdateOneRequiredWithoutChannelSubscriptionsNestedInput? profile;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionUpdateWithoutChannelInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUncheckedUpdateWithoutChannelInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionUncheckedUpdateWithoutChannelInput({
    this.shareRecord,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelSubscriptionUncheckedUpdateWithoutChannelInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionUncheckedUpdateWithoutChannelInputFromJson(json);

  final BoolFieldUpdateOperationsInput? shareRecord;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionUncheckedUpdateWithoutChannelInputToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionUncheckedUpdateManyWithoutSubscriptionsInput
    implements _i1.JsonSerializable {
  const ChannelSubscriptionUncheckedUpdateManyWithoutSubscriptionsInput({
    this.shareRecord,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelSubscriptionUncheckedUpdateManyWithoutSubscriptionsInput.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionUncheckedUpdateManyWithoutSubscriptionsInputFromJson(
          json);

  final BoolFieldUpdateOperationsInput? shareRecord;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionUncheckedUpdateManyWithoutSubscriptionsInputToJson(
          this);
}

@_i1.jsonSerializable
class TaskUpdateWithoutChannelInput implements _i1.JsonSerializable {
  const TaskUpdateWithoutChannelInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.owner,
    this.parent,
    this.children,
    this.assets,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskUpdateWithoutChannelInput.fromJson(Map<String, dynamic> json) =>
      _$TaskUpdateWithoutChannelInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? title;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? content;

  final NullableStringFieldUpdateOperationsInput? location;

  final BoolFieldUpdateOperationsInput? requireLocation;

  final BoolFieldUpdateOperationsInput? requireTime;

  final BoolFieldUpdateOperationsInput? requireAttachment;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ProfileUpdateOneRequiredWithoutTasksNestedInput? owner;

  final TaskUpdateOneWithoutChildrenNestedInput? parent;

  final TaskUpdateManyWithoutParentNestedInput? children;

  final TaskAssetUpdateManyWithoutTaskNestedInput? assets;

  final TaskAssignmentUpdateManyWithoutTaskNestedInput? assignments;

  final SessionUpdateManyWithoutTaskNestedInput? sessions;

  final RecordUpdateManyWithoutTaskNestedInput? records;

  @override
  Map<String, dynamic> toJson() => _$TaskUpdateWithoutChannelInputToJson(this);
}

@_i1.jsonSerializable
class TaskUncheckedUpdateWithoutChannelInput implements _i1.JsonSerializable {
  const TaskUncheckedUpdateWithoutChannelInput({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.userId,
    this.profile,
    this.parentUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.children,
    this.assets,
    this.assignments,
    this.sessions,
    this.records,
  });

  factory TaskUncheckedUpdateWithoutChannelInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskUncheckedUpdateWithoutChannelInputFromJson(json);

  final StringFieldUpdateOperationsInput? uuid;

  final StringFieldUpdateOperationsInput? title;

  final StringFieldUpdateOperationsInput? desc;

  final StringFieldUpdateOperationsInput? content;

  final NullableStringFieldUpdateOperationsInput? location;

  final BoolFieldUpdateOperationsInput? requireLocation;

  final BoolFieldUpdateOperationsInput? requireTime;

  final BoolFieldUpdateOperationsInput? requireAttachment;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profile;

  final NullableStringFieldUpdateOperationsInput? parentUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskUncheckedUpdateManyWithoutParentNestedInput? children;

  final TaskAssetUncheckedUpdateManyWithoutTaskNestedInput? assets;

  final TaskAssignmentUncheckedUpdateManyWithoutTaskNestedInput? assignments;

  final SessionUncheckedUpdateManyWithoutTaskNestedInput? sessions;

  final RecordUncheckedUpdateManyWithoutTaskNestedInput? records;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskUncheckedUpdateWithoutChannelInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleCreateManySessionInput implements _i1.JsonSerializable {
  const ScheduleCreateManySessionInput({
    required this.relStart,
    required this.relEnd,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory ScheduleCreateManySessionInput.fromJson(Map<String, dynamic> json) =>
      _$ScheduleCreateManySessionInputFromJson(json);

  final BigInt relStart;

  final BigInt relEnd;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$ScheduleCreateManySessionInputToJson(this);
}

@_i1.jsonSerializable
class RecordCreateManySessionInput implements _i1.JsonSerializable {
  const RecordCreateManySessionInput({
    required this.time,
    required this.recordIndex,
    required this.taskUuid,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory RecordCreateManySessionInput.fromJson(Map<String, dynamic> json) =>
      _$RecordCreateManySessionInputFromJson(json);

  final BigInt time;

  final int recordIndex;

  final String taskUuid;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$RecordCreateManySessionInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleUpdateWithoutSessionInput implements _i1.JsonSerializable {
  const ScheduleUpdateWithoutSessionInput({
    this.relStart,
    this.relEnd,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.profile,
  });

  factory ScheduleUpdateWithoutSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleUpdateWithoutSessionInputFromJson(json);

  final BigIntFieldUpdateOperationsInput? relStart;

  final BigIntFieldUpdateOperationsInput? relEnd;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final ProfileUpdateOneRequiredWithoutSchedulesNestedInput? profile;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleUpdateWithoutSessionInputToJson(this);
}

@_i1.jsonSerializable
class ScheduleUncheckedUpdateWithoutSessionInput
    implements _i1.JsonSerializable {
  const ScheduleUncheckedUpdateWithoutSessionInput({
    this.relStart,
    this.relEnd,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ScheduleUncheckedUpdateWithoutSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$ScheduleUncheckedUpdateWithoutSessionInputFromJson(json);

  final BigIntFieldUpdateOperationsInput? relStart;

  final BigIntFieldUpdateOperationsInput? relEnd;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ScheduleUncheckedUpdateWithoutSessionInputToJson(this);
}

@_i1.jsonSerializable
class RecordUpdateWithoutSessionInput implements _i1.JsonSerializable {
  const RecordUpdateWithoutSessionInput({
    this.time,
    this.recordIndex,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.task,
    this.profile,
    this.attachment,
  });

  factory RecordUpdateWithoutSessionInput.fromJson(Map<String, dynamic> json) =>
      _$RecordUpdateWithoutSessionInputFromJson(json);

  final BigIntFieldUpdateOperationsInput? time;

  final IntFieldUpdateOperationsInput? recordIndex;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskUpdateOneRequiredWithoutRecordsNestedInput? task;

  final ProfileUpdateOneRequiredWithoutRecordsNestedInput? profile;

  final RecordAttachmentUpdateOneWithoutRecordNestedInput? attachment;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUpdateWithoutSessionInputToJson(this);
}

@_i1.jsonSerializable
class RecordUncheckedUpdateWithoutSessionInput implements _i1.JsonSerializable {
  const RecordUncheckedUpdateWithoutSessionInput({
    this.time,
    this.recordIndex,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.attachment,
  });

  factory RecordUncheckedUpdateWithoutSessionInput.fromJson(
          Map<String, dynamic> json) =>
      _$RecordUncheckedUpdateWithoutSessionInputFromJson(json);

  final BigIntFieldUpdateOperationsInput? time;

  final IntFieldUpdateOperationsInput? recordIndex;

  final StringFieldUpdateOperationsInput? taskUuid;

  final IntFieldUpdateOperationsInput? userId;

  final StringFieldUpdateOperationsInput? profileName;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final RecordAttachmentUncheckedUpdateOneWithoutRecordNestedInput? attachment;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordUncheckedUpdateWithoutSessionInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentCreateManyCategoryInput implements _i1.JsonSerializable {
  const TaskAssignmentCreateManyCategoryInput({
    required this.status,
    required this.priority,
    required this.starred,
    required this.taskUuid,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory TaskAssignmentCreateManyCategoryInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentCreateManyCategoryInputFromJson(json);

  final TaskAssignmentStatus status;

  final TaskPriority priority;

  final bool starred;

  final String taskUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentCreateManyCategoryInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUpdateWithoutCategoryInput implements _i1.JsonSerializable {
  const TaskAssignmentUpdateWithoutCategoryInput({
    this.status,
    this.priority,
    this.starred,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.task,
    this.profile,
    this.tags,
  });

  factory TaskAssignmentUpdateWithoutCategoryInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUpdateWithoutCategoryInputFromJson(json);

  final TaskAssignmentStatus? status;

  final TaskPriority? priority;

  final BoolFieldUpdateOperationsInput? starred;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskUpdateOneRequiredWithoutAssignmentsNestedInput? task;

  final ProfileUpdateOneRequiredWithoutTaskAssignmentsNestedInput? profile;

  final TaskAssignmentTagsUpdateManyWithoutAssignmentNestedInput? tags;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUpdateWithoutCategoryInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentUncheckedUpdateWithoutCategoryInput
    implements _i1.JsonSerializable {
  const TaskAssignmentUncheckedUpdateWithoutCategoryInput({
    this.status,
    this.priority,
    this.starred,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
    this.tags,
  });

  factory TaskAssignmentUncheckedUpdateWithoutCategoryInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentUncheckedUpdateWithoutCategoryInputFromJson(json);

  final TaskAssignmentStatus? status;

  final TaskPriority? priority;

  final BoolFieldUpdateOperationsInput? starred;

  final StringFieldUpdateOperationsInput? taskUuid;

  final BigIntFieldUpdateOperationsInput? updateAt;

  final BigIntFieldUpdateOperationsInput? syncAt;

  final BigIntFieldUpdateOperationsInput? deleteAt;

  final TaskAssignmentTagsUncheckedUpdateManyWithoutAssignmentNestedInput? tags;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentUncheckedUpdateWithoutCategoryInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsCreateManyTagInput implements _i1.JsonSerializable {
  const TaskAssignmentTagsCreateManyTagInput({required this.taskUuid});

  factory TaskAssignmentTagsCreateManyTagInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsCreateManyTagInputFromJson(json);

  final String taskUuid;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsCreateManyTagInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUpdateWithoutTagInput implements _i1.JsonSerializable {
  const TaskAssignmentTagsUpdateWithoutTagInput({this.assignment});

  factory TaskAssignmentTagsUpdateWithoutTagInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUpdateWithoutTagInputFromJson(json);

  final TaskAssignmentUpdateOneRequiredWithoutTagsNestedInput? assignment;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsUpdateWithoutTagInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUncheckedUpdateWithoutTagInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsUncheckedUpdateWithoutTagInput({this.taskUuid});

  factory TaskAssignmentTagsUncheckedUpdateWithoutTagInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUncheckedUpdateWithoutTagInputFromJson(json);

  final StringFieldUpdateOperationsInput? taskUuid;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsUncheckedUpdateWithoutTagInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUncheckedUpdateManyWithoutAssignmentsInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsUncheckedUpdateManyWithoutAssignmentsInput(
      {this.taskUuid});

  factory TaskAssignmentTagsUncheckedUpdateManyWithoutAssignmentsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUncheckedUpdateManyWithoutAssignmentsInputFromJson(
          json);

  final StringFieldUpdateOperationsInput? taskUuid;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsUncheckedUpdateManyWithoutAssignmentsInputToJson(
          this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsCreateManyAssignmentInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsCreateManyAssignmentInput({required this.tagName});

  factory TaskAssignmentTagsCreateManyAssignmentInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsCreateManyAssignmentInputFromJson(json);

  final String tagName;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsCreateManyAssignmentInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUpdateWithoutAssignmentInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsUpdateWithoutAssignmentInput({this.tag});

  factory TaskAssignmentTagsUpdateWithoutAssignmentInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUpdateWithoutAssignmentInputFromJson(json);

  final TagUpdateOneRequiredWithoutAssignmentsNestedInput? tag;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsUpdateWithoutAssignmentInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUncheckedUpdateWithoutAssignmentInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsUncheckedUpdateWithoutAssignmentInput({this.tagName});

  factory TaskAssignmentTagsUncheckedUpdateWithoutAssignmentInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUncheckedUpdateWithoutAssignmentInputFromJson(json);

  final StringFieldUpdateOperationsInput? tagName;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsUncheckedUpdateWithoutAssignmentInputToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsUncheckedUpdateManyWithoutTagsInput
    implements _i1.JsonSerializable {
  const TaskAssignmentTagsUncheckedUpdateManyWithoutTagsInput({this.tagName});

  factory TaskAssignmentTagsUncheckedUpdateManyWithoutTagsInput.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsUncheckedUpdateManyWithoutTagsInputFromJson(json);

  final StringFieldUpdateOperationsInput? tagName;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsUncheckedUpdateManyWithoutTagsInputToJson(this);
}

@_i1.jsonSerializable
class User implements _i1.JsonSerializable {
  const User({
    required this.id,
    required this.name,
    this.email,
    this.phone,
    required this.password,
    this.avatarRef,
    this.unionId,
    this.tencentId,
    this.appleId,
  });

  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);

  final int id;

  final String name;

  final String? email;

  final String? phone;

  final String password;

  final String? avatarRef;

  final String? unionId;

  final String? tencentId;

  final String? appleId;

  @override
  Map<String, dynamic> toJson() => _$UserToJson(this);
}

@_i1.jsonSerializable
class Profile implements _i1.JsonSerializable {
  const Profile({
    required this.name,
    required this.color,
    required this.icon,
    required this.userId,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory Profile.fromJson(Map<String, dynamic> json) =>
      _$ProfileFromJson(json);

  final String name;

  final String color;

  final String icon;

  final int userId;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$ProfileToJson(this);
}

@_i1.jsonSerializable
class Task implements _i1.JsonSerializable {
  const Task({
    required this.uuid,
    required this.title,
    required this.desc,
    required this.content,
    this.location,
    required this.requireLocation,
    required this.requireTime,
    required this.requireAttachment,
    required this.userId,
    required this.profile,
    this.parentUuid,
    this.channelUuid,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory Task.fromJson(Map<String, dynamic> json) => _$TaskFromJson(json);

  final String uuid;

  final String title;

  final String desc;

  final String content;

  final String? location;

  final bool requireLocation;

  final bool requireTime;

  final bool requireAttachment;

  final int userId;

  final String profile;

  final String? parentUuid;

  final String? channelUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TaskToJson(this);
}

@_i1.jsonSerializable
class TaskAsset implements _i1.JsonSerializable {
  const TaskAsset({
    required this.name,
    required this.hash,
    required this.assetRef,
    required this.taskUuid,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory TaskAsset.fromJson(Map<String, dynamic> json) =>
      _$TaskAssetFromJson(json);

  final String name;

  final String hash;

  final String assetRef;

  final String taskUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TaskAssetToJson(this);
}

@_i1.jsonSerializable
class Channel implements _i1.JsonSerializable {
  const Channel({
    required this.uuid,
    required this.name,
    required this.desc,
    required this.color,
    this.imgRef,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory Channel.fromJson(Map<String, dynamic> json) =>
      _$ChannelFromJson(json);

  final String uuid;

  final String name;

  final String desc;

  final String color;

  final String? imgRef;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$ChannelToJson(this);
}

@_i1.jsonSerializable
class Session implements _i1.JsonSerializable {
  const Session({
    required this.uuid,
    required this.start,
    required this.end,
    required this.cycle,
    required this.taskUuid,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory Session.fromJson(Map<String, dynamic> json) =>
      _$SessionFromJson(json);

  final String uuid;

  final BigInt start;

  final BigInt end;

  final BigInt cycle;

  final String taskUuid;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$SessionToJson(this);
}

@_i1.jsonSerializable
class Record implements _i1.JsonSerializable {
  const Record({
    required this.time,
    required this.recordIndex,
    required this.sessionUuid,
    required this.taskUuid,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory Record.fromJson(Map<String, dynamic> json) => _$RecordFromJson(json);

  final BigInt time;

  final int recordIndex;

  final String sessionUuid;

  final String taskUuid;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$RecordToJson(this);
}

@_i1.jsonSerializable
class RecordAttachment implements _i1.JsonSerializable {
  const RecordAttachment({
    required this.hash,
    required this.name,
    required this.assetRef,
    required this.sessionUuid,
    required this.taskUuid,
    required this.userId,
    required this.profileName,
    required this.recordIndex,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory RecordAttachment.fromJson(Map<String, dynamic> json) =>
      _$RecordAttachmentFromJson(json);

  final String hash;

  final String name;

  final String assetRef;

  final String sessionUuid;

  final String taskUuid;

  final int userId;

  final String profileName;

  final int recordIndex;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$RecordAttachmentToJson(this);
}

@_i1.jsonSerializable
class Category implements _i1.JsonSerializable {
  const Category({
    required this.name,
    required this.color,
    required this.icon,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory Category.fromJson(Map<String, dynamic> json) =>
      _$CategoryFromJson(json);

  final String name;

  final String color;

  final String icon;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$CategoryToJson(this);
}

@_i1.jsonSerializable
class Tag implements _i1.JsonSerializable {
  const Tag({
    required this.name,
    required this.color,
    required this.icon,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory Tag.fromJson(Map<String, dynamic> json) => _$TagFromJson(json);

  final String name;

  final String color;

  final String icon;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TagToJson(this);
}

@_i1.jsonSerializable
class TaskAssignment implements _i1.JsonSerializable {
  const TaskAssignment({
    required this.status,
    required this.priority,
    required this.starred,
    required this.taskUuid,
    required this.userId,
    required this.profileName,
    this.categoryName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory TaskAssignment.fromJson(Map<String, dynamic> json) =>
      _$TaskAssignmentFromJson(json);

  final TaskAssignmentStatus status;

  final TaskPriority priority;

  final bool starred;

  final String taskUuid;

  final int userId;

  final String profileName;

  final String? categoryName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TaskAssignmentToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTags implements _i1.JsonSerializable {
  const TaskAssignmentTags({
    required this.taskUuid,
    required this.userId,
    required this.profileName,
    required this.tagName,
  });

  factory TaskAssignmentTags.fromJson(Map<String, dynamic> json) =>
      _$TaskAssignmentTagsFromJson(json);

  final String taskUuid;

  final int userId;

  final String profileName;

  final String tagName;

  @override
  Map<String, dynamic> toJson() => _$TaskAssignmentTagsToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscription implements _i1.JsonSerializable {
  const ChannelSubscription({
    required this.shareRecord,
    required this.channelUuid,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory ChannelSubscription.fromJson(Map<String, dynamic> json) =>
      _$ChannelSubscriptionFromJson(json);

  final bool shareRecord;

  final String channelUuid;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$ChannelSubscriptionToJson(this);
}

@_i1.jsonSerializable
class Schedule implements _i1.JsonSerializable {
  const Schedule({
    required this.relStart,
    required this.relEnd,
    required this.sessionUuid,
    required this.userId,
    required this.profileName,
    required this.updateAt,
    required this.syncAt,
    required this.deleteAt,
  });

  factory Schedule.fromJson(Map<String, dynamic> json) =>
      _$ScheduleFromJson(json);

  final BigInt relStart;

  final BigInt relEnd;

  final String sessionUuid;

  final int userId;

  final String profileName;

  final BigInt updateAt;

  final BigInt syncAt;

  final BigInt deleteAt;

  @override
  Map<String, dynamic> toJson() => _$ScheduleToJson(this);
}

@_i1.jsonSerializable
class FileRef implements _i1.JsonSerializable {
  const FileRef({
    required this.hash,
    this.count,
  });

  factory FileRef.fromJson(Map<String, dynamic> json) =>
      _$FileRefFromJson(json);

  final String hash;

  final int? count;

  @override
  Map<String, dynamic> toJson() => _$FileRefToJson(this);
}

class UserFluent<T> extends _i1.PrismaFluent<T> {
  const UserFluent(
    super.original,
    super.$query,
  );

  Future<Iterable<Profile>?> profiles({
    ProfileWhereInput? where,
    Iterable<ProfileOrderByWithRelationInput>? orderBy,
    ProfileWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<ProfileScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profiles',
          fields: fields,
          args: args,
        )
      ]),
      key: r'profiles',
    );
    final fields = ProfileScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> profiles) =>
        profiles.map((Map profiles) => Profile.fromJson(profiles.cast()));
    return query(fields)
        .then((json) => json is Iterable ? compiler(json.cast()) : null);
  }

  UserCountOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return UserCountOutputType(query);
  }
}

class ProfileFluent<T> extends _i1.PrismaFluent<T> {
  const ProfileFluent(
    super.original,
    super.$query,
  );

  UserFluent<User> user() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'user',
          fields: fields,
        )
      ]),
      key: r'user',
    );
    final future = query(UserScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? User.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: User)'));
    return UserFluent<User>(
      future,
      query,
    );
  }

  Future<Iterable<Category>?> categories({
    CategoryWhereInput? where,
    Iterable<CategoryOrderByWithRelationInput>? orderBy,
    CategoryWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CategoryScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'categories',
          fields: fields,
          args: args,
        )
      ]),
      key: r'categories',
    );
    final fields = CategoryScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> categories) => categories
        .map((Map categories) => Category.fromJson(categories.cast()));
    return query(fields)
        .then((json) => json is Iterable ? compiler(json.cast()) : null);
  }

  Future<Iterable<Tag>?> tags({
    TagWhereInput? where,
    Iterable<TagOrderByWithRelationInput>? orderBy,
    TagWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TagScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'tags',
          fields: fields,
          args: args,
        )
      ]),
      key: r'tags',
    );
    final fields = TagScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> tags) =>
        tags.map((Map tags) => Tag.fromJson(tags.cast()));
    return query(fields)
        .then((json) => json is Iterable ? compiler(json.cast()) : null);
  }

  Future<Iterable<Task>?> tasks({
    TaskWhereInput? where,
    Iterable<TaskOrderByWithRelationInput>? orderBy,
    TaskWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TaskScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'tasks',
          fields: fields,
          args: args,
        )
      ]),
      key: r'tasks',
    );
    final fields = TaskScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> tasks) =>
        tasks.map((Map tasks) => Task.fromJson(tasks.cast()));
    return query(fields)
        .then((json) => json is Iterable ? compiler(json.cast()) : null);
  }

  Future<Iterable<Channel>?> channels({
    ChannelWhereInput? where,
    Iterable<ChannelOrderByWithRelationInput>? orderBy,
    ChannelWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<ChannelScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'channels',
          fields: fields,
          args: args,
        )
      ]),
      key: r'channels',
    );
    final fields = ChannelScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> channels) =>
        channels.map((Map channels) => Channel.fromJson(channels.cast()));
    return query(fields)
        .then((json) => json is Iterable ? compiler(json.cast()) : null);
  }

  Future<Iterable<TaskAssignment>?> taskAssignments({
    TaskAssignmentWhereInput? where,
    Iterable<TaskAssignmentOrderByWithRelationInput>? orderBy,
    TaskAssignmentWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TaskAssignmentScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'taskAssignments',
          fields: fields,
          args: args,
        )
      ]),
      key: r'taskAssignments',
    );
    final fields = TaskAssignmentScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> taskAssignments) =>
        taskAssignments.map((Map taskAssignments) =>
            TaskAssignment.fromJson(taskAssignments.cast()));
    return query(fields)
        .then((json) => json is Iterable ? compiler(json.cast()) : null);
  }

  Future<Iterable<ChannelSubscription>?> channelSubscriptions({
    ChannelSubscriptionWhereInput? where,
    Iterable<ChannelSubscriptionOrderByWithRelationInput>? orderBy,
    ChannelSubscriptionWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<ChannelSubscriptionScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'channelSubscriptions',
          fields: fields,
          args: args,
        )
      ]),
      key: r'channelSubscriptions',
    );
    final fields = ChannelSubscriptionScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> channelSubscriptions) =>
        channelSubscriptions.map((Map channelSubscriptions) =>
            ChannelSubscription.fromJson(channelSubscriptions.cast()));
    return query(fields)
        .then((json) => json is Iterable ? compiler(json.cast()) : null);
  }

  Future<Iterable<Schedule>?> schedules({
    ScheduleWhereInput? where,
    Iterable<ScheduleOrderByWithRelationInput>? orderBy,
    ScheduleWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<ScheduleScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'schedules',
          fields: fields,
          args: args,
        )
      ]),
      key: r'schedules',
    );
    final fields = ScheduleScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> schedules) =>
        schedules.map((Map schedules) => Schedule.fromJson(schedules.cast()));
    return query(fields)
        .then((json) => json is Iterable ? compiler(json.cast()) : null);
  }

  Future<Iterable<Record>?> records({
    RecordWhereInput? where,
    Iterable<RecordOrderByWithRelationInput>? orderBy,
    RecordWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<RecordScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'records',
          fields: fields,
          args: args,
        )
      ]),
      key: r'records',
    );
    final fields = RecordScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> records) =>
        records.map((Map records) => Record.fromJson(records.cast()));
    return query(fields)
        .then((json) => json is Iterable ? compiler(json.cast()) : null);
  }

  ProfileCountOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return ProfileCountOutputType(query);
  }
}

class TaskFluent<T> extends _i1.PrismaFluent<T> {
  const TaskFluent(
    super.original,
    super.$query,
  );

  ProfileFluent<Profile> owner() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'owner',
          fields: fields,
        )
      ]),
      key: r'owner',
    );
    final future = query(ProfileScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Profile.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Profile)'));
    return ProfileFluent<Profile>(
      future,
      query,
    );
  }

  TaskFluent<Task?> parent() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'parent',
          fields: fields,
        )
      ]),
      key: r'parent',
    );
    final future = query(TaskScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? Task.fromJson(json.cast<String, dynamic>()) : null);
    return TaskFluent<Task?>(
      future,
      query,
    );
  }

  Future<Iterable<Task>?> children({
    TaskWhereInput? where,
    Iterable<TaskOrderByWithRelationInput>? orderBy,
    TaskWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TaskScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'children',
          fields: fields,
          args: args,
        )
      ]),
      key: r'children',
    );
    final fields = TaskScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> children) =>
        children.map((Map children) => Task.fromJson(children.cast()));
    return query(fields)
        .then((json) => json is Iterable ? compiler(json.cast()) : null);
  }

  ChannelFluent<Channel?> channel() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'channel',
          fields: fields,
        )
      ]),
      key: r'channel',
    );
    final future = query(ChannelScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Channel.fromJson(json.cast<String, dynamic>())
            : null);
    return ChannelFluent<Channel?>(
      future,
      query,
    );
  }

  Future<Iterable<TaskAsset>?> assets({
    TaskAssetWhereInput? where,
    Iterable<TaskAssetOrderByWithRelationInput>? orderBy,
    TaskAssetWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TaskAssetScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'assets',
          fields: fields,
          args: args,
        )
      ]),
      key: r'assets',
    );
    final fields = TaskAssetScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> assets) =>
        assets.map((Map assets) => TaskAsset.fromJson(assets.cast()));
    return query(fields)
        .then((json) => json is Iterable ? compiler(json.cast()) : null);
  }

  Future<Iterable<TaskAssignment>?> assignments({
    TaskAssignmentWhereInput? where,
    Iterable<TaskAssignmentOrderByWithRelationInput>? orderBy,
    TaskAssignmentWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TaskAssignmentScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'assignments',
          fields: fields,
          args: args,
        )
      ]),
      key: r'assignments',
    );
    final fields = TaskAssignmentScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> assignments) => assignments
        .map((Map assignments) => TaskAssignment.fromJson(assignments.cast()));
    return query(fields)
        .then((json) => json is Iterable ? compiler(json.cast()) : null);
  }

  Future<Iterable<Session>?> sessions({
    SessionWhereInput? where,
    Iterable<SessionOrderByWithRelationInput>? orderBy,
    SessionWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<SessionScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'sessions',
          fields: fields,
          args: args,
        )
      ]),
      key: r'sessions',
    );
    final fields = SessionScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> sessions) =>
        sessions.map((Map sessions) => Session.fromJson(sessions.cast()));
    return query(fields)
        .then((json) => json is Iterable ? compiler(json.cast()) : null);
  }

  Future<Iterable<Record>?> records({
    RecordWhereInput? where,
    Iterable<RecordOrderByWithRelationInput>? orderBy,
    RecordWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<RecordScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'records',
          fields: fields,
          args: args,
        )
      ]),
      key: r'records',
    );
    final fields = RecordScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> records) =>
        records.map((Map records) => Record.fromJson(records.cast()));
    return query(fields)
        .then((json) => json is Iterable ? compiler(json.cast()) : null);
  }

  TaskCountOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return TaskCountOutputType(query);
  }
}

class TaskAssetFluent<T> extends _i1.PrismaFluent<T> {
  const TaskAssetFluent(
    super.original,
    super.$query,
  );

  TaskFluent<Task> task() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'task',
          fields: fields,
        )
      ]),
      key: r'task',
    );
    final future = query(TaskScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Task.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Task)'));
    return TaskFluent<Task>(
      future,
      query,
    );
  }
}

class ChannelFluent<T> extends _i1.PrismaFluent<T> {
  const ChannelFluent(
    super.original,
    super.$query,
  );

  ProfileFluent<Profile> owner() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'owner',
          fields: fields,
        )
      ]),
      key: r'owner',
    );
    final future = query(ProfileScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Profile.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Profile)'));
    return ProfileFluent<Profile>(
      future,
      query,
    );
  }

  Future<Iterable<ChannelSubscription>?> subscriptions({
    ChannelSubscriptionWhereInput? where,
    Iterable<ChannelSubscriptionOrderByWithRelationInput>? orderBy,
    ChannelSubscriptionWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<ChannelSubscriptionScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'subscriptions',
          fields: fields,
          args: args,
        )
      ]),
      key: r'subscriptions',
    );
    final fields = ChannelSubscriptionScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> subscriptions) =>
        subscriptions.map((Map subscriptions) =>
            ChannelSubscription.fromJson(subscriptions.cast()));
    return query(fields)
        .then((json) => json is Iterable ? compiler(json.cast()) : null);
  }

  Future<Iterable<Task>?> tasks({
    TaskWhereInput? where,
    Iterable<TaskOrderByWithRelationInput>? orderBy,
    TaskWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TaskScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'tasks',
          fields: fields,
          args: args,
        )
      ]),
      key: r'tasks',
    );
    final fields = TaskScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> tasks) =>
        tasks.map((Map tasks) => Task.fromJson(tasks.cast()));
    return query(fields)
        .then((json) => json is Iterable ? compiler(json.cast()) : null);
  }

  ChannelCountOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return ChannelCountOutputType(query);
  }
}

class SessionFluent<T> extends _i1.PrismaFluent<T> {
  const SessionFluent(
    super.original,
    super.$query,
  );

  TaskFluent<Task> task() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'task',
          fields: fields,
        )
      ]),
      key: r'task',
    );
    final future = query(TaskScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Task.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Task)'));
    return TaskFluent<Task>(
      future,
      query,
    );
  }

  Future<Iterable<Schedule>?> schedules({
    ScheduleWhereInput? where,
    Iterable<ScheduleOrderByWithRelationInput>? orderBy,
    ScheduleWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<ScheduleScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'schedules',
          fields: fields,
          args: args,
        )
      ]),
      key: r'schedules',
    );
    final fields = ScheduleScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> schedules) =>
        schedules.map((Map schedules) => Schedule.fromJson(schedules.cast()));
    return query(fields)
        .then((json) => json is Iterable ? compiler(json.cast()) : null);
  }

  Future<Iterable<Record>?> records({
    RecordWhereInput? where,
    Iterable<RecordOrderByWithRelationInput>? orderBy,
    RecordWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<RecordScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'records',
          fields: fields,
          args: args,
        )
      ]),
      key: r'records',
    );
    final fields = RecordScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> records) =>
        records.map((Map records) => Record.fromJson(records.cast()));
    return query(fields)
        .then((json) => json is Iterable ? compiler(json.cast()) : null);
  }

  SessionCountOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return SessionCountOutputType(query);
  }
}

class RecordFluent<T> extends _i1.PrismaFluent<T> {
  const RecordFluent(
    super.original,
    super.$query,
  );

  SessionFluent<Session> session() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'session',
          fields: fields,
        )
      ]),
      key: r'session',
    );
    final future = query(SessionScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Session.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Session)'));
    return SessionFluent<Session>(
      future,
      query,
    );
  }

  TaskFluent<Task> task() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'task',
          fields: fields,
        )
      ]),
      key: r'task',
    );
    final future = query(TaskScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Task.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Task)'));
    return TaskFluent<Task>(
      future,
      query,
    );
  }

  ProfileFluent<Profile> profile() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profile',
          fields: fields,
        )
      ]),
      key: r'profile',
    );
    final future = query(ProfileScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Profile.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Profile)'));
    return ProfileFluent<Profile>(
      future,
      query,
    );
  }

  RecordAttachmentFluent<RecordAttachment?> attachment() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'attachment',
          fields: fields,
        )
      ]),
      key: r'attachment',
    );
    final future =
        query(RecordAttachmentScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? RecordAttachment.fromJson(json.cast<String, dynamic>())
                : null);
    return RecordAttachmentFluent<RecordAttachment?>(
      future,
      query,
    );
  }
}

class RecordAttachmentFluent<T> extends _i1.PrismaFluent<T> {
  const RecordAttachmentFluent(
    super.original,
    super.$query,
  );

  RecordFluent<Record> record() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'record',
          fields: fields,
        )
      ]),
      key: r'record',
    );
    final future = query(RecordScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Record.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Record)'));
    return RecordFluent<Record>(
      future,
      query,
    );
  }
}

class CategoryFluent<T> extends _i1.PrismaFluent<T> {
  const CategoryFluent(
    super.original,
    super.$query,
  );

  ProfileFluent<Profile> profile() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profile',
          fields: fields,
        )
      ]),
      key: r'profile',
    );
    final future = query(ProfileScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Profile.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Profile)'));
    return ProfileFluent<Profile>(
      future,
      query,
    );
  }

  Future<Iterable<TaskAssignment>?> assignments({
    TaskAssignmentWhereInput? where,
    Iterable<TaskAssignmentOrderByWithRelationInput>? orderBy,
    TaskAssignmentWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TaskAssignmentScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'assignments',
          fields: fields,
          args: args,
        )
      ]),
      key: r'assignments',
    );
    final fields = TaskAssignmentScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> assignments) => assignments
        .map((Map assignments) => TaskAssignment.fromJson(assignments.cast()));
    return query(fields)
        .then((json) => json is Iterable ? compiler(json.cast()) : null);
  }

  CategoryCountOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return CategoryCountOutputType(query);
  }
}

class TagFluent<T> extends _i1.PrismaFluent<T> {
  const TagFluent(
    super.original,
    super.$query,
  );

  ProfileFluent<Profile> profile() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profile',
          fields: fields,
        )
      ]),
      key: r'profile',
    );
    final future = query(ProfileScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Profile.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Profile)'));
    return ProfileFluent<Profile>(
      future,
      query,
    );
  }

  Future<Iterable<TaskAssignmentTags>?> assignments({
    TaskAssignmentTagsWhereInput? where,
    Iterable<TaskAssignmentTagsOrderByWithRelationInput>? orderBy,
    TaskAssignmentTagsWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TaskAssignmentTagsScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'assignments',
          fields: fields,
          args: args,
        )
      ]),
      key: r'assignments',
    );
    final fields = TaskAssignmentTagsScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> assignments) => assignments.map(
        (Map assignments) => TaskAssignmentTags.fromJson(assignments.cast()));
    return query(fields)
        .then((json) => json is Iterable ? compiler(json.cast()) : null);
  }

  TagCountOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return TagCountOutputType(query);
  }
}

class TaskAssignmentFluent<T> extends _i1.PrismaFluent<T> {
  const TaskAssignmentFluent(
    super.original,
    super.$query,
  );

  TaskFluent<Task> task() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'task',
          fields: fields,
        )
      ]),
      key: r'task',
    );
    final future = query(TaskScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Task.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Task)'));
    return TaskFluent<Task>(
      future,
      query,
    );
  }

  ProfileFluent<Profile> profile() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profile',
          fields: fields,
        )
      ]),
      key: r'profile',
    );
    final future = query(ProfileScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Profile.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Profile)'));
    return ProfileFluent<Profile>(
      future,
      query,
    );
  }

  CategoryFluent<Category?> category() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'category',
          fields: fields,
        )
      ]),
      key: r'category',
    );
    final future = query(CategoryScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Category.fromJson(json.cast<String, dynamic>())
            : null);
    return CategoryFluent<Category?>(
      future,
      query,
    );
  }

  Future<Iterable<TaskAssignmentTags>?> tags({
    TaskAssignmentTagsWhereInput? where,
    Iterable<TaskAssignmentTagsOrderByWithRelationInput>? orderBy,
    TaskAssignmentTagsWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TaskAssignmentTagsScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'tags',
          fields: fields,
          args: args,
        )
      ]),
      key: r'tags',
    );
    final fields = TaskAssignmentTagsScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> tags) =>
        tags.map((Map tags) => TaskAssignmentTags.fromJson(tags.cast()));
    return query(fields)
        .then((json) => json is Iterable ? compiler(json.cast()) : null);
  }

  TaskAssignmentCountOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return TaskAssignmentCountOutputType(query);
  }
}

class TaskAssignmentTagsFluent<T> extends _i1.PrismaFluent<T> {
  const TaskAssignmentTagsFluent(
    super.original,
    super.$query,
  );

  TaskAssignmentFluent<TaskAssignment> assignment() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'assignment',
          fields: fields,
        )
      ]),
      key: r'assignment',
    );
    final future = query(TaskAssignmentScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? TaskAssignment.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found TypeRefType.string(value: TaskAssignment)'));
    return TaskAssignmentFluent<TaskAssignment>(
      future,
      query,
    );
  }

  TagFluent<Tag> tag() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'tag',
          fields: fields,
        )
      ]),
      key: r'tag',
    );
    final future = query(TagScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Tag.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Tag)'));
    return TagFluent<Tag>(
      future,
      query,
    );
  }
}

class ChannelSubscriptionFluent<T> extends _i1.PrismaFluent<T> {
  const ChannelSubscriptionFluent(
    super.original,
    super.$query,
  );

  ChannelFluent<Channel> channel() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'channel',
          fields: fields,
        )
      ]),
      key: r'channel',
    );
    final future = query(ChannelScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Channel.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Channel)'));
    return ChannelFluent<Channel>(
      future,
      query,
    );
  }

  ProfileFluent<Profile> profile() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profile',
          fields: fields,
        )
      ]),
      key: r'profile',
    );
    final future = query(ProfileScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Profile.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Profile)'));
    return ProfileFluent<Profile>(
      future,
      query,
    );
  }
}

class ScheduleFluent<T> extends _i1.PrismaFluent<T> {
  const ScheduleFluent(
    super.original,
    super.$query,
  );

  SessionFluent<Session> session() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'session',
          fields: fields,
        )
      ]),
      key: r'session',
    );
    final future = query(SessionScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Session.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Session)'));
    return SessionFluent<Session>(
      future,
      query,
    );
  }

  ProfileFluent<Profile> profile() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profile',
          fields: fields,
        )
      ]),
      key: r'profile',
    );
    final future = query(ProfileScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Profile.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Profile)'));
    return ProfileFluent<Profile>(
      future,
      query,
    );
  }
}

class FileRefFluent<T> extends _i1.PrismaFluent<T> {
  const FileRefFluent(
    super.original,
    super.$query,
  );
}

extension UserModelDelegateExtension on _i1.ModelDelegate<User> {
  UserFluent<User?> findUnique({required UserWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueUser',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueUser',
    );
    final future = query(UserScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? User.fromJson(json.cast<String, dynamic>()) : null);
    return UserFluent<User?>(
      future,
      query,
    );
  }

  UserFluent<User> findUniqueOrThrow({required UserWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueUserOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueUserOrThrow',
    );
    final future = query(UserScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? User.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: User)'));
    return UserFluent<User>(
      future,
      query,
    );
  }

  UserFluent<User?> findFirst({
    UserWhereInput? where,
    Iterable<UserOrderByWithRelationInput>? orderBy,
    UserWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<UserScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstUser',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstUser',
    );
    final future = query(UserScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? User.fromJson(json.cast<String, dynamic>()) : null);
    return UserFluent<User?>(
      future,
      query,
    );
  }

  UserFluent<User> findFirstOrThrow({
    UserWhereInput? where,
    Iterable<UserOrderByWithRelationInput>? orderBy,
    UserWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<UserScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstUserOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstUserOrThrow',
    );
    final future = query(UserScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? User.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: User)'));
    return UserFluent<User>(
      future,
      query,
    );
  }

  Future<Iterable<User>> findMany({
    UserWhereInput? where,
    Iterable<UserOrderByWithRelationInput>? orderBy,
    UserWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<UserScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyUser',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyUser',
    );
    final fields = UserScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyUser) => findManyUser
        .map((Map findManyUser) => User.fromJson(findManyUser.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  UserFluent<User> create({required UserCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneUser',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneUser',
    );
    final future = query(UserScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? User.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: User)'));
    return UserFluent<User>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<UserCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyUser',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyUser',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyUser) =>
        AffectedRowsOutput.fromJson(createManyUser.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  UserFluent<User?> update({
    required UserUpdateInput data,
    required UserWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneUser',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneUser',
    );
    final future = query(UserScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? User.fromJson(json.cast<String, dynamic>()) : null);
    return UserFluent<User?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required UserUpdateManyMutationInput data,
    UserWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyUser',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyUser',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyUser) =>
        AffectedRowsOutput.fromJson(updateManyUser.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  UserFluent<User> upsert({
    required UserWhereUniqueInput where,
    required UserCreateInput create,
    required UserUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneUser',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneUser',
    );
    final future = query(UserScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? User.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: User)'));
    return UserFluent<User>(
      future,
      query,
    );
  }

  UserFluent<User?> delete({required UserWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneUser',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneUser',
    );
    final future = query(UserScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? User.fromJson(json.cast<String, dynamic>()) : null);
    return UserFluent<User?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({UserWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyUser',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyUser',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyUser) =>
        AffectedRowsOutput.fromJson(deleteManyUser.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateUser aggregate({
    UserWhereInput? where,
    Iterable<UserOrderByWithRelationInput>? orderBy,
    UserWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateUser',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateUser',
    );
    return AggregateUser(query);
  }

  Future<Iterable<UserGroupByOutputType>> groupBy({
    UserWhereInput? where,
    Iterable<UserOrderByWithAggregationInput>? orderBy,
    required Iterable<UserScalarFieldEnum> by,
    UserScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByUser',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByUser',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByUser) => groupByUser.map((Map groupByUser) =>
        UserGroupByOutputType.fromJson(groupByUser.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension ProfileModelDelegateExtension on _i1.ModelDelegate<Profile> {
  ProfileFluent<Profile?> findUnique({required ProfileWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueProfile',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueProfile',
    );
    final future = query(ProfileScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Profile.fromJson(json.cast<String, dynamic>())
            : null);
    return ProfileFluent<Profile?>(
      future,
      query,
    );
  }

  ProfileFluent<Profile> findUniqueOrThrow(
      {required ProfileWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueProfileOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueProfileOrThrow',
    );
    final future = query(ProfileScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Profile.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Profile)'));
    return ProfileFluent<Profile>(
      future,
      query,
    );
  }

  ProfileFluent<Profile?> findFirst({
    ProfileWhereInput? where,
    Iterable<ProfileOrderByWithRelationInput>? orderBy,
    ProfileWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<ProfileScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstProfile',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstProfile',
    );
    final future = query(ProfileScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Profile.fromJson(json.cast<String, dynamic>())
            : null);
    return ProfileFluent<Profile?>(
      future,
      query,
    );
  }

  ProfileFluent<Profile> findFirstOrThrow({
    ProfileWhereInput? where,
    Iterable<ProfileOrderByWithRelationInput>? orderBy,
    ProfileWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<ProfileScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstProfileOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstProfileOrThrow',
    );
    final future = query(ProfileScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Profile.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Profile)'));
    return ProfileFluent<Profile>(
      future,
      query,
    );
  }

  Future<Iterable<Profile>> findMany({
    ProfileWhereInput? where,
    Iterable<ProfileOrderByWithRelationInput>? orderBy,
    ProfileWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<ProfileScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyProfile',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyProfile',
    );
    final fields = ProfileScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyProfile) => findManyProfile
        .map((Map findManyProfile) => Profile.fromJson(findManyProfile.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  ProfileFluent<Profile> create({required ProfileCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneProfile',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneProfile',
    );
    final future = query(ProfileScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Profile.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Profile)'));
    return ProfileFluent<Profile>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<ProfileCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyProfile',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyProfile',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyProfile) =>
        AffectedRowsOutput.fromJson(createManyProfile.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  ProfileFluent<Profile?> update({
    required ProfileUpdateInput data,
    required ProfileWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneProfile',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneProfile',
    );
    final future = query(ProfileScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Profile.fromJson(json.cast<String, dynamic>())
            : null);
    return ProfileFluent<Profile?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required ProfileUpdateManyMutationInput data,
    ProfileWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyProfile',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyProfile',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyProfile) =>
        AffectedRowsOutput.fromJson(updateManyProfile.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  ProfileFluent<Profile> upsert({
    required ProfileWhereUniqueInput where,
    required ProfileCreateInput create,
    required ProfileUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneProfile',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneProfile',
    );
    final future = query(ProfileScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Profile.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Profile)'));
    return ProfileFluent<Profile>(
      future,
      query,
    );
  }

  ProfileFluent<Profile?> delete({required ProfileWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneProfile',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneProfile',
    );
    final future = query(ProfileScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Profile.fromJson(json.cast<String, dynamic>())
            : null);
    return ProfileFluent<Profile?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({ProfileWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyProfile',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyProfile',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyProfile) =>
        AffectedRowsOutput.fromJson(deleteManyProfile.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateProfile aggregate({
    ProfileWhereInput? where,
    Iterable<ProfileOrderByWithRelationInput>? orderBy,
    ProfileWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateProfile',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateProfile',
    );
    return AggregateProfile(query);
  }

  Future<Iterable<ProfileGroupByOutputType>> groupBy({
    ProfileWhereInput? where,
    Iterable<ProfileOrderByWithAggregationInput>? orderBy,
    required Iterable<ProfileScalarFieldEnum> by,
    ProfileScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByProfile',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByProfile',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByProfile) =>
        groupByProfile.map((Map groupByProfile) =>
            ProfileGroupByOutputType.fromJson(groupByProfile.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension TaskModelDelegateExtension on _i1.ModelDelegate<Task> {
  TaskFluent<Task?> findUnique({required TaskWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueTask',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueTask',
    );
    final future = query(TaskScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? Task.fromJson(json.cast<String, dynamic>()) : null);
    return TaskFluent<Task?>(
      future,
      query,
    );
  }

  TaskFluent<Task> findUniqueOrThrow({required TaskWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueTaskOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueTaskOrThrow',
    );
    final future = query(TaskScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Task.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Task)'));
    return TaskFluent<Task>(
      future,
      query,
    );
  }

  TaskFluent<Task?> findFirst({
    TaskWhereInput? where,
    Iterable<TaskOrderByWithRelationInput>? orderBy,
    TaskWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TaskScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstTask',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstTask',
    );
    final future = query(TaskScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? Task.fromJson(json.cast<String, dynamic>()) : null);
    return TaskFluent<Task?>(
      future,
      query,
    );
  }

  TaskFluent<Task> findFirstOrThrow({
    TaskWhereInput? where,
    Iterable<TaskOrderByWithRelationInput>? orderBy,
    TaskWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TaskScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstTaskOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstTaskOrThrow',
    );
    final future = query(TaskScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Task.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Task)'));
    return TaskFluent<Task>(
      future,
      query,
    );
  }

  Future<Iterable<Task>> findMany({
    TaskWhereInput? where,
    Iterable<TaskOrderByWithRelationInput>? orderBy,
    TaskWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TaskScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyTask',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyTask',
    );
    final fields = TaskScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyTask) => findManyTask
        .map((Map findManyTask) => Task.fromJson(findManyTask.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  TaskFluent<Task> create({required TaskCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneTask',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneTask',
    );
    final future = query(TaskScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Task.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Task)'));
    return TaskFluent<Task>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<TaskCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyTask',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyTask',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyTask) =>
        AffectedRowsOutput.fromJson(createManyTask.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  TaskFluent<Task?> update({
    required TaskUpdateInput data,
    required TaskWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneTask',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneTask',
    );
    final future = query(TaskScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? Task.fromJson(json.cast<String, dynamic>()) : null);
    return TaskFluent<Task?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required TaskUpdateManyMutationInput data,
    TaskWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyTask',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyTask',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyTask) =>
        AffectedRowsOutput.fromJson(updateManyTask.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  TaskFluent<Task> upsert({
    required TaskWhereUniqueInput where,
    required TaskCreateInput create,
    required TaskUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneTask',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneTask',
    );
    final future = query(TaskScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Task.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Task)'));
    return TaskFluent<Task>(
      future,
      query,
    );
  }

  TaskFluent<Task?> delete({required TaskWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneTask',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneTask',
    );
    final future = query(TaskScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? Task.fromJson(json.cast<String, dynamic>()) : null);
    return TaskFluent<Task?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({TaskWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyTask',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyTask',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyTask) =>
        AffectedRowsOutput.fromJson(deleteManyTask.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateTask aggregate({
    TaskWhereInput? where,
    Iterable<TaskOrderByWithRelationInput>? orderBy,
    TaskWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateTask',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateTask',
    );
    return AggregateTask(query);
  }

  Future<Iterable<TaskGroupByOutputType>> groupBy({
    TaskWhereInput? where,
    Iterable<TaskOrderByWithAggregationInput>? orderBy,
    required Iterable<TaskScalarFieldEnum> by,
    TaskScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByTask',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByTask',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByTask) => groupByTask.map((Map groupByTask) =>
        TaskGroupByOutputType.fromJson(groupByTask.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension TaskAssetModelDelegateExtension on _i1.ModelDelegate<TaskAsset> {
  TaskAssetFluent<TaskAsset?> findUnique(
      {required TaskAssetWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueTaskAsset',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueTaskAsset',
    );
    final future = query(TaskAssetScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? TaskAsset.fromJson(json.cast<String, dynamic>())
            : null);
    return TaskAssetFluent<TaskAsset?>(
      future,
      query,
    );
  }

  TaskAssetFluent<TaskAsset> findUniqueOrThrow(
      {required TaskAssetWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueTaskAssetOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueTaskAssetOrThrow',
    );
    final future = query(TaskAssetScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? TaskAsset.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found TypeRefType.string(value: TaskAsset)'));
    return TaskAssetFluent<TaskAsset>(
      future,
      query,
    );
  }

  TaskAssetFluent<TaskAsset?> findFirst({
    TaskAssetWhereInput? where,
    Iterable<TaskAssetOrderByWithRelationInput>? orderBy,
    TaskAssetWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TaskAssetScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstTaskAsset',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstTaskAsset',
    );
    final future = query(TaskAssetScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? TaskAsset.fromJson(json.cast<String, dynamic>())
            : null);
    return TaskAssetFluent<TaskAsset?>(
      future,
      query,
    );
  }

  TaskAssetFluent<TaskAsset> findFirstOrThrow({
    TaskAssetWhereInput? where,
    Iterable<TaskAssetOrderByWithRelationInput>? orderBy,
    TaskAssetWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TaskAssetScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstTaskAssetOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstTaskAssetOrThrow',
    );
    final future = query(TaskAssetScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? TaskAsset.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found TypeRefType.string(value: TaskAsset)'));
    return TaskAssetFluent<TaskAsset>(
      future,
      query,
    );
  }

  Future<Iterable<TaskAsset>> findMany({
    TaskAssetWhereInput? where,
    Iterable<TaskAssetOrderByWithRelationInput>? orderBy,
    TaskAssetWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TaskAssetScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyTaskAsset',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyTaskAsset',
    );
    final fields = TaskAssetScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyTaskAsset) =>
        findManyTaskAsset.map((Map findManyTaskAsset) =>
            TaskAsset.fromJson(findManyTaskAsset.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  TaskAssetFluent<TaskAsset> create({required TaskAssetCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneTaskAsset',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneTaskAsset',
    );
    final future = query(TaskAssetScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? TaskAsset.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found TypeRefType.string(value: TaskAsset)'));
    return TaskAssetFluent<TaskAsset>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<TaskAssetCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyTaskAsset',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyTaskAsset',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyTaskAsset) =>
        AffectedRowsOutput.fromJson(createManyTaskAsset.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  TaskAssetFluent<TaskAsset?> update({
    required TaskAssetUpdateInput data,
    required TaskAssetWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneTaskAsset',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneTaskAsset',
    );
    final future = query(TaskAssetScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? TaskAsset.fromJson(json.cast<String, dynamic>())
            : null);
    return TaskAssetFluent<TaskAsset?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required TaskAssetUpdateManyMutationInput data,
    TaskAssetWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyTaskAsset',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyTaskAsset',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyTaskAsset) =>
        AffectedRowsOutput.fromJson(updateManyTaskAsset.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  TaskAssetFluent<TaskAsset> upsert({
    required TaskAssetWhereUniqueInput where,
    required TaskAssetCreateInput create,
    required TaskAssetUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneTaskAsset',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneTaskAsset',
    );
    final future = query(TaskAssetScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? TaskAsset.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found TypeRefType.string(value: TaskAsset)'));
    return TaskAssetFluent<TaskAsset>(
      future,
      query,
    );
  }

  TaskAssetFluent<TaskAsset?> delete(
      {required TaskAssetWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneTaskAsset',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneTaskAsset',
    );
    final future = query(TaskAssetScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? TaskAsset.fromJson(json.cast<String, dynamic>())
            : null);
    return TaskAssetFluent<TaskAsset?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({TaskAssetWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyTaskAsset',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyTaskAsset',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyTaskAsset) =>
        AffectedRowsOutput.fromJson(deleteManyTaskAsset.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateTaskAsset aggregate({
    TaskAssetWhereInput? where,
    Iterable<TaskAssetOrderByWithRelationInput>? orderBy,
    TaskAssetWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateTaskAsset',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateTaskAsset',
    );
    return AggregateTaskAsset(query);
  }

  Future<Iterable<TaskAssetGroupByOutputType>> groupBy({
    TaskAssetWhereInput? where,
    Iterable<TaskAssetOrderByWithAggregationInput>? orderBy,
    required Iterable<TaskAssetScalarFieldEnum> by,
    TaskAssetScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByTaskAsset',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByTaskAsset',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByTaskAsset) =>
        groupByTaskAsset.map((Map groupByTaskAsset) =>
            TaskAssetGroupByOutputType.fromJson(groupByTaskAsset.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension ChannelModelDelegateExtension on _i1.ModelDelegate<Channel> {
  ChannelFluent<Channel?> findUnique({required ChannelWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueChannel',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueChannel',
    );
    final future = query(ChannelScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Channel.fromJson(json.cast<String, dynamic>())
            : null);
    return ChannelFluent<Channel?>(
      future,
      query,
    );
  }

  ChannelFluent<Channel> findUniqueOrThrow(
      {required ChannelWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueChannelOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueChannelOrThrow',
    );
    final future = query(ChannelScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Channel.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Channel)'));
    return ChannelFluent<Channel>(
      future,
      query,
    );
  }

  ChannelFluent<Channel?> findFirst({
    ChannelWhereInput? where,
    Iterable<ChannelOrderByWithRelationInput>? orderBy,
    ChannelWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<ChannelScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstChannel',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstChannel',
    );
    final future = query(ChannelScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Channel.fromJson(json.cast<String, dynamic>())
            : null);
    return ChannelFluent<Channel?>(
      future,
      query,
    );
  }

  ChannelFluent<Channel> findFirstOrThrow({
    ChannelWhereInput? where,
    Iterable<ChannelOrderByWithRelationInput>? orderBy,
    ChannelWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<ChannelScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstChannelOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstChannelOrThrow',
    );
    final future = query(ChannelScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Channel.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Channel)'));
    return ChannelFluent<Channel>(
      future,
      query,
    );
  }

  Future<Iterable<Channel>> findMany({
    ChannelWhereInput? where,
    Iterable<ChannelOrderByWithRelationInput>? orderBy,
    ChannelWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<ChannelScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyChannel',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyChannel',
    );
    final fields = ChannelScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyChannel) => findManyChannel
        .map((Map findManyChannel) => Channel.fromJson(findManyChannel.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  ChannelFluent<Channel> create({required ChannelCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneChannel',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneChannel',
    );
    final future = query(ChannelScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Channel.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Channel)'));
    return ChannelFluent<Channel>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<ChannelCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyChannel',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyChannel',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyChannel) =>
        AffectedRowsOutput.fromJson(createManyChannel.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  ChannelFluent<Channel?> update({
    required ChannelUpdateInput data,
    required ChannelWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneChannel',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneChannel',
    );
    final future = query(ChannelScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Channel.fromJson(json.cast<String, dynamic>())
            : null);
    return ChannelFluent<Channel?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required ChannelUpdateManyMutationInput data,
    ChannelWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyChannel',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyChannel',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyChannel) =>
        AffectedRowsOutput.fromJson(updateManyChannel.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  ChannelFluent<Channel> upsert({
    required ChannelWhereUniqueInput where,
    required ChannelCreateInput create,
    required ChannelUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneChannel',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneChannel',
    );
    final future = query(ChannelScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Channel.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Channel)'));
    return ChannelFluent<Channel>(
      future,
      query,
    );
  }

  ChannelFluent<Channel?> delete({required ChannelWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneChannel',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneChannel',
    );
    final future = query(ChannelScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Channel.fromJson(json.cast<String, dynamic>())
            : null);
    return ChannelFluent<Channel?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({ChannelWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyChannel',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyChannel',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyChannel) =>
        AffectedRowsOutput.fromJson(deleteManyChannel.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateChannel aggregate({
    ChannelWhereInput? where,
    Iterable<ChannelOrderByWithRelationInput>? orderBy,
    ChannelWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateChannel',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateChannel',
    );
    return AggregateChannel(query);
  }

  Future<Iterable<ChannelGroupByOutputType>> groupBy({
    ChannelWhereInput? where,
    Iterable<ChannelOrderByWithAggregationInput>? orderBy,
    required Iterable<ChannelScalarFieldEnum> by,
    ChannelScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByChannel',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByChannel',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByChannel) =>
        groupByChannel.map((Map groupByChannel) =>
            ChannelGroupByOutputType.fromJson(groupByChannel.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension SessionModelDelegateExtension on _i1.ModelDelegate<Session> {
  SessionFluent<Session?> findUnique({required SessionWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueSession',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueSession',
    );
    final future = query(SessionScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Session.fromJson(json.cast<String, dynamic>())
            : null);
    return SessionFluent<Session?>(
      future,
      query,
    );
  }

  SessionFluent<Session> findUniqueOrThrow(
      {required SessionWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueSessionOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueSessionOrThrow',
    );
    final future = query(SessionScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Session.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Session)'));
    return SessionFluent<Session>(
      future,
      query,
    );
  }

  SessionFluent<Session?> findFirst({
    SessionWhereInput? where,
    Iterable<SessionOrderByWithRelationInput>? orderBy,
    SessionWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<SessionScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstSession',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstSession',
    );
    final future = query(SessionScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Session.fromJson(json.cast<String, dynamic>())
            : null);
    return SessionFluent<Session?>(
      future,
      query,
    );
  }

  SessionFluent<Session> findFirstOrThrow({
    SessionWhereInput? where,
    Iterable<SessionOrderByWithRelationInput>? orderBy,
    SessionWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<SessionScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstSessionOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstSessionOrThrow',
    );
    final future = query(SessionScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Session.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Session)'));
    return SessionFluent<Session>(
      future,
      query,
    );
  }

  Future<Iterable<Session>> findMany({
    SessionWhereInput? where,
    Iterable<SessionOrderByWithRelationInput>? orderBy,
    SessionWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<SessionScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManySession',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManySession',
    );
    final fields = SessionScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySession) => findManySession
        .map((Map findManySession) => Session.fromJson(findManySession.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  SessionFluent<Session> create({required SessionCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneSession',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneSession',
    );
    final future = query(SessionScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Session.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Session)'));
    return SessionFluent<Session>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<SessionCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManySession',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManySession',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySession) =>
        AffectedRowsOutput.fromJson(createManySession.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  SessionFluent<Session?> update({
    required SessionUpdateInput data,
    required SessionWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneSession',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneSession',
    );
    final future = query(SessionScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Session.fromJson(json.cast<String, dynamic>())
            : null);
    return SessionFluent<Session?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required SessionUpdateManyMutationInput data,
    SessionWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManySession',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManySession',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySession) =>
        AffectedRowsOutput.fromJson(updateManySession.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  SessionFluent<Session> upsert({
    required SessionWhereUniqueInput where,
    required SessionCreateInput create,
    required SessionUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneSession',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneSession',
    );
    final future = query(SessionScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Session.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Session)'));
    return SessionFluent<Session>(
      future,
      query,
    );
  }

  SessionFluent<Session?> delete({required SessionWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneSession',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneSession',
    );
    final future = query(SessionScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Session.fromJson(json.cast<String, dynamic>())
            : null);
    return SessionFluent<Session?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({SessionWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManySession',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManySession',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySession) =>
        AffectedRowsOutput.fromJson(deleteManySession.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSession aggregate({
    SessionWhereInput? where,
    Iterable<SessionOrderByWithRelationInput>? orderBy,
    SessionWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateSession',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateSession',
    );
    return AggregateSession(query);
  }

  Future<Iterable<SessionGroupByOutputType>> groupBy({
    SessionWhereInput? where,
    Iterable<SessionOrderByWithAggregationInput>? orderBy,
    required Iterable<SessionScalarFieldEnum> by,
    SessionScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupBySession',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupBySession',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySession) =>
        groupBySession.map((Map groupBySession) =>
            SessionGroupByOutputType.fromJson(groupBySession.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension RecordModelDelegateExtension on _i1.ModelDelegate<Record> {
  RecordFluent<Record?> findUnique({required RecordWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueRecord',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueRecord',
    );
    final future = query(RecordScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? Record.fromJson(json.cast<String, dynamic>()) : null);
    return RecordFluent<Record?>(
      future,
      query,
    );
  }

  RecordFluent<Record> findUniqueOrThrow(
      {required RecordWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueRecordOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueRecordOrThrow',
    );
    final future = query(RecordScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Record.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Record)'));
    return RecordFluent<Record>(
      future,
      query,
    );
  }

  RecordFluent<Record?> findFirst({
    RecordWhereInput? where,
    Iterable<RecordOrderByWithRelationInput>? orderBy,
    RecordWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<RecordScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstRecord',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstRecord',
    );
    final future = query(RecordScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? Record.fromJson(json.cast<String, dynamic>()) : null);
    return RecordFluent<Record?>(
      future,
      query,
    );
  }

  RecordFluent<Record> findFirstOrThrow({
    RecordWhereInput? where,
    Iterable<RecordOrderByWithRelationInput>? orderBy,
    RecordWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<RecordScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstRecordOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstRecordOrThrow',
    );
    final future = query(RecordScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Record.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Record)'));
    return RecordFluent<Record>(
      future,
      query,
    );
  }

  Future<Iterable<Record>> findMany({
    RecordWhereInput? where,
    Iterable<RecordOrderByWithRelationInput>? orderBy,
    RecordWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<RecordScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyRecord',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyRecord',
    );
    final fields = RecordScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyRecord) => findManyRecord
        .map((Map findManyRecord) => Record.fromJson(findManyRecord.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  RecordFluent<Record> create({required RecordCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneRecord',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneRecord',
    );
    final future = query(RecordScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Record.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Record)'));
    return RecordFluent<Record>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<RecordCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyRecord',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyRecord',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyRecord) =>
        AffectedRowsOutput.fromJson(createManyRecord.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  RecordFluent<Record?> update({
    required RecordUpdateInput data,
    required RecordWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneRecord',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneRecord',
    );
    final future = query(RecordScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? Record.fromJson(json.cast<String, dynamic>()) : null);
    return RecordFluent<Record?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required RecordUpdateManyMutationInput data,
    RecordWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyRecord',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyRecord',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyRecord) =>
        AffectedRowsOutput.fromJson(updateManyRecord.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  RecordFluent<Record> upsert({
    required RecordWhereUniqueInput where,
    required RecordCreateInput create,
    required RecordUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneRecord',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneRecord',
    );
    final future = query(RecordScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Record.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Record)'));
    return RecordFluent<Record>(
      future,
      query,
    );
  }

  RecordFluent<Record?> delete({required RecordWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneRecord',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneRecord',
    );
    final future = query(RecordScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? Record.fromJson(json.cast<String, dynamic>()) : null);
    return RecordFluent<Record?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({RecordWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyRecord',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyRecord',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyRecord) =>
        AffectedRowsOutput.fromJson(deleteManyRecord.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateRecord aggregate({
    RecordWhereInput? where,
    Iterable<RecordOrderByWithRelationInput>? orderBy,
    RecordWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateRecord',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateRecord',
    );
    return AggregateRecord(query);
  }

  Future<Iterable<RecordGroupByOutputType>> groupBy({
    RecordWhereInput? where,
    Iterable<RecordOrderByWithAggregationInput>? orderBy,
    required Iterable<RecordScalarFieldEnum> by,
    RecordScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByRecord',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByRecord',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByRecord) =>
        groupByRecord.map((Map groupByRecord) =>
            RecordGroupByOutputType.fromJson(groupByRecord.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension RecordAttachmentModelDelegateExtension
    on _i1.ModelDelegate<RecordAttachment> {
  RecordAttachmentFluent<RecordAttachment?> findUnique(
      {required RecordAttachmentWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueRecordAttachment',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueRecordAttachment',
    );
    final future =
        query(RecordAttachmentScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? RecordAttachment.fromJson(json.cast<String, dynamic>())
                : null);
    return RecordAttachmentFluent<RecordAttachment?>(
      future,
      query,
    );
  }

  RecordAttachmentFluent<RecordAttachment> findUniqueOrThrow(
      {required RecordAttachmentWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueRecordAttachmentOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueRecordAttachmentOrThrow',
    );
    final future =
        query(RecordAttachmentScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? RecordAttachment.fromJson(json.cast<String, dynamic>())
                : throw Exception(
                    'Not found TypeRefType.string(value: RecordAttachment)'));
    return RecordAttachmentFluent<RecordAttachment>(
      future,
      query,
    );
  }

  RecordAttachmentFluent<RecordAttachment?> findFirst({
    RecordAttachmentWhereInput? where,
    Iterable<RecordAttachmentOrderByWithRelationInput>? orderBy,
    RecordAttachmentWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<RecordAttachmentScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstRecordAttachment',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstRecordAttachment',
    );
    final future =
        query(RecordAttachmentScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? RecordAttachment.fromJson(json.cast<String, dynamic>())
                : null);
    return RecordAttachmentFluent<RecordAttachment?>(
      future,
      query,
    );
  }

  RecordAttachmentFluent<RecordAttachment> findFirstOrThrow({
    RecordAttachmentWhereInput? where,
    Iterable<RecordAttachmentOrderByWithRelationInput>? orderBy,
    RecordAttachmentWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<RecordAttachmentScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstRecordAttachmentOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstRecordAttachmentOrThrow',
    );
    final future =
        query(RecordAttachmentScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? RecordAttachment.fromJson(json.cast<String, dynamic>())
                : throw Exception(
                    'Not found TypeRefType.string(value: RecordAttachment)'));
    return RecordAttachmentFluent<RecordAttachment>(
      future,
      query,
    );
  }

  Future<Iterable<RecordAttachment>> findMany({
    RecordAttachmentWhereInput? where,
    Iterable<RecordAttachmentOrderByWithRelationInput>? orderBy,
    RecordAttachmentWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<RecordAttachmentScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyRecordAttachment',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyRecordAttachment',
    );
    final fields = RecordAttachmentScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyRecordAttachment) =>
        findManyRecordAttachment.map((Map findManyRecordAttachment) =>
            RecordAttachment.fromJson(findManyRecordAttachment.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  RecordAttachmentFluent<RecordAttachment> create(
      {required RecordAttachmentCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneRecordAttachment',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneRecordAttachment',
    );
    final future =
        query(RecordAttachmentScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? RecordAttachment.fromJson(json.cast<String, dynamic>())
                : throw Exception(
                    'Not found TypeRefType.string(value: RecordAttachment)'));
    return RecordAttachmentFluent<RecordAttachment>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<RecordAttachmentCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyRecordAttachment',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyRecordAttachment',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyRecordAttachment) =>
        AffectedRowsOutput.fromJson(createManyRecordAttachment.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  RecordAttachmentFluent<RecordAttachment?> update({
    required RecordAttachmentUpdateInput data,
    required RecordAttachmentWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneRecordAttachment',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneRecordAttachment',
    );
    final future =
        query(RecordAttachmentScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? RecordAttachment.fromJson(json.cast<String, dynamic>())
                : null);
    return RecordAttachmentFluent<RecordAttachment?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required RecordAttachmentUpdateManyMutationInput data,
    RecordAttachmentWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyRecordAttachment',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyRecordAttachment',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyRecordAttachment) =>
        AffectedRowsOutput.fromJson(updateManyRecordAttachment.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  RecordAttachmentFluent<RecordAttachment> upsert({
    required RecordAttachmentWhereUniqueInput where,
    required RecordAttachmentCreateInput create,
    required RecordAttachmentUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneRecordAttachment',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneRecordAttachment',
    );
    final future =
        query(RecordAttachmentScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? RecordAttachment.fromJson(json.cast<String, dynamic>())
                : throw Exception(
                    'Not found TypeRefType.string(value: RecordAttachment)'));
    return RecordAttachmentFluent<RecordAttachment>(
      future,
      query,
    );
  }

  RecordAttachmentFluent<RecordAttachment?> delete(
      {required RecordAttachmentWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneRecordAttachment',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneRecordAttachment',
    );
    final future =
        query(RecordAttachmentScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? RecordAttachment.fromJson(json.cast<String, dynamic>())
                : null);
    return RecordAttachmentFluent<RecordAttachment?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({RecordAttachmentWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyRecordAttachment',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyRecordAttachment',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyRecordAttachment) =>
        AffectedRowsOutput.fromJson(deleteManyRecordAttachment.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateRecordAttachment aggregate({
    RecordAttachmentWhereInput? where,
    Iterable<RecordAttachmentOrderByWithRelationInput>? orderBy,
    RecordAttachmentWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateRecordAttachment',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateRecordAttachment',
    );
    return AggregateRecordAttachment(query);
  }

  Future<Iterable<RecordAttachmentGroupByOutputType>> groupBy({
    RecordAttachmentWhereInput? where,
    Iterable<RecordAttachmentOrderByWithAggregationInput>? orderBy,
    required Iterable<RecordAttachmentScalarFieldEnum> by,
    RecordAttachmentScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByRecordAttachment',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByRecordAttachment',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByRecordAttachment) =>
        groupByRecordAttachment.map((Map groupByRecordAttachment) =>
            RecordAttachmentGroupByOutputType.fromJson(
                groupByRecordAttachment.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension CategoryModelDelegateExtension on _i1.ModelDelegate<Category> {
  CategoryFluent<Category?> findUnique(
      {required CategoryWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueCategory',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueCategory',
    );
    final future = query(CategoryScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Category.fromJson(json.cast<String, dynamic>())
            : null);
    return CategoryFluent<Category?>(
      future,
      query,
    );
  }

  CategoryFluent<Category> findUniqueOrThrow(
      {required CategoryWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueCategoryOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueCategoryOrThrow',
    );
    final future = query(CategoryScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Category.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Category)'));
    return CategoryFluent<Category>(
      future,
      query,
    );
  }

  CategoryFluent<Category?> findFirst({
    CategoryWhereInput? where,
    Iterable<CategoryOrderByWithRelationInput>? orderBy,
    CategoryWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CategoryScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstCategory',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstCategory',
    );
    final future = query(CategoryScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Category.fromJson(json.cast<String, dynamic>())
            : null);
    return CategoryFluent<Category?>(
      future,
      query,
    );
  }

  CategoryFluent<Category> findFirstOrThrow({
    CategoryWhereInput? where,
    Iterable<CategoryOrderByWithRelationInput>? orderBy,
    CategoryWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CategoryScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstCategoryOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstCategoryOrThrow',
    );
    final future = query(CategoryScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Category.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Category)'));
    return CategoryFluent<Category>(
      future,
      query,
    );
  }

  Future<Iterable<Category>> findMany({
    CategoryWhereInput? where,
    Iterable<CategoryOrderByWithRelationInput>? orderBy,
    CategoryWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CategoryScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyCategory',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyCategory',
    );
    final fields = CategoryScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyCategory) => findManyCategory.map(
        (Map findManyCategory) => Category.fromJson(findManyCategory.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  CategoryFluent<Category> create({required CategoryCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneCategory',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneCategory',
    );
    final future = query(CategoryScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Category.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Category)'));
    return CategoryFluent<Category>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<CategoryCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyCategory',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyCategory',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyCategory) =>
        AffectedRowsOutput.fromJson(createManyCategory.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  CategoryFluent<Category?> update({
    required CategoryUpdateInput data,
    required CategoryWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneCategory',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneCategory',
    );
    final future = query(CategoryScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Category.fromJson(json.cast<String, dynamic>())
            : null);
    return CategoryFluent<Category?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required CategoryUpdateManyMutationInput data,
    CategoryWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyCategory',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyCategory',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyCategory) =>
        AffectedRowsOutput.fromJson(updateManyCategory.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  CategoryFluent<Category> upsert({
    required CategoryWhereUniqueInput where,
    required CategoryCreateInput create,
    required CategoryUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneCategory',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneCategory',
    );
    final future = query(CategoryScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Category.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Category)'));
    return CategoryFluent<Category>(
      future,
      query,
    );
  }

  CategoryFluent<Category?> delete({required CategoryWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneCategory',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneCategory',
    );
    final future = query(CategoryScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Category.fromJson(json.cast<String, dynamic>())
            : null);
    return CategoryFluent<Category?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({CategoryWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyCategory',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyCategory',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyCategory) =>
        AffectedRowsOutput.fromJson(deleteManyCategory.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateCategory aggregate({
    CategoryWhereInput? where,
    Iterable<CategoryOrderByWithRelationInput>? orderBy,
    CategoryWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateCategory',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateCategory',
    );
    return AggregateCategory(query);
  }

  Future<Iterable<CategoryGroupByOutputType>> groupBy({
    CategoryWhereInput? where,
    Iterable<CategoryOrderByWithAggregationInput>? orderBy,
    required Iterable<CategoryScalarFieldEnum> by,
    CategoryScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByCategory',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByCategory',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByCategory) =>
        groupByCategory.map((Map groupByCategory) =>
            CategoryGroupByOutputType.fromJson(groupByCategory.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension TagModelDelegateExtension on _i1.ModelDelegate<Tag> {
  TagFluent<Tag?> findUnique({required TagWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueTag',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueTag',
    );
    final future = query(TagScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? Tag.fromJson(json.cast<String, dynamic>()) : null);
    return TagFluent<Tag?>(
      future,
      query,
    );
  }

  TagFluent<Tag> findUniqueOrThrow({required TagWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueTagOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueTagOrThrow',
    );
    final future = query(TagScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Tag.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Tag)'));
    return TagFluent<Tag>(
      future,
      query,
    );
  }

  TagFluent<Tag?> findFirst({
    TagWhereInput? where,
    Iterable<TagOrderByWithRelationInput>? orderBy,
    TagWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TagScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstTag',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstTag',
    );
    final future = query(TagScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? Tag.fromJson(json.cast<String, dynamic>()) : null);
    return TagFluent<Tag?>(
      future,
      query,
    );
  }

  TagFluent<Tag> findFirstOrThrow({
    TagWhereInput? where,
    Iterable<TagOrderByWithRelationInput>? orderBy,
    TagWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TagScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstTagOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstTagOrThrow',
    );
    final future = query(TagScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Tag.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Tag)'));
    return TagFluent<Tag>(
      future,
      query,
    );
  }

  Future<Iterable<Tag>> findMany({
    TagWhereInput? where,
    Iterable<TagOrderByWithRelationInput>? orderBy,
    TagWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TagScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyTag',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyTag',
    );
    final fields = TagScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyTag) =>
        findManyTag.map((Map findManyTag) => Tag.fromJson(findManyTag.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  TagFluent<Tag> create({required TagCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneTag',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneTag',
    );
    final future = query(TagScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Tag.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Tag)'));
    return TagFluent<Tag>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<TagCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyTag',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyTag',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyTag) =>
        AffectedRowsOutput.fromJson(createManyTag.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  TagFluent<Tag?> update({
    required TagUpdateInput data,
    required TagWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneTag',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneTag',
    );
    final future = query(TagScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? Tag.fromJson(json.cast<String, dynamic>()) : null);
    return TagFluent<Tag?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required TagUpdateManyMutationInput data,
    TagWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyTag',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyTag',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyTag) =>
        AffectedRowsOutput.fromJson(updateManyTag.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  TagFluent<Tag> upsert({
    required TagWhereUniqueInput where,
    required TagCreateInput create,
    required TagUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneTag',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneTag',
    );
    final future = query(TagScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Tag.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Tag)'));
    return TagFluent<Tag>(
      future,
      query,
    );
  }

  TagFluent<Tag?> delete({required TagWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneTag',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneTag',
    );
    final future = query(TagScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? Tag.fromJson(json.cast<String, dynamic>()) : null);
    return TagFluent<Tag?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({TagWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyTag',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyTag',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyTag) =>
        AffectedRowsOutput.fromJson(deleteManyTag.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateTag aggregate({
    TagWhereInput? where,
    Iterable<TagOrderByWithRelationInput>? orderBy,
    TagWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateTag',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateTag',
    );
    return AggregateTag(query);
  }

  Future<Iterable<TagGroupByOutputType>> groupBy({
    TagWhereInput? where,
    Iterable<TagOrderByWithAggregationInput>? orderBy,
    required Iterable<TagScalarFieldEnum> by,
    TagScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByTag',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByTag',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByTag) => groupByTag.map(
        (Map groupByTag) => TagGroupByOutputType.fromJson(groupByTag.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension TaskAssignmentModelDelegateExtension
    on _i1.ModelDelegate<TaskAssignment> {
  TaskAssignmentFluent<TaskAssignment?> findUnique(
      {required TaskAssignmentWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueTaskAssignment',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueTaskAssignment',
    );
    final future = query(TaskAssignmentScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? TaskAssignment.fromJson(json.cast<String, dynamic>())
            : null);
    return TaskAssignmentFluent<TaskAssignment?>(
      future,
      query,
    );
  }

  TaskAssignmentFluent<TaskAssignment> findUniqueOrThrow(
      {required TaskAssignmentWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueTaskAssignmentOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueTaskAssignmentOrThrow',
    );
    final future = query(TaskAssignmentScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? TaskAssignment.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found TypeRefType.string(value: TaskAssignment)'));
    return TaskAssignmentFluent<TaskAssignment>(
      future,
      query,
    );
  }

  TaskAssignmentFluent<TaskAssignment?> findFirst({
    TaskAssignmentWhereInput? where,
    Iterable<TaskAssignmentOrderByWithRelationInput>? orderBy,
    TaskAssignmentWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TaskAssignmentScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstTaskAssignment',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstTaskAssignment',
    );
    final future = query(TaskAssignmentScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? TaskAssignment.fromJson(json.cast<String, dynamic>())
            : null);
    return TaskAssignmentFluent<TaskAssignment?>(
      future,
      query,
    );
  }

  TaskAssignmentFluent<TaskAssignment> findFirstOrThrow({
    TaskAssignmentWhereInput? where,
    Iterable<TaskAssignmentOrderByWithRelationInput>? orderBy,
    TaskAssignmentWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TaskAssignmentScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstTaskAssignmentOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstTaskAssignmentOrThrow',
    );
    final future = query(TaskAssignmentScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? TaskAssignment.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found TypeRefType.string(value: TaskAssignment)'));
    return TaskAssignmentFluent<TaskAssignment>(
      future,
      query,
    );
  }

  Future<Iterable<TaskAssignment>> findMany({
    TaskAssignmentWhereInput? where,
    Iterable<TaskAssignmentOrderByWithRelationInput>? orderBy,
    TaskAssignmentWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TaskAssignmentScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyTaskAssignment',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyTaskAssignment',
    );
    final fields = TaskAssignmentScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyTaskAssignment) =>
        findManyTaskAssignment.map((Map findManyTaskAssignment) =>
            TaskAssignment.fromJson(findManyTaskAssignment.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  TaskAssignmentFluent<TaskAssignment> create(
      {required TaskAssignmentCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneTaskAssignment',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneTaskAssignment',
    );
    final future = query(TaskAssignmentScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? TaskAssignment.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found TypeRefType.string(value: TaskAssignment)'));
    return TaskAssignmentFluent<TaskAssignment>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<TaskAssignmentCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyTaskAssignment',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyTaskAssignment',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyTaskAssignment) =>
        AffectedRowsOutput.fromJson(createManyTaskAssignment.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  TaskAssignmentFluent<TaskAssignment?> update({
    required TaskAssignmentUpdateInput data,
    required TaskAssignmentWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneTaskAssignment',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneTaskAssignment',
    );
    final future = query(TaskAssignmentScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? TaskAssignment.fromJson(json.cast<String, dynamic>())
            : null);
    return TaskAssignmentFluent<TaskAssignment?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required TaskAssignmentUpdateManyMutationInput data,
    TaskAssignmentWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyTaskAssignment',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyTaskAssignment',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyTaskAssignment) =>
        AffectedRowsOutput.fromJson(updateManyTaskAssignment.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  TaskAssignmentFluent<TaskAssignment> upsert({
    required TaskAssignmentWhereUniqueInput where,
    required TaskAssignmentCreateInput create,
    required TaskAssignmentUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneTaskAssignment',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneTaskAssignment',
    );
    final future = query(TaskAssignmentScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? TaskAssignment.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found TypeRefType.string(value: TaskAssignment)'));
    return TaskAssignmentFluent<TaskAssignment>(
      future,
      query,
    );
  }

  TaskAssignmentFluent<TaskAssignment?> delete(
      {required TaskAssignmentWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneTaskAssignment',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneTaskAssignment',
    );
    final future = query(TaskAssignmentScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? TaskAssignment.fromJson(json.cast<String, dynamic>())
            : null);
    return TaskAssignmentFluent<TaskAssignment?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({TaskAssignmentWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyTaskAssignment',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyTaskAssignment',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyTaskAssignment) =>
        AffectedRowsOutput.fromJson(deleteManyTaskAssignment.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateTaskAssignment aggregate({
    TaskAssignmentWhereInput? where,
    Iterable<TaskAssignmentOrderByWithRelationInput>? orderBy,
    TaskAssignmentWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateTaskAssignment',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateTaskAssignment',
    );
    return AggregateTaskAssignment(query);
  }

  Future<Iterable<TaskAssignmentGroupByOutputType>> groupBy({
    TaskAssignmentWhereInput? where,
    Iterable<TaskAssignmentOrderByWithAggregationInput>? orderBy,
    required Iterable<TaskAssignmentScalarFieldEnum> by,
    TaskAssignmentScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByTaskAssignment',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByTaskAssignment',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByTaskAssignment) => groupByTaskAssignment.map(
        (Map groupByTaskAssignment) => TaskAssignmentGroupByOutputType.fromJson(
            groupByTaskAssignment.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension TaskAssignmentTagsModelDelegateExtension
    on _i1.ModelDelegate<TaskAssignmentTags> {
  TaskAssignmentTagsFluent<TaskAssignmentTags?> findUnique(
      {required TaskAssignmentTagsWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueTaskAssignmentTags',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueTaskAssignmentTags',
    );
    final future =
        query(TaskAssignmentTagsScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? TaskAssignmentTags.fromJson(json.cast<String, dynamic>())
                : null);
    return TaskAssignmentTagsFluent<TaskAssignmentTags?>(
      future,
      query,
    );
  }

  TaskAssignmentTagsFluent<TaskAssignmentTags> findUniqueOrThrow(
      {required TaskAssignmentTagsWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueTaskAssignmentTagsOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueTaskAssignmentTagsOrThrow',
    );
    final future =
        query(TaskAssignmentTagsScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? TaskAssignmentTags.fromJson(json.cast<String, dynamic>())
                : throw Exception(
                    'Not found TypeRefType.string(value: TaskAssignmentTags)'));
    return TaskAssignmentTagsFluent<TaskAssignmentTags>(
      future,
      query,
    );
  }

  TaskAssignmentTagsFluent<TaskAssignmentTags?> findFirst({
    TaskAssignmentTagsWhereInput? where,
    Iterable<TaskAssignmentTagsOrderByWithRelationInput>? orderBy,
    TaskAssignmentTagsWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TaskAssignmentTagsScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstTaskAssignmentTags',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstTaskAssignmentTags',
    );
    final future =
        query(TaskAssignmentTagsScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? TaskAssignmentTags.fromJson(json.cast<String, dynamic>())
                : null);
    return TaskAssignmentTagsFluent<TaskAssignmentTags?>(
      future,
      query,
    );
  }

  TaskAssignmentTagsFluent<TaskAssignmentTags> findFirstOrThrow({
    TaskAssignmentTagsWhereInput? where,
    Iterable<TaskAssignmentTagsOrderByWithRelationInput>? orderBy,
    TaskAssignmentTagsWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TaskAssignmentTagsScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstTaskAssignmentTagsOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstTaskAssignmentTagsOrThrow',
    );
    final future =
        query(TaskAssignmentTagsScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? TaskAssignmentTags.fromJson(json.cast<String, dynamic>())
                : throw Exception(
                    'Not found TypeRefType.string(value: TaskAssignmentTags)'));
    return TaskAssignmentTagsFluent<TaskAssignmentTags>(
      future,
      query,
    );
  }

  Future<Iterable<TaskAssignmentTags>> findMany({
    TaskAssignmentTagsWhereInput? where,
    Iterable<TaskAssignmentTagsOrderByWithRelationInput>? orderBy,
    TaskAssignmentTagsWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<TaskAssignmentTagsScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyTaskAssignmentTags',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyTaskAssignmentTags',
    );
    final fields = TaskAssignmentTagsScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyTaskAssignmentTags) =>
        findManyTaskAssignmentTags.map((Map findManyTaskAssignmentTags) =>
            TaskAssignmentTags.fromJson(findManyTaskAssignmentTags.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  TaskAssignmentTagsFluent<TaskAssignmentTags> create(
      {required TaskAssignmentTagsCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneTaskAssignmentTags',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneTaskAssignmentTags',
    );
    final future =
        query(TaskAssignmentTagsScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? TaskAssignmentTags.fromJson(json.cast<String, dynamic>())
                : throw Exception(
                    'Not found TypeRefType.string(value: TaskAssignmentTags)'));
    return TaskAssignmentTagsFluent<TaskAssignmentTags>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<TaskAssignmentTagsCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyTaskAssignmentTags',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyTaskAssignmentTags',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyTaskAssignmentTags) =>
        AffectedRowsOutput.fromJson(createManyTaskAssignmentTags.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  TaskAssignmentTagsFluent<TaskAssignmentTags?> update({
    required TaskAssignmentTagsUpdateInput data,
    required TaskAssignmentTagsWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneTaskAssignmentTags',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneTaskAssignmentTags',
    );
    final future =
        query(TaskAssignmentTagsScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? TaskAssignmentTags.fromJson(json.cast<String, dynamic>())
                : null);
    return TaskAssignmentTagsFluent<TaskAssignmentTags?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required TaskAssignmentTagsUpdateManyMutationInput data,
    TaskAssignmentTagsWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyTaskAssignmentTags',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyTaskAssignmentTags',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyTaskAssignmentTags) =>
        AffectedRowsOutput.fromJson(updateManyTaskAssignmentTags.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  TaskAssignmentTagsFluent<TaskAssignmentTags> upsert({
    required TaskAssignmentTagsWhereUniqueInput where,
    required TaskAssignmentTagsCreateInput create,
    required TaskAssignmentTagsUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneTaskAssignmentTags',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneTaskAssignmentTags',
    );
    final future =
        query(TaskAssignmentTagsScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? TaskAssignmentTags.fromJson(json.cast<String, dynamic>())
                : throw Exception(
                    'Not found TypeRefType.string(value: TaskAssignmentTags)'));
    return TaskAssignmentTagsFluent<TaskAssignmentTags>(
      future,
      query,
    );
  }

  TaskAssignmentTagsFluent<TaskAssignmentTags?> delete(
      {required TaskAssignmentTagsWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneTaskAssignmentTags',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneTaskAssignmentTags',
    );
    final future =
        query(TaskAssignmentTagsScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? TaskAssignmentTags.fromJson(json.cast<String, dynamic>())
                : null);
    return TaskAssignmentTagsFluent<TaskAssignmentTags?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({TaskAssignmentTagsWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyTaskAssignmentTags',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyTaskAssignmentTags',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyTaskAssignmentTags) =>
        AffectedRowsOutput.fromJson(deleteManyTaskAssignmentTags.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateTaskAssignmentTags aggregate({
    TaskAssignmentTagsWhereInput? where,
    Iterable<TaskAssignmentTagsOrderByWithRelationInput>? orderBy,
    TaskAssignmentTagsWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateTaskAssignmentTags',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateTaskAssignmentTags',
    );
    return AggregateTaskAssignmentTags(query);
  }

  Future<Iterable<TaskAssignmentTagsGroupByOutputType>> groupBy({
    TaskAssignmentTagsWhereInput? where,
    Iterable<TaskAssignmentTagsOrderByWithAggregationInput>? orderBy,
    required Iterable<TaskAssignmentTagsScalarFieldEnum> by,
    TaskAssignmentTagsScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByTaskAssignmentTags',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByTaskAssignmentTags',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByTaskAssignmentTags) =>
        groupByTaskAssignmentTags.map((Map groupByTaskAssignmentTags) =>
            TaskAssignmentTagsGroupByOutputType.fromJson(
                groupByTaskAssignmentTags.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension ChannelSubscriptionModelDelegateExtension
    on _i1.ModelDelegate<ChannelSubscription> {
  ChannelSubscriptionFluent<ChannelSubscription?> findUnique(
      {required ChannelSubscriptionWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueChannelSubscription',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueChannelSubscription',
    );
    final future =
        query(ChannelSubscriptionScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ChannelSubscription.fromJson(json.cast<String, dynamic>())
                : null);
    return ChannelSubscriptionFluent<ChannelSubscription?>(
      future,
      query,
    );
  }

  ChannelSubscriptionFluent<ChannelSubscription> findUniqueOrThrow(
      {required ChannelSubscriptionWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueChannelSubscriptionOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueChannelSubscriptionOrThrow',
    );
    final future = query(
            ChannelSubscriptionScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ChannelSubscription.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found TypeRefType.string(value: ChannelSubscription)'));
    return ChannelSubscriptionFluent<ChannelSubscription>(
      future,
      query,
    );
  }

  ChannelSubscriptionFluent<ChannelSubscription?> findFirst({
    ChannelSubscriptionWhereInput? where,
    Iterable<ChannelSubscriptionOrderByWithRelationInput>? orderBy,
    ChannelSubscriptionWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<ChannelSubscriptionScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstChannelSubscription',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstChannelSubscription',
    );
    final future =
        query(ChannelSubscriptionScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ChannelSubscription.fromJson(json.cast<String, dynamic>())
                : null);
    return ChannelSubscriptionFluent<ChannelSubscription?>(
      future,
      query,
    );
  }

  ChannelSubscriptionFluent<ChannelSubscription> findFirstOrThrow({
    ChannelSubscriptionWhereInput? where,
    Iterable<ChannelSubscriptionOrderByWithRelationInput>? orderBy,
    ChannelSubscriptionWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<ChannelSubscriptionScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstChannelSubscriptionOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstChannelSubscriptionOrThrow',
    );
    final future = query(
            ChannelSubscriptionScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ChannelSubscription.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found TypeRefType.string(value: ChannelSubscription)'));
    return ChannelSubscriptionFluent<ChannelSubscription>(
      future,
      query,
    );
  }

  Future<Iterable<ChannelSubscription>> findMany({
    ChannelSubscriptionWhereInput? where,
    Iterable<ChannelSubscriptionOrderByWithRelationInput>? orderBy,
    ChannelSubscriptionWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<ChannelSubscriptionScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyChannelSubscription',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyChannelSubscription',
    );
    final fields = ChannelSubscriptionScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyChannelSubscription) =>
        findManyChannelSubscription.map((Map findManyChannelSubscription) =>
            ChannelSubscription.fromJson(findManyChannelSubscription.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  ChannelSubscriptionFluent<ChannelSubscription> create(
      {required ChannelSubscriptionCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneChannelSubscription',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneChannelSubscription',
    );
    final future = query(
            ChannelSubscriptionScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ChannelSubscription.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found TypeRefType.string(value: ChannelSubscription)'));
    return ChannelSubscriptionFluent<ChannelSubscription>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<ChannelSubscriptionCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyChannelSubscription',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyChannelSubscription',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyChannelSubscription) =>
        AffectedRowsOutput.fromJson(createManyChannelSubscription.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  ChannelSubscriptionFluent<ChannelSubscription?> update({
    required ChannelSubscriptionUpdateInput data,
    required ChannelSubscriptionWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneChannelSubscription',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneChannelSubscription',
    );
    final future =
        query(ChannelSubscriptionScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ChannelSubscription.fromJson(json.cast<String, dynamic>())
                : null);
    return ChannelSubscriptionFluent<ChannelSubscription?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required ChannelSubscriptionUpdateManyMutationInput data,
    ChannelSubscriptionWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyChannelSubscription',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyChannelSubscription',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyChannelSubscription) =>
        AffectedRowsOutput.fromJson(updateManyChannelSubscription.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  ChannelSubscriptionFluent<ChannelSubscription> upsert({
    required ChannelSubscriptionWhereUniqueInput where,
    required ChannelSubscriptionCreateInput create,
    required ChannelSubscriptionUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneChannelSubscription',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneChannelSubscription',
    );
    final future = query(
            ChannelSubscriptionScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ChannelSubscription.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found TypeRefType.string(value: ChannelSubscription)'));
    return ChannelSubscriptionFluent<ChannelSubscription>(
      future,
      query,
    );
  }

  ChannelSubscriptionFluent<ChannelSubscription?> delete(
      {required ChannelSubscriptionWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneChannelSubscription',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneChannelSubscription',
    );
    final future =
        query(ChannelSubscriptionScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ChannelSubscription.fromJson(json.cast<String, dynamic>())
                : null);
    return ChannelSubscriptionFluent<ChannelSubscription?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany(
      {ChannelSubscriptionWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyChannelSubscription',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyChannelSubscription',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyChannelSubscription) =>
        AffectedRowsOutput.fromJson(deleteManyChannelSubscription.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateChannelSubscription aggregate({
    ChannelSubscriptionWhereInput? where,
    Iterable<ChannelSubscriptionOrderByWithRelationInput>? orderBy,
    ChannelSubscriptionWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateChannelSubscription',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateChannelSubscription',
    );
    return AggregateChannelSubscription(query);
  }

  Future<Iterable<ChannelSubscriptionGroupByOutputType>> groupBy({
    ChannelSubscriptionWhereInput? where,
    Iterable<ChannelSubscriptionOrderByWithAggregationInput>? orderBy,
    required Iterable<ChannelSubscriptionScalarFieldEnum> by,
    ChannelSubscriptionScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByChannelSubscription',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByChannelSubscription',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByChannelSubscription) =>
        groupByChannelSubscription.map((Map groupByChannelSubscription) =>
            ChannelSubscriptionGroupByOutputType.fromJson(
                groupByChannelSubscription.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension ScheduleModelDelegateExtension on _i1.ModelDelegate<Schedule> {
  ScheduleFluent<Schedule?> findUnique(
      {required ScheduleWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueSchedule',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueSchedule',
    );
    final future = query(ScheduleScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Schedule.fromJson(json.cast<String, dynamic>())
            : null);
    return ScheduleFluent<Schedule?>(
      future,
      query,
    );
  }

  ScheduleFluent<Schedule> findUniqueOrThrow(
      {required ScheduleWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueScheduleOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueScheduleOrThrow',
    );
    final future = query(ScheduleScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Schedule.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Schedule)'));
    return ScheduleFluent<Schedule>(
      future,
      query,
    );
  }

  ScheduleFluent<Schedule?> findFirst({
    ScheduleWhereInput? where,
    Iterable<ScheduleOrderByWithRelationInput>? orderBy,
    ScheduleWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<ScheduleScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstSchedule',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstSchedule',
    );
    final future = query(ScheduleScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Schedule.fromJson(json.cast<String, dynamic>())
            : null);
    return ScheduleFluent<Schedule?>(
      future,
      query,
    );
  }

  ScheduleFluent<Schedule> findFirstOrThrow({
    ScheduleWhereInput? where,
    Iterable<ScheduleOrderByWithRelationInput>? orderBy,
    ScheduleWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<ScheduleScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstScheduleOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstScheduleOrThrow',
    );
    final future = query(ScheduleScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Schedule.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Schedule)'));
    return ScheduleFluent<Schedule>(
      future,
      query,
    );
  }

  Future<Iterable<Schedule>> findMany({
    ScheduleWhereInput? where,
    Iterable<ScheduleOrderByWithRelationInput>? orderBy,
    ScheduleWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<ScheduleScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManySchedule',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManySchedule',
    );
    final fields = ScheduleScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySchedule) => findManySchedule.map(
        (Map findManySchedule) => Schedule.fromJson(findManySchedule.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  ScheduleFluent<Schedule> create({required ScheduleCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneSchedule',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneSchedule',
    );
    final future = query(ScheduleScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Schedule.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Schedule)'));
    return ScheduleFluent<Schedule>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<ScheduleCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManySchedule',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManySchedule',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySchedule) =>
        AffectedRowsOutput.fromJson(createManySchedule.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  ScheduleFluent<Schedule?> update({
    required ScheduleUpdateInput data,
    required ScheduleWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneSchedule',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneSchedule',
    );
    final future = query(ScheduleScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Schedule.fromJson(json.cast<String, dynamic>())
            : null);
    return ScheduleFluent<Schedule?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required ScheduleUpdateManyMutationInput data,
    ScheduleWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManySchedule',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManySchedule',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySchedule) =>
        AffectedRowsOutput.fromJson(updateManySchedule.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  ScheduleFluent<Schedule> upsert({
    required ScheduleWhereUniqueInput where,
    required ScheduleCreateInput create,
    required ScheduleUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneSchedule',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneSchedule',
    );
    final future = query(ScheduleScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Schedule.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: Schedule)'));
    return ScheduleFluent<Schedule>(
      future,
      query,
    );
  }

  ScheduleFluent<Schedule?> delete({required ScheduleWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneSchedule',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneSchedule',
    );
    final future = query(ScheduleScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? Schedule.fromJson(json.cast<String, dynamic>())
            : null);
    return ScheduleFluent<Schedule?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({ScheduleWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManySchedule',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManySchedule',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySchedule) =>
        AffectedRowsOutput.fromJson(deleteManySchedule.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSchedule aggregate({
    ScheduleWhereInput? where,
    Iterable<ScheduleOrderByWithRelationInput>? orderBy,
    ScheduleWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateSchedule',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateSchedule',
    );
    return AggregateSchedule(query);
  }

  Future<Iterable<ScheduleGroupByOutputType>> groupBy({
    ScheduleWhereInput? where,
    Iterable<ScheduleOrderByWithAggregationInput>? orderBy,
    required Iterable<ScheduleScalarFieldEnum> by,
    ScheduleScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupBySchedule',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupBySchedule',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySchedule) =>
        groupBySchedule.map((Map groupBySchedule) =>
            ScheduleGroupByOutputType.fromJson(groupBySchedule.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension FileRefModelDelegateExtension on _i1.ModelDelegate<FileRef> {
  FileRefFluent<FileRef?> findUnique({required FileRefWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueFileRef',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueFileRef',
    );
    final future = query(FileRefScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? FileRef.fromJson(json.cast<String, dynamic>())
            : null);
    return FileRefFluent<FileRef?>(
      future,
      query,
    );
  }

  FileRefFluent<FileRef> findUniqueOrThrow(
      {required FileRefWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueFileRefOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueFileRefOrThrow',
    );
    final future = query(FileRefScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? FileRef.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: FileRef)'));
    return FileRefFluent<FileRef>(
      future,
      query,
    );
  }

  FileRefFluent<FileRef?> findFirst({
    FileRefWhereInput? where,
    Iterable<FileRefOrderByWithRelationInput>? orderBy,
    FileRefWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<FileRefScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstFileRef',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstFileRef',
    );
    final future = query(FileRefScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? FileRef.fromJson(json.cast<String, dynamic>())
            : null);
    return FileRefFluent<FileRef?>(
      future,
      query,
    );
  }

  FileRefFluent<FileRef> findFirstOrThrow({
    FileRefWhereInput? where,
    Iterable<FileRefOrderByWithRelationInput>? orderBy,
    FileRefWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<FileRefScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstFileRefOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstFileRefOrThrow',
    );
    final future = query(FileRefScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? FileRef.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: FileRef)'));
    return FileRefFluent<FileRef>(
      future,
      query,
    );
  }

  Future<Iterable<FileRef>> findMany({
    FileRefWhereInput? where,
    Iterable<FileRefOrderByWithRelationInput>? orderBy,
    FileRefWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<FileRefScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyFileRef',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyFileRef',
    );
    final fields = FileRefScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyFileRef) => findManyFileRef
        .map((Map findManyFileRef) => FileRef.fromJson(findManyFileRef.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  FileRefFluent<FileRef> create({required FileRefCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneFileRef',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneFileRef',
    );
    final future = query(FileRefScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? FileRef.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: FileRef)'));
    return FileRefFluent<FileRef>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<FileRefCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyFileRef',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyFileRef',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyFileRef) =>
        AffectedRowsOutput.fromJson(createManyFileRef.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  FileRefFluent<FileRef?> update({
    required FileRefUpdateInput data,
    required FileRefWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneFileRef',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneFileRef',
    );
    final future = query(FileRefScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? FileRef.fromJson(json.cast<String, dynamic>())
            : null);
    return FileRefFluent<FileRef?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required FileRefUpdateManyMutationInput data,
    FileRefWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyFileRef',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyFileRef',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyFileRef) =>
        AffectedRowsOutput.fromJson(updateManyFileRef.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  FileRefFluent<FileRef> upsert({
    required FileRefWhereUniqueInput where,
    required FileRefCreateInput create,
    required FileRefUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneFileRef',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneFileRef',
    );
    final future = query(FileRefScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? FileRef.fromJson(json.cast<String, dynamic>())
            : throw Exception('Not found TypeRefType.string(value: FileRef)'));
    return FileRefFluent<FileRef>(
      future,
      query,
    );
  }

  FileRefFluent<FileRef?> delete({required FileRefWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneFileRef',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneFileRef',
    );
    final future = query(FileRefScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? FileRef.fromJson(json.cast<String, dynamic>())
            : null);
    return FileRefFluent<FileRef?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({FileRefWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyFileRef',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyFileRef',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyFileRef) =>
        AffectedRowsOutput.fromJson(deleteManyFileRef.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateFileRef aggregate({
    FileRefWhereInput? where,
    Iterable<FileRefOrderByWithRelationInput>? orderBy,
    FileRefWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateFileRef',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateFileRef',
    );
    return AggregateFileRef(query);
  }

  Future<Iterable<FileRefGroupByOutputType>> groupBy({
    FileRefWhereInput? where,
    Iterable<FileRefOrderByWithAggregationInput>? orderBy,
    required Iterable<FileRefScalarFieldEnum> by,
    FileRefScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByFileRef',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByFileRef',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByFileRef) =>
        groupByFileRef.map((Map groupByFileRef) =>
            FileRefGroupByOutputType.fromJson(groupByFileRef.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

@_i1.jsonSerializable
class UserGroupByOutputType implements _i1.JsonSerializable {
  const UserGroupByOutputType({
    this.id,
    this.name,
    this.email,
    this.phone,
    this.password,
    this.avatarRef,
    this.unionId,
    this.tencentId,
    this.appleId,
  });

  factory UserGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$UserGroupByOutputTypeFromJson(json);

  final int? id;

  final String? name;

  final String? email;

  final String? phone;

  final String? password;

  final String? avatarRef;

  final String? unionId;

  final String? tencentId;

  final String? appleId;

  @override
  Map<String, dynamic> toJson() => _$UserGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class ProfileGroupByOutputType implements _i1.JsonSerializable {
  const ProfileGroupByOutputType({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ProfileGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$ProfileGroupByOutputTypeFromJson(json);

  final String? name;

  final String? color;

  final String? icon;

  final int? userId;

  final BigInt? updateAt;

  final BigInt? syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$ProfileGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class TaskGroupByOutputType implements _i1.JsonSerializable {
  const TaskGroupByOutputType({
    this.uuid,
    this.title,
    this.desc,
    this.content,
    this.location,
    this.requireLocation,
    this.requireTime,
    this.requireAttachment,
    this.userId,
    this.profile,
    this.parentUuid,
    this.channelUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$TaskGroupByOutputTypeFromJson(json);

  final String? uuid;

  final String? title;

  final String? desc;

  final String? content;

  final String? location;

  final bool? requireLocation;

  final bool? requireTime;

  final bool? requireAttachment;

  final int? userId;

  final String? profile;

  final String? parentUuid;

  final String? channelUuid;

  final BigInt? updateAt;

  final BigInt? syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TaskGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class TaskAssetGroupByOutputType implements _i1.JsonSerializable {
  const TaskAssetGroupByOutputType({
    this.name,
    this.hash,
    this.assetRef,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssetGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$TaskAssetGroupByOutputTypeFromJson(json);

  final String? name;

  final String? hash;

  final String? assetRef;

  final String? taskUuid;

  final BigInt? updateAt;

  final BigInt? syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TaskAssetGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class ChannelGroupByOutputType implements _i1.JsonSerializable {
  const ChannelGroupByOutputType({
    this.uuid,
    this.name,
    this.desc,
    this.color,
    this.imgRef,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$ChannelGroupByOutputTypeFromJson(json);

  final String? uuid;

  final String? name;

  final String? desc;

  final String? color;

  final String? imgRef;

  final int? userId;

  final String? profileName;

  final BigInt? updateAt;

  final BigInt? syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$ChannelGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class SessionGroupByOutputType implements _i1.JsonSerializable {
  const SessionGroupByOutputType({
    this.uuid,
    this.start,
    this.end,
    this.cycle,
    this.taskUuid,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory SessionGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$SessionGroupByOutputTypeFromJson(json);

  final String? uuid;

  final BigInt? start;

  final BigInt? end;

  final BigInt? cycle;

  final String? taskUuid;

  final BigInt? updateAt;

  final BigInt? syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$SessionGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class RecordGroupByOutputType implements _i1.JsonSerializable {
  const RecordGroupByOutputType({
    this.time,
    this.recordIndex,
    this.sessionUuid,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory RecordGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$RecordGroupByOutputTypeFromJson(json);

  final BigInt? time;

  final int? recordIndex;

  final String? sessionUuid;

  final String? taskUuid;

  final int? userId;

  final String? profileName;

  final BigInt? updateAt;

  final BigInt? syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$RecordGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class RecordAttachmentGroupByOutputType implements _i1.JsonSerializable {
  const RecordAttachmentGroupByOutputType({
    this.hash,
    this.name,
    this.assetRef,
    this.sessionUuid,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.recordIndex,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory RecordAttachmentGroupByOutputType.fromJson(
          Map<String, dynamic> json) =>
      _$RecordAttachmentGroupByOutputTypeFromJson(json);

  final String? hash;

  final String? name;

  final String? assetRef;

  final String? sessionUuid;

  final String? taskUuid;

  final int? userId;

  final String? profileName;

  final int? recordIndex;

  final BigInt? updateAt;

  final BigInt? syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$RecordAttachmentGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class CategoryGroupByOutputType implements _i1.JsonSerializable {
  const CategoryGroupByOutputType({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory CategoryGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$CategoryGroupByOutputTypeFromJson(json);

  final String? name;

  final String? color;

  final String? icon;

  final int? userId;

  final String? profileName;

  final BigInt? updateAt;

  final BigInt? syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$CategoryGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class TagGroupByOutputType implements _i1.JsonSerializable {
  const TagGroupByOutputType({
    this.name,
    this.color,
    this.icon,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TagGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$TagGroupByOutputTypeFromJson(json);

  final String? name;

  final String? color;

  final String? icon;

  final int? userId;

  final String? profileName;

  final BigInt? updateAt;

  final BigInt? syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$TagGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentGroupByOutputType implements _i1.JsonSerializable {
  const TaskAssignmentGroupByOutputType({
    this.status,
    this.priority,
    this.starred,
    this.taskUuid,
    this.userId,
    this.profileName,
    this.categoryName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory TaskAssignmentGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$TaskAssignmentGroupByOutputTypeFromJson(json);

  final TaskAssignmentStatus? status;

  final TaskPriority? priority;

  final bool? starred;

  final String? taskUuid;

  final int? userId;

  final String? profileName;

  final String? categoryName;

  final BigInt? updateAt;

  final BigInt? syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class TaskAssignmentTagsGroupByOutputType implements _i1.JsonSerializable {
  const TaskAssignmentTagsGroupByOutputType({
    this.taskUuid,
    this.userId,
    this.profileName,
    this.tagName,
  });

  factory TaskAssignmentTagsGroupByOutputType.fromJson(
          Map<String, dynamic> json) =>
      _$TaskAssignmentTagsGroupByOutputTypeFromJson(json);

  final String? taskUuid;

  final int? userId;

  final String? profileName;

  final String? tagName;

  @override
  Map<String, dynamic> toJson() =>
      _$TaskAssignmentTagsGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class ChannelSubscriptionGroupByOutputType implements _i1.JsonSerializable {
  const ChannelSubscriptionGroupByOutputType({
    this.shareRecord,
    this.channelUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ChannelSubscriptionGroupByOutputType.fromJson(
          Map<String, dynamic> json) =>
      _$ChannelSubscriptionGroupByOutputTypeFromJson(json);

  final bool? shareRecord;

  final String? channelUuid;

  final int? userId;

  final String? profileName;

  final BigInt? updateAt;

  final BigInt? syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() =>
      _$ChannelSubscriptionGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class ScheduleGroupByOutputType implements _i1.JsonSerializable {
  const ScheduleGroupByOutputType({
    this.relStart,
    this.relEnd,
    this.sessionUuid,
    this.userId,
    this.profileName,
    this.updateAt,
    this.syncAt,
    this.deleteAt,
  });

  factory ScheduleGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$ScheduleGroupByOutputTypeFromJson(json);

  final BigInt? relStart;

  final BigInt? relEnd;

  final String? sessionUuid;

  final int? userId;

  final String? profileName;

  final BigInt? updateAt;

  final BigInt? syncAt;

  final BigInt? deleteAt;

  @override
  Map<String, dynamic> toJson() => _$ScheduleGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class FileRefGroupByOutputType implements _i1.JsonSerializable {
  const FileRefGroupByOutputType({
    this.hash,
    this.count,
  });

  factory FileRefGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$FileRefGroupByOutputTypeFromJson(json);

  final String? hash;

  final int? count;

  @override
  Map<String, dynamic> toJson() => _$FileRefGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class AffectedRowsOutput implements _i1.JsonSerializable {
  const AffectedRowsOutput({this.count});

  factory AffectedRowsOutput.fromJson(Map<String, dynamic> json) =>
      _$AffectedRowsOutputFromJson(json);

  final int? count;

  @override
  Map<String, dynamic> toJson() => _$AffectedRowsOutputToJson(this);
}

class AggregateUser {
  const AggregateUser(this.$query);

  final _i1.PrismaFluentQuery $query;

  UserCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return UserCountAggregateOutputType(query);
  }

  UserAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return UserAvgAggregateOutputType(query);
  }

  UserSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return UserSumAggregateOutputType(query);
  }

  UserMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return UserMinAggregateOutputType(query);
  }

  UserMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return UserMaxAggregateOutputType(query);
  }
}

class AggregateProfile {
  const AggregateProfile(this.$query);

  final _i1.PrismaFluentQuery $query;

  ProfileCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return ProfileCountAggregateOutputType(query);
  }

  ProfileAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return ProfileAvgAggregateOutputType(query);
  }

  ProfileSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return ProfileSumAggregateOutputType(query);
  }

  ProfileMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return ProfileMinAggregateOutputType(query);
  }

  ProfileMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return ProfileMaxAggregateOutputType(query);
  }
}

class AggregateTask {
  const AggregateTask(this.$query);

  final _i1.PrismaFluentQuery $query;

  TaskCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return TaskCountAggregateOutputType(query);
  }

  TaskAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return TaskAvgAggregateOutputType(query);
  }

  TaskSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return TaskSumAggregateOutputType(query);
  }

  TaskMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return TaskMinAggregateOutputType(query);
  }

  TaskMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return TaskMaxAggregateOutputType(query);
  }
}

class AggregateTaskAsset {
  const AggregateTaskAsset(this.$query);

  final _i1.PrismaFluentQuery $query;

  TaskAssetCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return TaskAssetCountAggregateOutputType(query);
  }

  TaskAssetAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return TaskAssetAvgAggregateOutputType(query);
  }

  TaskAssetSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return TaskAssetSumAggregateOutputType(query);
  }

  TaskAssetMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return TaskAssetMinAggregateOutputType(query);
  }

  TaskAssetMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return TaskAssetMaxAggregateOutputType(query);
  }
}

class AggregateChannel {
  const AggregateChannel(this.$query);

  final _i1.PrismaFluentQuery $query;

  ChannelCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return ChannelCountAggregateOutputType(query);
  }

  ChannelAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return ChannelAvgAggregateOutputType(query);
  }

  ChannelSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return ChannelSumAggregateOutputType(query);
  }

  ChannelMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return ChannelMinAggregateOutputType(query);
  }

  ChannelMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return ChannelMaxAggregateOutputType(query);
  }
}

class AggregateSession {
  const AggregateSession(this.$query);

  final _i1.PrismaFluentQuery $query;

  SessionCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return SessionCountAggregateOutputType(query);
  }

  SessionAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return SessionAvgAggregateOutputType(query);
  }

  SessionSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return SessionSumAggregateOutputType(query);
  }

  SessionMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return SessionMinAggregateOutputType(query);
  }

  SessionMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return SessionMaxAggregateOutputType(query);
  }
}

class AggregateRecord {
  const AggregateRecord(this.$query);

  final _i1.PrismaFluentQuery $query;

  RecordCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return RecordCountAggregateOutputType(query);
  }

  RecordAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return RecordAvgAggregateOutputType(query);
  }

  RecordSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return RecordSumAggregateOutputType(query);
  }

  RecordMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return RecordMinAggregateOutputType(query);
  }

  RecordMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return RecordMaxAggregateOutputType(query);
  }
}

class AggregateRecordAttachment {
  const AggregateRecordAttachment(this.$query);

  final _i1.PrismaFluentQuery $query;

  RecordAttachmentCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return RecordAttachmentCountAggregateOutputType(query);
  }

  RecordAttachmentAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return RecordAttachmentAvgAggregateOutputType(query);
  }

  RecordAttachmentSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return RecordAttachmentSumAggregateOutputType(query);
  }

  RecordAttachmentMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return RecordAttachmentMinAggregateOutputType(query);
  }

  RecordAttachmentMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return RecordAttachmentMaxAggregateOutputType(query);
  }
}

class AggregateCategory {
  const AggregateCategory(this.$query);

  final _i1.PrismaFluentQuery $query;

  CategoryCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return CategoryCountAggregateOutputType(query);
  }

  CategoryAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return CategoryAvgAggregateOutputType(query);
  }

  CategorySumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return CategorySumAggregateOutputType(query);
  }

  CategoryMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return CategoryMinAggregateOutputType(query);
  }

  CategoryMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return CategoryMaxAggregateOutputType(query);
  }
}

class AggregateTag {
  const AggregateTag(this.$query);

  final _i1.PrismaFluentQuery $query;

  TagCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return TagCountAggregateOutputType(query);
  }

  TagAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return TagAvgAggregateOutputType(query);
  }

  TagSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return TagSumAggregateOutputType(query);
  }

  TagMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return TagMinAggregateOutputType(query);
  }

  TagMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return TagMaxAggregateOutputType(query);
  }
}

class AggregateTaskAssignment {
  const AggregateTaskAssignment(this.$query);

  final _i1.PrismaFluentQuery $query;

  TaskAssignmentCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return TaskAssignmentCountAggregateOutputType(query);
  }

  TaskAssignmentAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return TaskAssignmentAvgAggregateOutputType(query);
  }

  TaskAssignmentSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return TaskAssignmentSumAggregateOutputType(query);
  }

  TaskAssignmentMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return TaskAssignmentMinAggregateOutputType(query);
  }

  TaskAssignmentMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return TaskAssignmentMaxAggregateOutputType(query);
  }
}

class AggregateTaskAssignmentTags {
  const AggregateTaskAssignmentTags(this.$query);

  final _i1.PrismaFluentQuery $query;

  TaskAssignmentTagsCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return TaskAssignmentTagsCountAggregateOutputType(query);
  }

  TaskAssignmentTagsAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return TaskAssignmentTagsAvgAggregateOutputType(query);
  }

  TaskAssignmentTagsSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return TaskAssignmentTagsSumAggregateOutputType(query);
  }

  TaskAssignmentTagsMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return TaskAssignmentTagsMinAggregateOutputType(query);
  }

  TaskAssignmentTagsMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return TaskAssignmentTagsMaxAggregateOutputType(query);
  }
}

class AggregateChannelSubscription {
  const AggregateChannelSubscription(this.$query);

  final _i1.PrismaFluentQuery $query;

  ChannelSubscriptionCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return ChannelSubscriptionCountAggregateOutputType(query);
  }

  ChannelSubscriptionAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return ChannelSubscriptionAvgAggregateOutputType(query);
  }

  ChannelSubscriptionSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return ChannelSubscriptionSumAggregateOutputType(query);
  }

  ChannelSubscriptionMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return ChannelSubscriptionMinAggregateOutputType(query);
  }

  ChannelSubscriptionMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return ChannelSubscriptionMaxAggregateOutputType(query);
  }
}

class AggregateSchedule {
  const AggregateSchedule(this.$query);

  final _i1.PrismaFluentQuery $query;

  ScheduleCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return ScheduleCountAggregateOutputType(query);
  }

  ScheduleAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return ScheduleAvgAggregateOutputType(query);
  }

  ScheduleSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return ScheduleSumAggregateOutputType(query);
  }

  ScheduleMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return ScheduleMinAggregateOutputType(query);
  }

  ScheduleMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return ScheduleMaxAggregateOutputType(query);
  }
}

class AggregateFileRef {
  const AggregateFileRef(this.$query);

  final _i1.PrismaFluentQuery $query;

  FileRefCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return FileRefCountAggregateOutputType(query);
  }

  FileRefAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return FileRefAvgAggregateOutputType(query);
  }

  FileRefSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return FileRefSumAggregateOutputType(query);
  }

  FileRefMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return FileRefMinAggregateOutputType(query);
  }

  FileRefMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return FileRefMaxAggregateOutputType(query);
  }
}

class UserCountOutputType {
  const UserCountOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> profiles() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profiles',
          fields: fields,
        )
      ]),
      key: r'profiles',
    );
    return query(const []).then((value) => (value as int));
  }
}

class UserCountAggregateOutputType {
  const UserCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> id() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'id',
          fields: fields,
        )
      ]),
      key: r'id',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> name() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'name',
          fields: fields,
        )
      ]),
      key: r'name',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> email() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'email',
          fields: fields,
        )
      ]),
      key: r'email',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> phone() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'phone',
          fields: fields,
        )
      ]),
      key: r'phone',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> password() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'password',
          fields: fields,
        )
      ]),
      key: r'password',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> avatarRef() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'avatarRef',
          fields: fields,
        )
      ]),
      key: r'avatarRef',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> unionId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'unionId',
          fields: fields,
        )
      ]),
      key: r'unionId',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> tencentId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'tencentId',
          fields: fields,
        )
      ]),
      key: r'tencentId',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> appleId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'appleId',
          fields: fields,
        )
      ]),
      key: r'appleId',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class UserAvgAggregateOutputType {
  const UserAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> id() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'id',
          fields: fields,
        )
      ]),
      key: r'id',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class UserSumAggregateOutputType {
  const UserSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> id() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'id',
          fields: fields,
        )
      ]),
      key: r'id',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class UserMinAggregateOutputType {
  const UserMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> id() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'id',
          fields: fields,
        )
      ]),
      key: r'id',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> name() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'name',
          fields: fields,
        )
      ]),
      key: r'name',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> email() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'email',
          fields: fields,
        )
      ]),
      key: r'email',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> phone() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'phone',
          fields: fields,
        )
      ]),
      key: r'phone',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> password() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'password',
          fields: fields,
        )
      ]),
      key: r'password',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> avatarRef() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'avatarRef',
          fields: fields,
        )
      ]),
      key: r'avatarRef',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> unionId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'unionId',
          fields: fields,
        )
      ]),
      key: r'unionId',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> tencentId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'tencentId',
          fields: fields,
        )
      ]),
      key: r'tencentId',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> appleId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'appleId',
          fields: fields,
        )
      ]),
      key: r'appleId',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class UserMaxAggregateOutputType {
  const UserMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> id() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'id',
          fields: fields,
        )
      ]),
      key: r'id',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> name() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'name',
          fields: fields,
        )
      ]),
      key: r'name',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> email() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'email',
          fields: fields,
        )
      ]),
      key: r'email',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> phone() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'phone',
          fields: fields,
        )
      ]),
      key: r'phone',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> password() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'password',
          fields: fields,
        )
      ]),
      key: r'password',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> avatarRef() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'avatarRef',
          fields: fields,
        )
      ]),
      key: r'avatarRef',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> unionId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'unionId',
          fields: fields,
        )
      ]),
      key: r'unionId',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> tencentId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'tencentId',
          fields: fields,
        )
      ]),
      key: r'tencentId',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> appleId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'appleId',
          fields: fields,
        )
      ]),
      key: r'appleId',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class ProfileCountOutputType {
  const ProfileCountOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> categories() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'categories',
          fields: fields,
        )
      ]),
      key: r'categories',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> tags() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'tags',
          fields: fields,
        )
      ]),
      key: r'tags',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> tasks() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'tasks',
          fields: fields,
        )
      ]),
      key: r'tasks',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> channels() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'channels',
          fields: fields,
        )
      ]),
      key: r'channels',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> taskAssignments() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'taskAssignments',
          fields: fields,
        )
      ]),
      key: r'taskAssignments',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> channelSubscriptions() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'channelSubscriptions',
          fields: fields,
        )
      ]),
      key: r'channelSubscriptions',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> schedules() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'schedules',
          fields: fields,
        )
      ]),
      key: r'schedules',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> records() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'records',
          fields: fields,
        )
      ]),
      key: r'records',
    );
    return query(const []).then((value) => (value as int));
  }
}

class ProfileCountAggregateOutputType {
  const ProfileCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> name() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'name',
          fields: fields,
        )
      ]),
      key: r'name',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> color() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'color',
          fields: fields,
        )
      ]),
      key: r'color',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> icon() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'icon',
          fields: fields,
        )
      ]),
      key: r'icon',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class ProfileAvgAggregateOutputType {
  const ProfileAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class ProfileSumAggregateOutputType {
  const ProfileSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class ProfileMinAggregateOutputType {
  const ProfileMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> name() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'name',
          fields: fields,
        )
      ]),
      key: r'name',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> color() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'color',
          fields: fields,
        )
      ]),
      key: r'color',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> icon() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'icon',
          fields: fields,
        )
      ]),
      key: r'icon',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class ProfileMaxAggregateOutputType {
  const ProfileMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> name() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'name',
          fields: fields,
        )
      ]),
      key: r'name',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> color() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'color',
          fields: fields,
        )
      ]),
      key: r'color',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> icon() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'icon',
          fields: fields,
        )
      ]),
      key: r'icon',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class TaskCountOutputType {
  const TaskCountOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> children() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'children',
          fields: fields,
        )
      ]),
      key: r'children',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> assets() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'assets',
          fields: fields,
        )
      ]),
      key: r'assets',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> assignments() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'assignments',
          fields: fields,
        )
      ]),
      key: r'assignments',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> sessions() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'sessions',
          fields: fields,
        )
      ]),
      key: r'sessions',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> records() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'records',
          fields: fields,
        )
      ]),
      key: r'records',
    );
    return query(const []).then((value) => (value as int));
  }
}

class TaskCountAggregateOutputType {
  const TaskCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> uuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'uuid',
          fields: fields,
        )
      ]),
      key: r'uuid',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> title() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'title',
          fields: fields,
        )
      ]),
      key: r'title',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> desc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'desc',
          fields: fields,
        )
      ]),
      key: r'desc',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> content() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'content',
          fields: fields,
        )
      ]),
      key: r'content',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> location() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'location',
          fields: fields,
        )
      ]),
      key: r'location',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> requireLocation() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'requireLocation',
          fields: fields,
        )
      ]),
      key: r'requireLocation',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> requireTime() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'requireTime',
          fields: fields,
        )
      ]),
      key: r'requireTime',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> requireAttachment() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'requireAttachment',
          fields: fields,
        )
      ]),
      key: r'requireAttachment',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> profile() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profile',
          fields: fields,
        )
      ]),
      key: r'profile',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> parentUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'parentUuid',
          fields: fields,
        )
      ]),
      key: r'parentUuid',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> channelUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'channelUuid',
          fields: fields,
        )
      ]),
      key: r'channelUuid',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class TaskAvgAggregateOutputType {
  const TaskAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class TaskSumAggregateOutputType {
  const TaskSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class TaskMinAggregateOutputType {
  const TaskMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> uuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'uuid',
          fields: fields,
        )
      ]),
      key: r'uuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> title() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'title',
          fields: fields,
        )
      ]),
      key: r'title',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> desc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'desc',
          fields: fields,
        )
      ]),
      key: r'desc',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> content() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'content',
          fields: fields,
        )
      ]),
      key: r'content',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> location() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'location',
          fields: fields,
        )
      ]),
      key: r'location',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<bool?> requireLocation() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'requireLocation',
          fields: fields,
        )
      ]),
      key: r'requireLocation',
    );
    return query(const []).then((value) => (value as bool?));
  }

  Future<bool?> requireTime() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'requireTime',
          fields: fields,
        )
      ]),
      key: r'requireTime',
    );
    return query(const []).then((value) => (value as bool?));
  }

  Future<bool?> requireAttachment() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'requireAttachment',
          fields: fields,
        )
      ]),
      key: r'requireAttachment',
    );
    return query(const []).then((value) => (value as bool?));
  }

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> profile() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profile',
          fields: fields,
        )
      ]),
      key: r'profile',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> parentUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'parentUuid',
          fields: fields,
        )
      ]),
      key: r'parentUuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> channelUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'channelUuid',
          fields: fields,
        )
      ]),
      key: r'channelUuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class TaskMaxAggregateOutputType {
  const TaskMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> uuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'uuid',
          fields: fields,
        )
      ]),
      key: r'uuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> title() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'title',
          fields: fields,
        )
      ]),
      key: r'title',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> desc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'desc',
          fields: fields,
        )
      ]),
      key: r'desc',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> content() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'content',
          fields: fields,
        )
      ]),
      key: r'content',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> location() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'location',
          fields: fields,
        )
      ]),
      key: r'location',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<bool?> requireLocation() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'requireLocation',
          fields: fields,
        )
      ]),
      key: r'requireLocation',
    );
    return query(const []).then((value) => (value as bool?));
  }

  Future<bool?> requireTime() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'requireTime',
          fields: fields,
        )
      ]),
      key: r'requireTime',
    );
    return query(const []).then((value) => (value as bool?));
  }

  Future<bool?> requireAttachment() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'requireAttachment',
          fields: fields,
        )
      ]),
      key: r'requireAttachment',
    );
    return query(const []).then((value) => (value as bool?));
  }

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> profile() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profile',
          fields: fields,
        )
      ]),
      key: r'profile',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> parentUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'parentUuid',
          fields: fields,
        )
      ]),
      key: r'parentUuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> channelUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'channelUuid',
          fields: fields,
        )
      ]),
      key: r'channelUuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class TaskAssetCountAggregateOutputType {
  const TaskAssetCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> name() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'name',
          fields: fields,
        )
      ]),
      key: r'name',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> hash() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'hash',
          fields: fields,
        )
      ]),
      key: r'hash',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> assetRef() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'assetRef',
          fields: fields,
        )
      ]),
      key: r'assetRef',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> taskUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'taskUuid',
          fields: fields,
        )
      ]),
      key: r'taskUuid',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class TaskAssetAvgAggregateOutputType {
  const TaskAssetAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class TaskAssetSumAggregateOutputType {
  const TaskAssetSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class TaskAssetMinAggregateOutputType {
  const TaskAssetMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> name() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'name',
          fields: fields,
        )
      ]),
      key: r'name',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> hash() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'hash',
          fields: fields,
        )
      ]),
      key: r'hash',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> assetRef() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'assetRef',
          fields: fields,
        )
      ]),
      key: r'assetRef',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> taskUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'taskUuid',
          fields: fields,
        )
      ]),
      key: r'taskUuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class TaskAssetMaxAggregateOutputType {
  const TaskAssetMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> name() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'name',
          fields: fields,
        )
      ]),
      key: r'name',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> hash() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'hash',
          fields: fields,
        )
      ]),
      key: r'hash',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> assetRef() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'assetRef',
          fields: fields,
        )
      ]),
      key: r'assetRef',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> taskUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'taskUuid',
          fields: fields,
        )
      ]),
      key: r'taskUuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class ChannelCountOutputType {
  const ChannelCountOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> subscriptions() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'subscriptions',
          fields: fields,
        )
      ]),
      key: r'subscriptions',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> tasks() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'tasks',
          fields: fields,
        )
      ]),
      key: r'tasks',
    );
    return query(const []).then((value) => (value as int));
  }
}

class ChannelCountAggregateOutputType {
  const ChannelCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> uuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'uuid',
          fields: fields,
        )
      ]),
      key: r'uuid',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> name() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'name',
          fields: fields,
        )
      ]),
      key: r'name',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> desc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'desc',
          fields: fields,
        )
      ]),
      key: r'desc',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> color() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'color',
          fields: fields,
        )
      ]),
      key: r'color',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> imgRef() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'imgRef',
          fields: fields,
        )
      ]),
      key: r'imgRef',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class ChannelAvgAggregateOutputType {
  const ChannelAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class ChannelSumAggregateOutputType {
  const ChannelSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class ChannelMinAggregateOutputType {
  const ChannelMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> uuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'uuid',
          fields: fields,
        )
      ]),
      key: r'uuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> name() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'name',
          fields: fields,
        )
      ]),
      key: r'name',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> desc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'desc',
          fields: fields,
        )
      ]),
      key: r'desc',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> color() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'color',
          fields: fields,
        )
      ]),
      key: r'color',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> imgRef() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'imgRef',
          fields: fields,
        )
      ]),
      key: r'imgRef',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class ChannelMaxAggregateOutputType {
  const ChannelMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> uuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'uuid',
          fields: fields,
        )
      ]),
      key: r'uuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> name() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'name',
          fields: fields,
        )
      ]),
      key: r'name',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> desc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'desc',
          fields: fields,
        )
      ]),
      key: r'desc',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> color() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'color',
          fields: fields,
        )
      ]),
      key: r'color',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> imgRef() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'imgRef',
          fields: fields,
        )
      ]),
      key: r'imgRef',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class SessionCountOutputType {
  const SessionCountOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> schedules() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'schedules',
          fields: fields,
        )
      ]),
      key: r'schedules',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> records() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'records',
          fields: fields,
        )
      ]),
      key: r'records',
    );
    return query(const []).then((value) => (value as int));
  }
}

class SessionCountAggregateOutputType {
  const SessionCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> uuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'uuid',
          fields: fields,
        )
      ]),
      key: r'uuid',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> start() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'start',
          fields: fields,
        )
      ]),
      key: r'start',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> end() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'end',
          fields: fields,
        )
      ]),
      key: r'end',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> cycle() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'cycle',
          fields: fields,
        )
      ]),
      key: r'cycle',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> taskUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'taskUuid',
          fields: fields,
        )
      ]),
      key: r'taskUuid',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class SessionAvgAggregateOutputType {
  const SessionAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> start() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'start',
          fields: fields,
        )
      ]),
      key: r'start',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> end() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'end',
          fields: fields,
        )
      ]),
      key: r'end',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> cycle() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'cycle',
          fields: fields,
        )
      ]),
      key: r'cycle',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class SessionSumAggregateOutputType {
  const SessionSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> start() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'start',
          fields: fields,
        )
      ]),
      key: r'start',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> end() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'end',
          fields: fields,
        )
      ]),
      key: r'end',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> cycle() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'cycle',
          fields: fields,
        )
      ]),
      key: r'cycle',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class SessionMinAggregateOutputType {
  const SessionMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> uuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'uuid',
          fields: fields,
        )
      ]),
      key: r'uuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> start() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'start',
          fields: fields,
        )
      ]),
      key: r'start',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> end() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'end',
          fields: fields,
        )
      ]),
      key: r'end',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> cycle() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'cycle',
          fields: fields,
        )
      ]),
      key: r'cycle',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> taskUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'taskUuid',
          fields: fields,
        )
      ]),
      key: r'taskUuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class SessionMaxAggregateOutputType {
  const SessionMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> uuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'uuid',
          fields: fields,
        )
      ]),
      key: r'uuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> start() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'start',
          fields: fields,
        )
      ]),
      key: r'start',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> end() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'end',
          fields: fields,
        )
      ]),
      key: r'end',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> cycle() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'cycle',
          fields: fields,
        )
      ]),
      key: r'cycle',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> taskUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'taskUuid',
          fields: fields,
        )
      ]),
      key: r'taskUuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class RecordCountAggregateOutputType {
  const RecordCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> time() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'time',
          fields: fields,
        )
      ]),
      key: r'time',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> recordIndex() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'recordIndex',
          fields: fields,
        )
      ]),
      key: r'recordIndex',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> sessionUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'sessionUuid',
          fields: fields,
        )
      ]),
      key: r'sessionUuid',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> taskUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'taskUuid',
          fields: fields,
        )
      ]),
      key: r'taskUuid',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class RecordAvgAggregateOutputType {
  const RecordAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> time() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'time',
          fields: fields,
        )
      ]),
      key: r'time',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> recordIndex() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'recordIndex',
          fields: fields,
        )
      ]),
      key: r'recordIndex',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class RecordSumAggregateOutputType {
  const RecordSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> time() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'time',
          fields: fields,
        )
      ]),
      key: r'time',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<int?> recordIndex() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'recordIndex',
          fields: fields,
        )
      ]),
      key: r'recordIndex',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class RecordMinAggregateOutputType {
  const RecordMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> time() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'time',
          fields: fields,
        )
      ]),
      key: r'time',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<int?> recordIndex() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'recordIndex',
          fields: fields,
        )
      ]),
      key: r'recordIndex',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> sessionUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'sessionUuid',
          fields: fields,
        )
      ]),
      key: r'sessionUuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> taskUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'taskUuid',
          fields: fields,
        )
      ]),
      key: r'taskUuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class RecordMaxAggregateOutputType {
  const RecordMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> time() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'time',
          fields: fields,
        )
      ]),
      key: r'time',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<int?> recordIndex() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'recordIndex',
          fields: fields,
        )
      ]),
      key: r'recordIndex',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> sessionUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'sessionUuid',
          fields: fields,
        )
      ]),
      key: r'sessionUuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> taskUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'taskUuid',
          fields: fields,
        )
      ]),
      key: r'taskUuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class RecordAttachmentCountAggregateOutputType {
  const RecordAttachmentCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> hash() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'hash',
          fields: fields,
        )
      ]),
      key: r'hash',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> name() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'name',
          fields: fields,
        )
      ]),
      key: r'name',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> assetRef() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'assetRef',
          fields: fields,
        )
      ]),
      key: r'assetRef',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> sessionUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'sessionUuid',
          fields: fields,
        )
      ]),
      key: r'sessionUuid',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> taskUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'taskUuid',
          fields: fields,
        )
      ]),
      key: r'taskUuid',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> recordIndex() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'recordIndex',
          fields: fields,
        )
      ]),
      key: r'recordIndex',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class RecordAttachmentAvgAggregateOutputType {
  const RecordAttachmentAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> recordIndex() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'recordIndex',
          fields: fields,
        )
      ]),
      key: r'recordIndex',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class RecordAttachmentSumAggregateOutputType {
  const RecordAttachmentSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> recordIndex() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'recordIndex',
          fields: fields,
        )
      ]),
      key: r'recordIndex',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class RecordAttachmentMinAggregateOutputType {
  const RecordAttachmentMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> hash() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'hash',
          fields: fields,
        )
      ]),
      key: r'hash',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> name() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'name',
          fields: fields,
        )
      ]),
      key: r'name',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> assetRef() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'assetRef',
          fields: fields,
        )
      ]),
      key: r'assetRef',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> sessionUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'sessionUuid',
          fields: fields,
        )
      ]),
      key: r'sessionUuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> taskUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'taskUuid',
          fields: fields,
        )
      ]),
      key: r'taskUuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> recordIndex() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'recordIndex',
          fields: fields,
        )
      ]),
      key: r'recordIndex',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class RecordAttachmentMaxAggregateOutputType {
  const RecordAttachmentMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> hash() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'hash',
          fields: fields,
        )
      ]),
      key: r'hash',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> name() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'name',
          fields: fields,
        )
      ]),
      key: r'name',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> assetRef() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'assetRef',
          fields: fields,
        )
      ]),
      key: r'assetRef',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> sessionUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'sessionUuid',
          fields: fields,
        )
      ]),
      key: r'sessionUuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> taskUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'taskUuid',
          fields: fields,
        )
      ]),
      key: r'taskUuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> recordIndex() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'recordIndex',
          fields: fields,
        )
      ]),
      key: r'recordIndex',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class CategoryCountOutputType {
  const CategoryCountOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> assignments() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'assignments',
          fields: fields,
        )
      ]),
      key: r'assignments',
    );
    return query(const []).then((value) => (value as int));
  }
}

class CategoryCountAggregateOutputType {
  const CategoryCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> name() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'name',
          fields: fields,
        )
      ]),
      key: r'name',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> color() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'color',
          fields: fields,
        )
      ]),
      key: r'color',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> icon() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'icon',
          fields: fields,
        )
      ]),
      key: r'icon',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class CategoryAvgAggregateOutputType {
  const CategoryAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class CategorySumAggregateOutputType {
  const CategorySumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class CategoryMinAggregateOutputType {
  const CategoryMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> name() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'name',
          fields: fields,
        )
      ]),
      key: r'name',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> color() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'color',
          fields: fields,
        )
      ]),
      key: r'color',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> icon() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'icon',
          fields: fields,
        )
      ]),
      key: r'icon',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class CategoryMaxAggregateOutputType {
  const CategoryMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> name() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'name',
          fields: fields,
        )
      ]),
      key: r'name',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> color() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'color',
          fields: fields,
        )
      ]),
      key: r'color',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> icon() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'icon',
          fields: fields,
        )
      ]),
      key: r'icon',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class TagCountOutputType {
  const TagCountOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> assignments() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'assignments',
          fields: fields,
        )
      ]),
      key: r'assignments',
    );
    return query(const []).then((value) => (value as int));
  }
}

class TagCountAggregateOutputType {
  const TagCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> name() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'name',
          fields: fields,
        )
      ]),
      key: r'name',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> color() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'color',
          fields: fields,
        )
      ]),
      key: r'color',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> icon() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'icon',
          fields: fields,
        )
      ]),
      key: r'icon',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class TagAvgAggregateOutputType {
  const TagAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class TagSumAggregateOutputType {
  const TagSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class TagMinAggregateOutputType {
  const TagMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> name() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'name',
          fields: fields,
        )
      ]),
      key: r'name',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> color() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'color',
          fields: fields,
        )
      ]),
      key: r'color',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> icon() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'icon',
          fields: fields,
        )
      ]),
      key: r'icon',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class TagMaxAggregateOutputType {
  const TagMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> name() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'name',
          fields: fields,
        )
      ]),
      key: r'name',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> color() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'color',
          fields: fields,
        )
      ]),
      key: r'color',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> icon() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'icon',
          fields: fields,
        )
      ]),
      key: r'icon',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class TaskAssignmentCountOutputType {
  const TaskAssignmentCountOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> tags() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'tags',
          fields: fields,
        )
      ]),
      key: r'tags',
    );
    return query(const []).then((value) => (value as int));
  }
}

class TaskAssignmentCountAggregateOutputType {
  const TaskAssignmentCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> status() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'status',
          fields: fields,
        )
      ]),
      key: r'status',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> priority() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'priority',
          fields: fields,
        )
      ]),
      key: r'priority',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> starred() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'starred',
          fields: fields,
        )
      ]),
      key: r'starred',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> taskUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'taskUuid',
          fields: fields,
        )
      ]),
      key: r'taskUuid',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> categoryName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'categoryName',
          fields: fields,
        )
      ]),
      key: r'categoryName',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class TaskAssignmentAvgAggregateOutputType {
  const TaskAssignmentAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class TaskAssignmentSumAggregateOutputType {
  const TaskAssignmentSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class TaskAssignmentMinAggregateOutputType {
  const TaskAssignmentMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<TaskAssignmentStatus?> status() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'status',
          fields: fields,
        )
      ]),
      key: r'status',
    );
    return query(const []).then((value) => $enumDecodeNullable(
          _$TaskAssignmentStatusEnumMap,
          value,
        ));
  }

  Future<TaskPriority?> priority() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'priority',
          fields: fields,
        )
      ]),
      key: r'priority',
    );
    return query(const []).then((value) => $enumDecodeNullable(
          _$TaskPriorityEnumMap,
          value,
        ));
  }

  Future<bool?> starred() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'starred',
          fields: fields,
        )
      ]),
      key: r'starred',
    );
    return query(const []).then((value) => (value as bool?));
  }

  Future<String?> taskUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'taskUuid',
          fields: fields,
        )
      ]),
      key: r'taskUuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> categoryName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'categoryName',
          fields: fields,
        )
      ]),
      key: r'categoryName',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class TaskAssignmentMaxAggregateOutputType {
  const TaskAssignmentMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<TaskAssignmentStatus?> status() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'status',
          fields: fields,
        )
      ]),
      key: r'status',
    );
    return query(const []).then((value) => $enumDecodeNullable(
          _$TaskAssignmentStatusEnumMap,
          value,
        ));
  }

  Future<TaskPriority?> priority() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'priority',
          fields: fields,
        )
      ]),
      key: r'priority',
    );
    return query(const []).then((value) => $enumDecodeNullable(
          _$TaskPriorityEnumMap,
          value,
        ));
  }

  Future<bool?> starred() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'starred',
          fields: fields,
        )
      ]),
      key: r'starred',
    );
    return query(const []).then((value) => (value as bool?));
  }

  Future<String?> taskUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'taskUuid',
          fields: fields,
        )
      ]),
      key: r'taskUuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> categoryName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'categoryName',
          fields: fields,
        )
      ]),
      key: r'categoryName',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class TaskAssignmentTagsCountAggregateOutputType {
  const TaskAssignmentTagsCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> taskUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'taskUuid',
          fields: fields,
        )
      ]),
      key: r'taskUuid',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> tagName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'tagName',
          fields: fields,
        )
      ]),
      key: r'tagName',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class TaskAssignmentTagsAvgAggregateOutputType {
  const TaskAssignmentTagsAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class TaskAssignmentTagsSumAggregateOutputType {
  const TaskAssignmentTagsSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class TaskAssignmentTagsMinAggregateOutputType {
  const TaskAssignmentTagsMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> taskUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'taskUuid',
          fields: fields,
        )
      ]),
      key: r'taskUuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> tagName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'tagName',
          fields: fields,
        )
      ]),
      key: r'tagName',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class TaskAssignmentTagsMaxAggregateOutputType {
  const TaskAssignmentTagsMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> taskUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'taskUuid',
          fields: fields,
        )
      ]),
      key: r'taskUuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> tagName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'tagName',
          fields: fields,
        )
      ]),
      key: r'tagName',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class ChannelSubscriptionCountAggregateOutputType {
  const ChannelSubscriptionCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> shareRecord() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'shareRecord',
          fields: fields,
        )
      ]),
      key: r'shareRecord',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> channelUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'channelUuid',
          fields: fields,
        )
      ]),
      key: r'channelUuid',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class ChannelSubscriptionAvgAggregateOutputType {
  const ChannelSubscriptionAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class ChannelSubscriptionSumAggregateOutputType {
  const ChannelSubscriptionSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class ChannelSubscriptionMinAggregateOutputType {
  const ChannelSubscriptionMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<bool?> shareRecord() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'shareRecord',
          fields: fields,
        )
      ]),
      key: r'shareRecord',
    );
    return query(const []).then((value) => (value as bool?));
  }

  Future<String?> channelUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'channelUuid',
          fields: fields,
        )
      ]),
      key: r'channelUuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class ChannelSubscriptionMaxAggregateOutputType {
  const ChannelSubscriptionMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<bool?> shareRecord() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'shareRecord',
          fields: fields,
        )
      ]),
      key: r'shareRecord',
    );
    return query(const []).then((value) => (value as bool?));
  }

  Future<String?> channelUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'channelUuid',
          fields: fields,
        )
      ]),
      key: r'channelUuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class ScheduleCountAggregateOutputType {
  const ScheduleCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> relStart() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'relStart',
          fields: fields,
        )
      ]),
      key: r'relStart',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> relEnd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'relEnd',
          fields: fields,
        )
      ]),
      key: r'relEnd',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> sessionUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'sessionUuid',
          fields: fields,
        )
      ]),
      key: r'sessionUuid',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class ScheduleAvgAggregateOutputType {
  const ScheduleAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> relStart() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'relStart',
          fields: fields,
        )
      ]),
      key: r'relStart',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> relEnd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'relEnd',
          fields: fields,
        )
      ]),
      key: r'relEnd',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class ScheduleSumAggregateOutputType {
  const ScheduleSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> relStart() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'relStart',
          fields: fields,
        )
      ]),
      key: r'relStart',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> relEnd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'relEnd',
          fields: fields,
        )
      ]),
      key: r'relEnd',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class ScheduleMinAggregateOutputType {
  const ScheduleMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> relStart() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'relStart',
          fields: fields,
        )
      ]),
      key: r'relStart',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> relEnd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'relEnd',
          fields: fields,
        )
      ]),
      key: r'relEnd',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> sessionUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'sessionUuid',
          fields: fields,
        )
      ]),
      key: r'sessionUuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class ScheduleMaxAggregateOutputType {
  const ScheduleMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> relStart() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'relStart',
          fields: fields,
        )
      ]),
      key: r'relStart',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> relEnd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'relEnd',
          fields: fields,
        )
      ]),
      key: r'relEnd',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> sessionUuid() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'sessionUuid',
          fields: fields,
        )
      ]),
      key: r'sessionUuid',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'userId',
          fields: fields,
        )
      ]),
      key: r'userId',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> profileName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'profileName',
          fields: fields,
        )
      ]),
      key: r'profileName',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> updateAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'updateAt',
          fields: fields,
        )
      ]),
      key: r'updateAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> syncAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'syncAt',
          fields: fields,
        )
      ]),
      key: r'syncAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> deleteAt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'deleteAt',
          fields: fields,
        )
      ]),
      key: r'deleteAt',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class FileRefCountAggregateOutputType {
  const FileRefCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> hash() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'hash',
          fields: fields,
        )
      ]),
      key: r'hash',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'count',
          fields: fields,
        )
      ]),
      key: r'count',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class FileRefAvgAggregateOutputType {
  const FileRefAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'count',
          fields: fields,
        )
      ]),
      key: r'count',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class FileRefSumAggregateOutputType {
  const FileRefSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'count',
          fields: fields,
        )
      ]),
      key: r'count',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class FileRefMinAggregateOutputType {
  const FileRefMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> hash() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'hash',
          fields: fields,
        )
      ]),
      key: r'hash',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'count',
          fields: fields,
        )
      ]),
      key: r'count',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class FileRefMaxAggregateOutputType {
  const FileRefMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> hash() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'hash',
          fields: fields,
        )
      ]),
      key: r'hash',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'count',
          fields: fields,
        )
      ]),
      key: r'count',
    );
    return query(const []).then((value) => (value as int?));
  }
}

@JsonSerializable(
  createFactory: false,
  createToJson: true,
  includeIfNull: false,
)
class Datasources implements _i1.JsonSerializable {
  const Datasources({this.db});

  final String? db;

  @override
  Map<String, dynamic> toJson() => _$DatasourcesToJson(this);
}

class PrismaClient extends _i1.BasePrismaClient<PrismaClient> {
  PrismaClient._internal(
    _i3.Engine engine, {
    _i3.QueryEngineRequestHeaders? headers,
    _i3.TransactionInfo? transaction,
  })  : _engine = engine,
        _headers = headers,
        _transaction = transaction,
        super(
          engine,
          headers: headers,
          transaction: transaction,
        );

  factory PrismaClient({
    Datasources? datasources,
    Iterable<_i4.Event>? stdout,
    Iterable<_i4.Event>? event,
  }) {
    final logger = _i4.Logger(
      stdout: stdout,
      event: event,
    );
    final engine = _i5.BinaryEngine(
      logger: logger,
      schema:
          r'Z2VuZXJhdG9yIGNsaWVudCB7CiAgcHJvdmlkZXIgPSAiZGFydCBydW4gb3JtIgp9CgpkYXRhc291cmNlIGRiIHsKICBwcm92aWRlciA9ICJwb3N0Z3Jlc3FsIgogIHVybCAgICAgID0gZW52KCJEQVRBQkFTRV9VUkwiKQp9Cgptb2RlbCBVc2VyIHsKICBpZCAgICAgICAgSW50ICAgICAgICAgICAgIEBpZCBAZGVmYXVsdChhdXRvaW5jcmVtZW50KCkpCiAgbmFtZSAgICAgIFN0cmluZwogIGVtYWlsICAgICBTdHJpbmc/ICAgICAgICAgQHVuaXF1ZQogIHBob25lICAgICBTdHJpbmc/ICAgICAgICAgQHVuaXF1ZQogIHBhc3N3b3JkICBTdHJpbmcKICBhdmF0YXJSZWYgU3RyaW5nPwogIHVuaW9uSWQgICBTdHJpbmc/ICAgICAgICAgQHVuaXF1ZQogIHRlbmNlbnRJZCBTdHJpbmc/ICAgICAgICAgQHVuaXF1ZQogIGFwcGxlSWQgICBTdHJpbmc/ICAgICAgICAgQHVuaXF1ZQoKICBwcm9maWxlcyAgUHJvZmlsZVtdCn0KCm1vZGVsIFByb2ZpbGUgewogIC8vIGluZm9ybWF0aW9uCiAgbmFtZSAgICAgICAgICAgICAgICAgIFN0cmluZwogIGNvbG9yICAgICAgICAgICAgICAgICBTdHJpbmcKICBpY29uICAgICAgICAgICAgICAgICAgU3RyaW5nCiAgCiAgLy8gdXNlciBpbmZvCiAgdXNlcklkICAgICAgICAgICAgICAgIEludAogIHVzZXIgICAgICAgICAgICAgICAgICBVc2VyICAgIEByZWxhdGlvbihyZWZlcmVuY2VzOiBbaWRdLCBmaWVsZHM6IFt1c2VySWRdLCBvbkRlbGV0ZTogQ2FzY2FkZSkKCiAgLy8gcmVsYXRlZCBvYmplY3RzCiAgY2F0ZWdvcmllcyAgICAgICAgICAgIENhdGVnb3J5W10KICB0YWdzICAgICAgICAgICAgICAgICAgVGFnW10KICB0YXNrcyAgICAgICAgICAgICAgICAgVGFza1tdCiAgY2hhbm5lbHMgICAgICAgICAgICAgIENoYW5uZWxbXQogIHRhc2tBc3NpZ25tZW50cyAgICAgICBUYXNrQXNzaWdubWVudFtdCiAgY2hhbm5lbFN1YnNjcmlwdGlvbnMgIENoYW5uZWxTdWJzY3JpcHRpb25bXQogIHNjaGVkdWxlcyAgICAgICAgICAgICBTY2hlZHVsZVtdCiAgcmVjb3JkcyAgICAgICAgICAgICAgIFJlY29yZFtdCgogIC8vIHN5bmMgZmllbGRzCiAgdXBkYXRlQXQgICAgICAgICAgICAgIEJpZ0ludAogIHN5bmNBdCAgICAgICAgICAgICAgICBCaWdJbnQKICBkZWxldGVBdCAgICAgICAgICAgICAgQmlnSW50ICBAZGVmYXVsdCgtMSkKCiAgQEBpZChbdXNlcklkLCBuYW1lXSkKICBAQGluZGV4KFtzeW5jQXRdKQp9Cgptb2RlbCBUYXNrIHsKICAvLyB0YXNrIGluZm9ybWF0aW9uCiAgdXVpZCAgICAgICAgU3RyaW5nICAgICAgQGlkCiAgdGl0bGUgICAgICAgU3RyaW5nCiAgZGVzYyAgICAgICAgU3RyaW5nCiAgY29udGVudCAgICAgU3RyaW5nICAgICAgLy8gbWFya2Rvd24gc3R5bGVkIHRhc2sgY29udGVudAogIGxvY2F0aW9uICAgIFN0cmluZz8gICAgIC8vICdsb24tbGF0JyBsb2NhdGlvbgoKICAvLyB0YXNrIHJlcXVpcmVtZW50cwogIHJlcXVpcmVMb2NhdGlvbiAgIEJvb2xlYW4KICByZXF1aXJlVGltZSAgICAgICBCb29sZWFuCiAgcmVxdWlyZUF0dGFjaG1lbnQgQm9vbGVhbgoKICAvLyBvd25lcgogIHVzZXJJZCAgICAgIEludAogIHByb2ZpbGUgICAgIFN0cmluZwogIG93bmVyICAgICAgIFByb2ZpbGUgICAgIEByZWxhdGlvbihyZWZlcmVuY2VzOiBbdXNlcklkLCBuYW1lXSwgZmllbGRzOiBbdXNlcklkICwgcHJvZmlsZV0sIG9uRGVsZXRlOiBDYXNjYWRlKQoKICAvLyBwYXJlbnQKICBwYXJlbnRVdWlkICBTdHJpbmc/CiAgcGFyZW50ICAgICAgVGFzaz8gICAgICAgQHJlbGF0aW9uKCJUYXNrUGFyZW50IiwgcmVmZXJlbmNlczogW3V1aWRdLCBmaWVsZHM6IFtwYXJlbnRVdWlkXSwgb25EZWxldGU6IENhc2NhZGUpCiAgY2hpbGRyZW4gICAgVGFza1tdICAgICAgQHJlbGF0aW9uKCJUYXNrUGFyZW50IikKCiAgLy8gY2hhbm5lbAogIGNoYW5uZWxVdWlkIFN0cmluZz8KICBjaGFubmVsICAgICBDaGFubmVsPyAgICBAcmVsYXRpb24ocmVmZXJlbmNlczogW3V1aWRdLCBmaWVsZHM6IFtjaGFubmVsVXVpZF0sIG9uRGVsZXRlOiBDYXNjYWRlKQoKICAvLyByZWxhdGVkIG9iamVjdHMKICBhc3NldHMgICAgICBUYXNrQXNzZXRbXQogIGFzc2lnbm1lbnRzIFRhc2tBc3NpZ25tZW50W10KICBzZXNzaW9ucyAgICBTZXNzaW9uW10KICByZWNvcmRzICAgICBSZWNvcmRbXQoKICAvLyBzeW5jIGZpZWxkcwogIHVwZGF0ZUF0ICAgIEJpZ0ludAogIHN5bmNBdCAgICAgIEJpZ0ludAogIGRlbGV0ZUF0ICAgIEJpZ0ludCAgICAgIEBkZWZhdWx0KC0xKQoKICBAQGluZGV4KFtzeW5jQXRdKQp9Cgptb2RlbCBUYXNrQXNzZXQgewogIC8vIGluZm9ybWF0aW9uCiAgbmFtZSAgU3RyaW5nICAgIC8vIHRoZSBuYW1lIG9mIHRoZSBhc3NldCBmaWxlCiAgaGFzaCAgU3RyaW5nICAgIC8vIHRoZSBoYXNoIG9mIHRoZSBhc3NldCBmaWxlCiAgYXNzZXRSZWYgIFN0cmluZyAgICAvLyB0aGUgcmVmZXJlbmNlIG9mIHRoZSBhc3NldCBmaWxlCgogIC8vIHJlbGF0ZWQgdGFzawogIHRhc2tVdWlkICBTdHJpbmcgICAgLy8gdGhlIHV1aWQgb2YgdGhlIHRhc2sgdGhhdCB0aGUgYXNzZXQgYmVsb25ncyB0bwogIHRhc2sgICAgICBUYXNrICAgICAgQHJlbGF0aW9uKHJlZmVyZW5jZXM6IFt1dWlkXSwgZmllbGRzOiBbdGFza1V1aWRdLCBvbkRlbGV0ZTogQ2FzY2FkZSkKCiAgLy8gc3luYyBmaWVsZHMKICB1cGRhdGVBdCAgQmlnSW50CiAgc3luY0F0ICAgIEJpZ0ludAogIGRlbGV0ZUF0ICBCaWdJbnQgICAgQGRlZmF1bHQoLTEpCgogIEBAaWQoW3Rhc2tVdWlkLCBoYXNoXSkKICBAQGluZGV4KFtzeW5jQXRdKQp9Cgptb2RlbCBDaGFubmVsIHsKICAvLyBjaGFubmVsIGluZm9ybWF0aW9uCiAgdXVpZCAgICAgICAgICBTdHJpbmcgICAgICAgICAgICAgICAgICBAaWQKICBuYW1lICAgICAgICAgIFN0cmluZyAgICAgICAgICAgICAgICAgIC8vIHRoZSBuYW1lIG9mIHRoZSBjaGFubmVsCiAgZGVzYyAgICAgICAgICBTdHJpbmcgICAgICAgICAgICAgICAgICAvLyB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGNoYW5uZWwKICBjb2xvciAgICAgICAgIFN0cmluZyAgICAgICAgICAgICAgICAgIC8vIHRoZSBjb2xvciBvZiB0aGUgY2hhbm5lbAogIGltZ1JlZiAgICAgICAgU3RyaW5nPyAgICAgICAgICAgICAgICAgLy8gdGhlIGJhY2tncm91bmQgaW1hZ2Ugb2YgdGhlIGNoYW5uZWwKCiAgLy8gb3duZXIKICB1c2VySWQgICAgICAgIEludCAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSB1c2VyIGlkIG9mIHRoZSBvd25lciBwcm9maWxlCiAgcHJvZmlsZU5hbWUgICBTdHJpbmcgICAgICAgICAgICAgICAgICAvLyB0aGUgbmFtZSBvZiB0aGUgb3duZXIgcHJvZmlsZQogIG93bmVyICAgICAgICAgUHJvZmlsZSAgICAgICAgICAgICAgICAgQHJlbGF0aW9uKHJlZmVyZW5jZXM6IFt1c2VySWQsIG5hbWVdLCBmaWVsZHM6IFt1c2VySWQsIHByb2ZpbGVOYW1lXSwgb25EZWxldGU6IENhc2NhZGUpCgogIC8vIHJlbGF0ZWQgb2JqZWN0cwogIHN1YnNjcmlwdGlvbnMgQ2hhbm5lbFN1YnNjcmlwdGlvbltdCiAgdGFza3MgICAgICAgICBUYXNrW10gICAgICAgICAgICAgICAgICAvLyB0YXNrcyB0aGF0IGhhZCBiZWVuIHB1Ymxpc2hlZCB0byB0aGlzIGNoYW5uZWwKCiAgLy8gc3luYyBmaWVsZHMKICB1cGRhdGVBdCAgICAgIEJpZ0ludAogIHN5bmNBdCAgICAgICAgQmlnSW50CiAgZGVsZXRlQXQgICAgICBCaWdJbnQgICAgICAgICAgICAgICAgICBAZGVmYXVsdCgtMSkKCiAgQEBpbmRleChbc3luY0F0XSkKfQoKbW9kZWwgU2Vzc2lvbiB7CiAgLy8gaW5mb3JtYXRpb24KICB1dWlkICAgICAgICAgICAgICBTdHJpbmcgICAgICAgICAgICBAaWQKICBzdGFydCAgICAgICAgICAgICBCaWdJbnQgICAgICAgICAgICAvLyBzdGFydCB0aW1lc3RhbXAgKHVuaXggbWlsbGlzZWNvbmRzKSwgZm9yIG5vbi1yZXBlYXQgc2Vzc2lvbiwgaXQncyBzYW1lIGFzIGVuZAogIGVuZCAgICAgICAgICAgICAgIEJpZ0ludCAgICAgICAgICAgIC8vIGVuZCB0aW1lc3RhbXAgKHVuaXggbWlsbGlzZWNvbmRzKQogIGN5Y2xlICAgICAgICAgICAgIEJpZ0ludCAgICAgICAgICAgIC8vIHRoZSB0aW1lc3BhbiBvZiBvbmUgY3ljbGUgKHVuaXggbWlsbGlzZWNvbmRzKQoKICAvLyBwYXJlbnQgdGFzawogIHRhc2tVdWlkICAgICAgICAgIFN0cmluZwogIHRhc2sgICAgICAgICAgICAgIFRhc2sgICAgICAgICAgICAgIEByZWxhdGlvbihyZWZlcmVuY2VzOiBbdXVpZF0sIGZpZWxkczogW3Rhc2tVdWlkXSwgb25EZWxldGU6IENhc2NhZGUpCgogIC8vIHJlbGF0ZWQgb2JqZWN0cwogIHNjaGVkdWxlcyAgICAgICAgIFNjaGVkdWxlW10gICAgICAgIC8vIHNjaGVkdWxlcyBmb3IgdGhpcyBzZXNzaW9uCiAgcmVjb3JkcyAgICAgICAgICAgUmVjb3JkW10KCiAgLy8gc3luYyBmaWVsZHMKICB1cGRhdGVBdCAgICAgICAgICBCaWdJbnQKICBzeW5jQXQgICAgICAgICAgICBCaWdJbnQKICBkZWxldGVBdCAgICAgICAgICBCaWdJbnQKCiAgQEBpbmRleChbc3luY0F0XSkKfQoKbW9kZWwgUmVjb3JkIHsKICAvLyBpbmZvcm1hdGlvbgogIHRpbWUgICAgICAgIEJpZ0ludCAgICAvLyB0aGUgZmluaXNoIHRpbWUgb2YgdGhlIHJlbGF0ZWQgc2Vzc2lvbiB0YXNrICh1bml4IG1pbGxpc2Vjb25kcykKICByZWNvcmRJbmRleCBJbnQgICAgICAgLy8gdGhlIGluZGV4IG9mIHRoZSByZWNvcmQgaW4gdGhlIHNlc3Npb24KCiAgLy8gcGFyZW50IHNlc3Npb24KICBzZXNzaW9uVXVpZCBTdHJpbmcKICBzZXNzaW9uICAgICBTZXNzaW9uICAgQHJlbGF0aW9uKHJlZmVyZW5jZXM6IFt1dWlkXSwgZmllbGRzOiBbc2Vzc2lvblV1aWRdLCBvbkRlbGV0ZTogQ2FzY2FkZSkKCiAgLy8gcGFyZW50IHRhc2sKICB0YXNrVXVpZCAgICBTdHJpbmcKICB0YXNrICAgICAgICBUYXNrICAgICAgQHJlbGF0aW9uKHJlZmVyZW5jZXM6IFt1dWlkXSwgZmllbGRzOiBbdGFza1V1aWRdLCBvbkRlbGV0ZTogQ2FzY2FkZSkKCiAgLy8gcGFyZW50IHByb2ZpbGUKICB1c2VySWQgICAgICBJbnQKICBwcm9maWxlTmFtZSBTdHJpbmcKICBwcm9maWxlICAgICBQcm9maWxlICAgQHJlbGF0aW9uKHJlZmVyZW5jZXM6IFt1c2VySWQsIG5hbWVdLCBmaWVsZHM6IFt1c2VySWQsIHByb2ZpbGVOYW1lXSwgb25EZWxldGU6IENhc2NhZGUpCgogIC8vIHJlbGF0ZWQgb2JqZWN0cwogIGF0dGFjaG1lbnQgIFJlY29yZEF0dGFjaG1lbnQ/CgogIC8vIHN5bmMgZmllbGRzCiAgdXBkYXRlQXQgICAgQmlnSW50CiAgc3luY0F0ICAgICAgQmlnSW50CiAgZGVsZXRlQXQgICAgQmlnSW50CgogIEBAaWQoW3Nlc3Npb25VdWlkLCB0YXNrVXVpZCwgdXNlcklkLCBwcm9maWxlTmFtZSwgcmVjb3JkSW5kZXhdKQogIEBAaW5kZXgoW3N5bmNBdF0pCn0KCm1vZGVsIFJlY29yZEF0dGFjaG1lbnQgewogIC8vIGluZm9ybWF0aW9uCiAgaGFzaCAgICAgICAgU3RyaW5nCiAgbmFtZSAgICAgICAgU3RyaW5nCiAgYXNzZXRSZWYgICAgU3RyaW5nCgogIC8vIHJlbGF0ZWQgcmVjb3JkCiAgc2Vzc2lvblV1aWQgU3RyaW5nCiAgdGFza1V1aWQgICAgU3RyaW5nCiAgdXNlcklkICAgICAgSW50CiAgcHJvZmlsZU5hbWUgU3RyaW5nCiAgcmVjb3JkSW5kZXggSW50CiAgcmVjb3JkICAgICAgUmVjb3JkICAgIEByZWxhdGlvbihyZWZlcmVuY2VzOiBbc2Vzc2lvblV1aWQsIHRhc2tVdWlkLCB1c2VySWQsIHByb2ZpbGVOYW1lLCByZWNvcmRJbmRleF0sIGZpZWxkczogW3Nlc3Npb25VdWlkLCB0YXNrVXVpZCwgdXNlcklkLCBwcm9maWxlTmFtZSwgcmVjb3JkSW5kZXhdLCBvbkRlbGV0ZTogQ2FzY2FkZSkKCiAgLy8gc3luYyBmaWVsZHMKICB1cGRhdGVBdCAgICBCaWdJbnQKICBzeW5jQXQgICAgICBCaWdJbnQKICBkZWxldGVBdCAgICBCaWdJbnQKCiAgQEBpZChbc2Vzc2lvblV1aWQsIHRhc2tVdWlkLCB1c2VySWQsIHByb2ZpbGVOYW1lLCByZWNvcmRJbmRleF0pCiAgQEBpbmRleChbc3luY0F0XSkKfQoKbW9kZWwgQ2F0ZWdvcnkgewogIC8vIGluZm9ybWF0aW9uCiAgbmFtZSAgICAgICAgU3RyaW5nICAgICAgICAgICAgLy8gdGhlIG5hbWUgb2YgdGhlIGNhdGVnb3J5CiAgY29sb3IgICAgICAgU3RyaW5nICAgICAgICAgICAgLy8gdGhlIGNvbG9yIG9mIHRoZSBjYXRlZ29yeQogIGljb24gICAgICAgIFN0cmluZyAgICAgICAgICAgIC8vIHRoZSBpY29uIG9mIHRoZSBjYXRlZ29yeQoKICAvLyBvd25lcgogIHVzZXJJZCAgICAgIEludAogIHByb2ZpbGVOYW1lIFN0cmluZwogIHByb2ZpbGUgICAgIFByb2ZpbGUgICAgICAgICAgIEByZWxhdGlvbihyZWZlcmVuY2VzOiBbdXNlcklkLCBuYW1lXSwgZmllbGRzOiBbdXNlcklkLCBwcm9maWxlTmFtZV0sIG9uRGVsZXRlOiBDYXNjYWRlKQoKICAvLyByZWxhdGVkIG9iamVjdHMKICBhc3NpZ25tZW50cyBUYXNrQXNzaWdubWVudFtdCgogIC8vIHN5bmMgZmllbGRzCiAgdXBkYXRlQXQgICAgQmlnSW50CiAgc3luY0F0ICAgICAgQmlnSW50CiAgZGVsZXRlQXQgICAgQmlnSW50CgogIEBAaWQoW3VzZXJJZCwgcHJvZmlsZU5hbWUsIG5hbWVdKQogIEBAaW5kZXgoW3N5bmNBdF0pCn0KCm1vZGVsIFRhZyB7CiAgLy8gaW5mb3JtYXRpb24KICBuYW1lICAgICAgICBTdHJpbmcgICAgLy8gdGhlIG5hbWUgb2YgdGhlIHRhZwogIGNvbG9yICAgICAgIFN0cmluZyAgICAvLyB0aGUgY29sb3Igb2YgdGhlIHRhZwogIGljb24gICAgICAgIFN0cmluZyAgICAvLyB0aGUgaWNvbiBvZiB0aGUgdGFnCgogIC8vIG93bmVyCiAgdXNlcklkICAgICAgSW50CiAgcHJvZmlsZU5hbWUgU3RyaW5nCiAgcHJvZmlsZSAgICAgUHJvZmlsZSAgIEByZWxhdGlvbihyZWZlcmVuY2VzOiBbdXNlcklkLCBuYW1lXSwgZmllbGRzOiBbdXNlcklkLCBwcm9maWxlTmFtZV0sIG9uRGVsZXRlOiBDYXNjYWRlKQoKICAvLyByZWxhdGVkIG9iamVjdHMKICBhc3NpZ25tZW50cyBUYXNrQXNzaWdubWVudFRhZ3NbXQoKICAvLyBzeW5jIGZpZWxkcwogIHVwZGF0ZUF0ICAgIEJpZ0ludAogIHN5bmNBdCAgICAgIEJpZ0ludAogIGRlbGV0ZUF0ICAgIEJpZ0ludAoKICBAQGlkKFt1c2VySWQsIHByb2ZpbGVOYW1lLCBuYW1lXSkKICBAQGluZGV4KFtzeW5jQXRdKQp9CgplbnVtIFRhc2tBc3NpZ25tZW50U3RhdHVzIHsKICBBQ0NFUFRFRAogIFJFSkVDVEVECn0KCmVudW0gVGFza1ByaW9yaXR5IHsKICBOT05FCiAgTE9XCiAgTUVESVVNCiAgSElHSAogIFVSR0VOVAp9Cgptb2RlbCBUYXNrQXNzaWdubWVudCB7CiAgLy8gaW5mb3JtYXRpb24KICBzdGF0dXMgICAgICAgICAgICBUYXNrQXNzaWdubWVudFN0YXR1cwogIHByaW9yaXR5ICAgICAgICAgIFRhc2tQcmlvcml0eQogIHN0YXJyZWQgICAgICAgICAgIEJvb2xlYW4KCiAgLy8gcGFyZW50IHRhc2sKICB0YXNrVXVpZCAgICAgICAgICBTdHJpbmcKICB0YXNrICAgICAgICAgICAgICBUYXNrICAgICAgICAgICAgICAgICAgQHJlbGF0aW9uKHJlZmVyZW5jZXM6IFt1dWlkXSwgZmllbGRzOiBbdGFza1V1aWRdLCBvbkRlbGV0ZTogQ2FzY2FkZSkKICAKICAvLyBwcm9maWxlCiAgdXNlcklkICAgICAgICAgICAgSW50CiAgcHJvZmlsZU5hbWUgICAgICAgU3RyaW5nCiAgcHJvZmlsZSAgICAgICAgICAgUHJvZmlsZSAgICAgICAgICAgICAgIEByZWxhdGlvbihyZWZlcmVuY2VzOiBbdXNlcklkLCBuYW1lXSwgZmllbGRzOiBbdXNlcklkLCBwcm9maWxlTmFtZV0sIG9uRGVsZXRlOiBDYXNjYWRlKQoKICAvLyBjYXRlZ29yeQogIGNhdGVnb3J5TmFtZSAgICAgIFN0cmluZz8KICBjYXRlZ29yeSAgICAgICAgICBDYXRlZ29yeT8gICAgICAgICAgICAgQHJlbGF0aW9uKHJlZmVyZW5jZXM6IFt1c2VySWQsIHByb2ZpbGVOYW1lLCBuYW1lXSwgZmllbGRzOiBbdXNlcklkLCBwcm9maWxlTmFtZSwgY2F0ZWdvcnlOYW1lXSwgb25EZWxldGU6IENhc2NhZGUpCgogIC8vIHRhZwogIHRhZ3MgICAgICAgICAgICAgIFRhc2tBc3NpZ25tZW50VGFnc1tdCgogIC8vIHN5bmMgZmllbGRzCiAgdXBkYXRlQXQgICAgICAgICAgQmlnSW50CiAgc3luY0F0ICAgICAgICAgICAgQmlnSW50CiAgZGVsZXRlQXQgICAgICAgICAgQmlnSW50CgogIEBAaWQoW3Rhc2tVdWlkLCB1c2VySWQsIHByb2ZpbGVOYW1lXSkKICBAQGluZGV4KFtzeW5jQXRdKQp9Cgptb2RlbCBUYXNrQXNzaWdubWVudFRhZ3MgewogIC8vIHBhcmVudCBhc3NpZ25tZW50CiAgdGFza1V1aWQgICAgICAgICAgU3RyaW5nCiAgdXNlcklkICAgICAgICAgICAgSW50CiAgcHJvZmlsZU5hbWUgICAgICAgU3RyaW5nCiAgYXNzaWdubWVudCAgICAgICAgVGFza0Fzc2lnbm1lbnQgICAgICAgICBAcmVsYXRpb24ocmVmZXJlbmNlczogW3Rhc2tVdWlkLCB1c2VySWQsIHByb2ZpbGVOYW1lXSwgZmllbGRzOiBbdGFza1V1aWQsIHVzZXJJZCwgcHJvZmlsZU5hbWVdLCBvbkRlbGV0ZTogQ2FzY2FkZSkKCiAgLy8gcGFyZW50IHRhZwogIHRhZ05hbWUgICAgICAgICAgIFN0cmluZwogIHRhZyAgICAgICAgICAgICAgIFRhZyAgICAgICAgICAgICAgICAgICAgQHJlbGF0aW9uKHJlZmVyZW5jZXM6IFt1c2VySWQsIHByb2ZpbGVOYW1lLCBuYW1lXSwgZmllbGRzOiBbdXNlcklkLCBwcm9maWxlTmFtZSwgdGFnTmFtZV0sIG9uRGVsZXRlOiBDYXNjYWRlKQoKICBAQGlkKFt0YXNrVXVpZCwgdXNlcklkLCBwcm9maWxlTmFtZSwgdGFnTmFtZV0pCn0KCm1vZGVsIENoYW5uZWxTdWJzY3JpcHRpb24gewogIC8vIHN1YnNjcmlwdGlvbiBzZXR0aW5ncwogIHNoYXJlUmVjb3JkICAgQm9vbGVhbgoKICAvLyBwYXJlbnQgY2hhbm5lbAogIGNoYW5uZWxVdWlkICAgU3RyaW5nCiAgY2hhbm5lbCAgICAgICBDaGFubmVsICAgQHJlbGF0aW9uKHJlZmVyZW5jZXM6IFt1dWlkXSwgZmllbGRzOiBbY2hhbm5lbFV1aWRdLCBvbkRlbGV0ZTogQ2FzY2FkZSkKCiAgLy8gcHJvZmlsZQogIHVzZXJJZCAgICAgICAgSW50CiAgcHJvZmlsZU5hbWUgICBTdHJpbmcKICBwcm9maWxlICAgICAgIFByb2ZpbGUgICBAcmVsYXRpb24ocmVmZXJlbmNlczogW3VzZXJJZCwgbmFtZV0sIGZpZWxkczogW3VzZXJJZCwgcHJvZmlsZU5hbWVdLCBvbkRlbGV0ZTogQ2FzY2FkZSkKCiAgLy8gc3luYyBmaWVsZHMKICB1cGRhdGVBdCAgICAgIEJpZ0ludAogIHN5bmNBdCAgICAgICAgQmlnSW50CiAgZGVsZXRlQXQgICAgICBCaWdJbnQKCiAgQEBpZChbY2hhbm5lbFV1aWQsIHVzZXJJZCwgcHJvZmlsZU5hbWVdKQogIEBAaW5kZXgoW3N5bmNBdF0pCn0KCm1vZGVsIFNjaGVkdWxlIHsKICAvLyBpbmZvcm1hdGlvbgogIHJlbFN0YXJ0ICAgICAgQmlnSW50ICAgICAgLy8gcmVsYXRpdmUgc3RhcnQgdGltZSBpbiBtaWxsaXNlY29uZHMgYmFzZWQgb24gdGhlIHNlc3Npb24gdGFzayBkdWUKICByZWxFbmQgICAgICAgIEJpZ0ludCAgICAgIC8vIHJlbGF0aXZlIGVuZCB0aW1lIGluIG1pbGxpc2Vjb25kcyBiYXNlZCBvbiB0aGUgc2Vzc2lvbiB0YXNrIGR1ZQogIAogIC8vIHBhcmVudCBzZXNzaW9uCiAgc2Vzc2lvblV1aWQgICBTdHJpbmcKICBzZXNzaW9uICAgICAgIFNlc3Npb24gICAgIEByZWxhdGlvbihyZWZlcmVuY2VzOiBbdXVpZF0sIGZpZWxkczogW3Nlc3Npb25VdWlkXSwgb25EZWxldGU6IENhc2NhZGUpCgogIC8vIHByb2ZpbGUKICB1c2VySWQgICAgICAgIEludAogIHByb2ZpbGVOYW1lICAgU3RyaW5nCiAgcHJvZmlsZSAgICAgICBQcm9maWxlICAgICBAcmVsYXRpb24ocmVmZXJlbmNlczogW3VzZXJJZCwgbmFtZV0sIGZpZWxkczogW3VzZXJJZCwgcHJvZmlsZU5hbWVdLCBvbkRlbGV0ZTogQ2FzY2FkZSkKCiAgLy8gc3luYyBmaWVsZHMKICB1cGRhdGVBdCAgICAgIEJpZ0ludAogIHN5bmNBdCAgICAgICAgQmlnSW50CiAgZGVsZXRlQXQgICAgICBCaWdJbnQKCiAgQEBpZChbc2Vzc2lvblV1aWQsIHVzZXJJZCwgcHJvZmlsZU5hbWVdKQp9Cgptb2RlbCBGaWxlUmVmIHsKICBoYXNoICAgICAgICAgIFN0cmluZyAgICBAaWQKICBjb3VudCAgICAgICAgIEludD8gICAgICBAZGVmYXVsdCgxKQp9Cg==',
      datasources: datasources?.toJson().cast() ?? const {},
      executable:
          r'/Users/linloir/Dev/whatelse/whatelse_server/node_modules/prisma/query-engine-darwin-arm64',
    );
    return PrismaClient._internal(engine);
  }

  final _i3.Engine _engine;

  final _i3.QueryEngineRequestHeaders? _headers;

  final _i3.TransactionInfo? _transaction;

  @override
  PrismaClient copyWith({
    _i3.QueryEngineRequestHeaders? headers,
    _i3.TransactionInfo? transaction,
  }) =>
      PrismaClient._internal(
        _engine,
        headers: headers ?? _headers,
        transaction: transaction ?? _transaction,
      );
  _i1.ModelDelegate<User> get user => _i1.ModelDelegate<User>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );
  _i1.ModelDelegate<Profile> get profile => _i1.ModelDelegate<Profile>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );
  _i1.ModelDelegate<Task> get task => _i1.ModelDelegate<Task>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );
  _i1.ModelDelegate<TaskAsset> get taskAsset => _i1.ModelDelegate<TaskAsset>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );
  _i1.ModelDelegate<Channel> get channel => _i1.ModelDelegate<Channel>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );
  _i1.ModelDelegate<Session> get session => _i1.ModelDelegate<Session>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );
  _i1.ModelDelegate<Record> get record => _i1.ModelDelegate<Record>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );
  _i1.ModelDelegate<RecordAttachment> get recordAttachment =>
      _i1.ModelDelegate<RecordAttachment>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );
  _i1.ModelDelegate<Category> get category => _i1.ModelDelegate<Category>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );
  _i1.ModelDelegate<Tag> get tag => _i1.ModelDelegate<Tag>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );
  _i1.ModelDelegate<TaskAssignment> get taskAssignment =>
      _i1.ModelDelegate<TaskAssignment>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );
  _i1.ModelDelegate<TaskAssignmentTags> get taskAssignmentTags =>
      _i1.ModelDelegate<TaskAssignmentTags>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );
  _i1.ModelDelegate<ChannelSubscription> get channelSubscription =>
      _i1.ModelDelegate<ChannelSubscription>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );
  _i1.ModelDelegate<Schedule> get schedule => _i1.ModelDelegate<Schedule>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );
  _i1.ModelDelegate<FileRef> get fileRef => _i1.ModelDelegate<FileRef>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );
}
